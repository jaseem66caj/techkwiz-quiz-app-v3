"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/jaseemadmin/page",{

/***/ "(app-pages-browser)/./src/utils/quizDataManager.ts":
/*!**************************************!*\
  !*** ./src/utils/quizDataManager.ts ***!
  \**************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   QuizDataError: () => (/* binding */ QuizDataError),\n/* harmony export */   VALIDATION_RULES: () => (/* binding */ VALIDATION_RULES),\n/* harmony export */   quizDataManager: () => (/* binding */ quizDataManager)\n/* harmony export */ });\n/* harmony import */ var _types_admin__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/types/admin */ \"(app-pages-browser)/./src/types/admin.ts\");\n\n// Data validation schemas\nconst VALIDATION_RULES = {\n    QUESTION_MIN_LENGTH: 10,\n    QUESTION_MAX_LENGTH: 500,\n    OPTION_MIN_LENGTH: 1,\n    OPTION_MAX_LENGTH: 100,\n    MIN_OPTIONS: 4,\n    MAX_OPTIONS: 4,\n    MAX_BULK_OPERATIONS: 50,\n    MAX_FILE_SIZE: 5 * 1024 * 1024,\n    AUTO_SAVE_INTERVAL: 30000 // 30 seconds\n};\n// Error types\nclass QuizDataError extends Error {\n    constructor(message, code){\n        super(message), this.code = code;\n        this.name = 'QuizDataError';\n    }\n}\n// Utility functions for localStorage operations\nclass QuizDataManager {\n    static getInstance() {\n        if (!QuizDataManager.instance) {\n            QuizDataManager.instance = new QuizDataManager();\n        }\n        return QuizDataManager.instance;\n    }\n    // Safe localStorage operations with error handling\n    safeGetItem(key) {\n        // Return null if not on client side\n        if (false) {}\n        try {\n            return localStorage.getItem(key);\n        } catch (error) {\n            console.error(\"Error reading from localStorage key \".concat(key, \":\"), error);\n            return null;\n        }\n    }\n    safeSetItem(key, value) {\n        // Return false if not on client side\n        if (false) {}\n        try {\n            localStorage.setItem(key, value);\n            return true;\n        } catch (error) {\n            console.error(\"Error writing to localStorage key \".concat(key, \":\"), error);\n            if (error instanceof DOMException && error.code === 22) {\n                throw new QuizDataError('Storage quota exceeded. Please clear some data.', 'QUOTA_EXCEEDED');\n            }\n            return false;\n        }\n    }\n    // Question CRUD operations\n    getQuestions() {\n        const data = this.safeGetItem(_types_admin__WEBPACK_IMPORTED_MODULE_0__.QUIZ_STORAGE_KEYS.QUESTIONS);\n        if (!data) return this.initializeWithSampleData();\n        try {\n            const questions = JSON.parse(data);\n            return Array.isArray(questions) ? questions : [];\n        } catch (error) {\n            console.error('Error parsing questions data:', error);\n            return this.initializeWithSampleData();\n        }\n    }\n    saveQuestion(question) {\n        this.validateQuestion(question);\n        const questions = this.getQuestions();\n        const now = Date.now();\n        const newQuestion = {\n            ...question,\n            id: this.generateId(),\n            createdAt: now,\n            updatedAt: now\n        };\n        questions.push(newQuestion);\n        this.saveQuestions(questions);\n        return newQuestion;\n    }\n    updateQuestion(id, updates) {\n        const questions = this.getQuestions();\n        const index = questions.findIndex((q)=>q.id === id);\n        if (index === -1) {\n            throw new QuizDataError(\"Question with id \".concat(id, \" not found\"), 'NOT_FOUND');\n        }\n        const updatedQuestion = {\n            ...questions[index],\n            ...updates,\n            updatedAt: Date.now()\n        };\n        this.validateQuestion(updatedQuestion);\n        questions[index] = updatedQuestion;\n        this.saveQuestions(questions);\n        return updatedQuestion;\n    }\n    deleteQuestion(id) {\n        const questions = this.getQuestions();\n        const filteredQuestions = questions.filter((q)=>q.id !== id);\n        if (filteredQuestions.length === questions.length) {\n            throw new QuizDataError(\"Question with id \".concat(id, \" not found\"), 'NOT_FOUND');\n        }\n        this.saveQuestions(filteredQuestions);\n        return true;\n    }\n    bulkDelete(ids) {\n        if (ids.length > VALIDATION_RULES.MAX_BULK_OPERATIONS) {\n            throw new QuizDataError(\"Cannot delete more than \".concat(VALIDATION_RULES.MAX_BULK_OPERATIONS, \" questions at once\"), 'BULK_LIMIT_EXCEEDED');\n        }\n        const questions = this.getQuestions();\n        const initialCount = questions.length;\n        const filteredQuestions = questions.filter((q)=>!ids.includes(q.id));\n        const deletedCount = initialCount - filteredQuestions.length;\n        this.saveQuestions(filteredQuestions);\n        return {\n            success: true,\n            processedCount: deletedCount,\n            errorCount: ids.length - deletedCount,\n            errors: ids.length > deletedCount ? [\n                'Some questions were not found'\n            ] : []\n        };\n    }\n    // Search and filter operations\n    searchQuestions(filters) {\n        const questions = this.getQuestions();\n        return questions.filter((question)=>{\n            // Text search\n            if (filters.searchText) {\n                const searchLower = filters.searchText.toLowerCase();\n                if (!question.question.toLowerCase().includes(searchLower)) {\n                    return false;\n                }\n            }\n            // Category filter\n            if (filters.category !== 'all' && question.category !== filters.category) {\n                return false;\n            }\n            // Difficulty filter\n            if (filters.difficulty !== 'all' && question.difficulty !== filters.difficulty) {\n                return false;\n            }\n            // Type filter\n            if (filters.type !== 'all' && question.type !== filters.type) {\n                return false;\n            }\n            return true;\n        });\n    }\n    // Categories management\n    getCategories() {\n        const questions = this.getQuestions();\n        const categoryCounts = questions.reduce((acc, question)=>{\n            acc[question.category] = (acc[question.category] || 0) + 1;\n            return acc;\n        }, {});\n        return _types_admin__WEBPACK_IMPORTED_MODULE_0__.DEFAULT_CATEGORIES.map((category)=>({\n                ...category,\n                questionCount: categoryCounts[category.id] || 0\n            }));\n    }\n    // Draft management\n    saveDraft(draft) {\n        const drafts = this.getDrafts();\n        const existingIndex = drafts.findIndex((d)=>d.id === draft.id);\n        if (existingIndex >= 0) {\n            drafts[existingIndex] = {\n                ...draft,\n                lastSaved: Date.now()\n            };\n        } else {\n            drafts.push({\n                ...draft,\n                lastSaved: Date.now()\n            });\n        }\n        this.safeSetItem(_types_admin__WEBPACK_IMPORTED_MODULE_0__.QUIZ_STORAGE_KEYS.DRAFTS, JSON.stringify(drafts));\n    }\n    getDrafts() {\n        const data = this.safeGetItem(_types_admin__WEBPACK_IMPORTED_MODULE_0__.QUIZ_STORAGE_KEYS.DRAFTS);\n        if (!data) return [];\n        try {\n            return JSON.parse(data);\n        } catch (error) {\n            console.error('Error parsing drafts data:', error);\n            return [];\n        }\n    }\n    deleteDraft(id) {\n        const drafts = this.getDrafts().filter((d)=>d.id !== id);\n        this.safeSetItem(_types_admin__WEBPACK_IMPORTED_MODULE_0__.QUIZ_STORAGE_KEYS.DRAFTS, JSON.stringify(drafts));\n    }\n    // Settings management\n    getSettings() {\n        const data = this.safeGetItem(_types_admin__WEBPACK_IMPORTED_MODULE_0__.QUIZ_STORAGE_KEYS.SETTINGS);\n        if (!data) return this.getDefaultSettings();\n        try {\n            return {\n                ...this.getDefaultSettings(),\n                ...JSON.parse(data)\n            };\n        } catch (error) {\n            console.error('Error parsing settings data:', error);\n            return this.getDefaultSettings();\n        }\n    }\n    saveSettings(settings) {\n        const currentSettings = this.getSettings();\n        const updatedSettings = {\n            ...currentSettings,\n            ...settings\n        };\n        this.safeSetItem(_types_admin__WEBPACK_IMPORTED_MODULE_0__.QUIZ_STORAGE_KEYS.SETTINGS, JSON.stringify(updatedSettings));\n    }\n    getDefaultSettings() {\n        return {\n            pageSize: 10,\n            sortBy: 'updatedAt',\n            sortOrder: 'desc',\n            filters: {\n                searchText: '',\n                category: 'all',\n                difficulty: 'all',\n                type: 'all'\n            },\n            selectedQuestions: []\n        };\n    }\n    // Validation\n    validateQuestion(question) {\n        if (!question.question || question.question.length < VALIDATION_RULES.QUESTION_MIN_LENGTH) {\n            throw new QuizDataError(\"Question must be at least \".concat(VALIDATION_RULES.QUESTION_MIN_LENGTH, \" characters long\"), 'INVALID_QUESTION_LENGTH');\n        }\n        if (question.question.length > VALIDATION_RULES.QUESTION_MAX_LENGTH) {\n            throw new QuizDataError(\"Question must be no more than \".concat(VALIDATION_RULES.QUESTION_MAX_LENGTH, \" characters long\"), 'INVALID_QUESTION_LENGTH');\n        }\n        if (!question.options || question.options.length !== VALIDATION_RULES.MIN_OPTIONS) {\n            throw new QuizDataError(\"Question must have exactly \".concat(VALIDATION_RULES.MIN_OPTIONS, \" options\"), 'INVALID_OPTIONS_COUNT');\n        }\n        // Validate each option\n        question.options.forEach((option, index)=>{\n            if (!option || option.length < VALIDATION_RULES.OPTION_MIN_LENGTH) {\n                throw new QuizDataError(\"Option \".concat(index + 1, \" must be at least \").concat(VALIDATION_RULES.OPTION_MIN_LENGTH, \" character long\"), 'INVALID_OPTION_LENGTH');\n            }\n            if (option.length > VALIDATION_RULES.OPTION_MAX_LENGTH) {\n                throw new QuizDataError(\"Option \".concat(index + 1, \" must be no more than \").concat(VALIDATION_RULES.OPTION_MAX_LENGTH, \" characters long\"), 'INVALID_OPTION_LENGTH');\n            }\n        });\n        // Check for duplicate options\n        const uniqueOptions = new Set(question.options.map((opt)=>opt.toLowerCase().trim()));\n        if (uniqueOptions.size !== question.options.length) {\n            throw new QuizDataError('All options must be unique', 'DUPLICATE_OPTIONS');\n        }\n        // Validate correct answer\n        if (typeof question.correctAnswer !== 'number' || question.correctAnswer < 0 || question.correctAnswer >= question.options.length) {\n            throw new QuizDataError('Invalid correct answer selection', 'INVALID_CORRECT_ANSWER');\n        }\n        // Validate category\n        const validCategories = _types_admin__WEBPACK_IMPORTED_MODULE_0__.DEFAULT_CATEGORIES.map((c)=>c.id);\n        if (!question.category || !validCategories.includes(question.category)) {\n            throw new QuizDataError('Invalid category selection', 'INVALID_CATEGORY');\n        }\n    }\n    // Utility methods\n    saveQuestions(questions) {\n        this.safeSetItem(_types_admin__WEBPACK_IMPORTED_MODULE_0__.QUIZ_STORAGE_KEYS.QUESTIONS, JSON.stringify(questions));\n    }\n    generateId() {\n        return \"q_\".concat(Date.now(), \"_\").concat(Math.random().toString(36).substr(2, 9));\n    }\n    // CSV Export/Import functionality\n    exportToCSV(questions) {\n        const questionsToExport = questions || this.getQuestions();\n        const headers = [\n            'ID',\n            'Question',\n            'Option 1',\n            'Option 2',\n            'Option 3',\n            'Option 4',\n            'Correct Answer',\n            'Category',\n            'Difficulty',\n            'Type',\n            'Fun Fact',\n            'Tags',\n            'Created At',\n            'Updated At'\n        ];\n        const csvRows = [\n            headers.join(','),\n            ...questionsToExport.map((q)=>[\n                    q.id,\n                    '\"'.concat(q.question.replace(/\"/g, '\"\"'), '\"'),\n                    '\"'.concat(q.options[0].replace(/\"/g, '\"\"'), '\"'),\n                    '\"'.concat(q.options[1].replace(/\"/g, '\"\"'), '\"'),\n                    '\"'.concat(q.options[2].replace(/\"/g, '\"\"'), '\"'),\n                    '\"'.concat(q.options[3].replace(/\"/g, '\"\"'), '\"'),\n                    q.correctAnswer + 1,\n                    q.category,\n                    q.difficulty,\n                    q.type,\n                    '\"'.concat((q.funFact || '').replace(/\"/g, '\"\"'), '\"'),\n                    '\"'.concat((q.tags || []).join(';'), '\"'),\n                    new Date(q.createdAt).toISOString(),\n                    new Date(q.updatedAt).toISOString()\n                ].join(','))\n        ];\n        // Add UTF-8 BOM for Excel compatibility\n        return '\\uFEFF' + csvRows.join('\\n');\n    }\n    async importFromCSV(csvContent) {\n        const lines = csvContent.split('\\n').filter((line)=>line.trim());\n        if (lines.length < 2) {\n            throw new QuizDataError('CSV file must contain at least a header and one data row', 'INVALID_CSV_FORMAT');\n        }\n        const headers = lines[0].split(',').map((h)=>h.trim().replace(/\"/g, ''));\n        const dataLines = lines.slice(1);\n        const results = {\n            success: true,\n            processedCount: 0,\n            errorCount: 0,\n            errors: []\n        };\n        const validQuestions = [];\n        const existingQuestions = this.getQuestions();\n        for(let i = 0; i < dataLines.length; i++){\n            try {\n                const values = this.parseCSVLine(dataLines[i]);\n                if (values.length < 8) {\n                    results.errors.push(\"Line \".concat(i + 2, \": Insufficient data columns\"));\n                    results.errorCount++;\n                    continue;\n                }\n                const question = {\n                    id: values[0] || this.generateId(),\n                    question: values[1],\n                    options: [\n                        values[2],\n                        values[3],\n                        values[4],\n                        values[5]\n                    ],\n                    correctAnswer: parseInt(values[6]) - 1,\n                    category: values[7],\n                    difficulty: values[8],\n                    type: values[9] || 'regular',\n                    funFact: values[10] || undefined,\n                    tags: values[11] ? values[11].split(';').filter((t)=>t.trim()) : undefined,\n                    createdAt: values[12] ? new Date(values[12]).getTime() : Date.now(),\n                    updatedAt: values[13] ? new Date(values[13]).getTime() : Date.now()\n                };\n                // Validate the question\n                this.validateQuestion(question);\n                // Check for duplicates\n                const existingIndex = existingQuestions.findIndex((q)=>q.id === question.id);\n                if (existingIndex >= 0) {\n                    // Update existing question\n                    existingQuestions[existingIndex] = question;\n                } else {\n                    validQuestions.push(question);\n                }\n                results.processedCount++;\n            } catch (error) {\n                results.errors.push(\"Line \".concat(i + 2, \": \").concat(error instanceof Error ? error.message : 'Unknown error'));\n                results.errorCount++;\n            }\n        }\n        // Save all valid questions\n        if (validQuestions.length > 0) {\n            const allQuestions = [\n                ...existingQuestions,\n                ...validQuestions\n            ];\n            this.saveQuestions(allQuestions);\n        }\n        results.success = results.errorCount === 0;\n        return results;\n    }\n    parseCSVLine(line) {\n        const result = [];\n        let current = '';\n        let inQuotes = false;\n        for(let i = 0; i < line.length; i++){\n            const char = line[i];\n            if (char === '\"') {\n                if (inQuotes && line[i + 1] === '\"') {\n                    current += '\"';\n                    i++; // Skip next quote\n                } else {\n                    inQuotes = !inQuotes;\n                }\n            } else if (char === ',' && !inQuotes) {\n                result.push(current.trim());\n                current = '';\n            } else {\n                current += char;\n            }\n        }\n        result.push(current.trim());\n        return result;\n    }\n    initializeWithSampleData() {\n        // Initialize with a few sample questions for demonstration\n        const sampleQuestions = [\n            {\n                id: 'sample_1',\n                question: 'Which social media platform is known for its short-form video content and viral dances?',\n                options: [\n                    'Instagram',\n                    'TikTok',\n                    'Twitter',\n                    'Snapchat'\n                ],\n                correctAnswer: 1,\n                category: 'social-media',\n                difficulty: 'beginner',\n                type: 'regular',\n                funFact: 'TikTok was originally called Musical.ly before being acquired by ByteDance.',\n                tags: [\n                    'social-media',\n                    'video',\n                    'viral'\n                ],\n                createdAt: Date.now() - 86400000,\n                updatedAt: Date.now() - 86400000\n            }\n        ];\n        this.saveQuestions(sampleQuestions);\n        return sampleQuestions;\n    }\n    // Backup and restore functionality\n    createBackup() {\n        const backup = {\n            questions: this.getQuestions(),\n            settings: this.getSettings(),\n            drafts: this.getDrafts(),\n            timestamp: Date.now(),\n            version: '1.0'\n        };\n        return JSON.stringify(backup, null, 2);\n    }\n    restoreFromBackup(backupData) {\n        try {\n            const backup = JSON.parse(backupData);\n            if (!backup.questions || !Array.isArray(backup.questions)) {\n                throw new QuizDataError('Invalid backup format: missing questions array', 'INVALID_BACKUP');\n            }\n            // Validate all questions in backup\n            backup.questions.forEach((q, index)=>{\n                try {\n                    this.validateQuestion(q);\n                } catch (error) {\n                    throw new QuizDataError(\"Invalid question at index \".concat(index, \": \").concat(error instanceof Error ? error.message : 'Unknown error'), 'INVALID_BACKUP_QUESTION');\n                }\n            });\n            // Create current backup before restore\n            const currentBackup = this.createBackup();\n            this.safeSetItem(_types_admin__WEBPACK_IMPORTED_MODULE_0__.QUIZ_STORAGE_KEYS.BACKUP, currentBackup);\n            // Restore data\n            this.saveQuestions(backup.questions);\n            if (backup.settings) {\n                this.safeSetItem(_types_admin__WEBPACK_IMPORTED_MODULE_0__.QUIZ_STORAGE_KEYS.SETTINGS, JSON.stringify(backup.settings));\n            }\n            if (backup.drafts) {\n                this.safeSetItem(_types_admin__WEBPACK_IMPORTED_MODULE_0__.QUIZ_STORAGE_KEYS.DRAFTS, JSON.stringify(backup.drafts));\n            }\n            return {\n                success: true,\n                processedCount: backup.questions.length,\n                errorCount: 0,\n                errors: []\n            };\n        } catch (error) {\n            throw new QuizDataError(\"Failed to restore backup: \".concat(error instanceof Error ? error.message : 'Unknown error'), 'RESTORE_FAILED');\n        }\n    }\n    // Auto-save functionality for drafts\n    startAutoSave(draftId, getDraftData) {\n        this.stopAutoSave();\n        this.autoSaveTimer = setInterval(()=>{\n            try {\n                const draftData = getDraftData();\n                if (draftData.question && draftData.question.length > 0) {\n                    const draft = {\n                        id: draftId,\n                        question: draftData.question || '',\n                        options: draftData.options || [\n                            '',\n                            '',\n                            '',\n                            ''\n                        ],\n                        correctAnswer: draftData.correctAnswer || 0,\n                        category: draftData.category || 'facts',\n                        difficulty: draftData.difficulty || 'beginner',\n                        type: draftData.type || 'regular',\n                        funFact: draftData.funFact,\n                        tags: draftData.tags,\n                        lastSaved: Date.now()\n                    };\n                    this.saveDraft(draft);\n                }\n            } catch (error) {\n                console.error('Auto-save failed:', error);\n            }\n        }, VALIDATION_RULES.AUTO_SAVE_INTERVAL);\n    }\n    stopAutoSave() {\n        if (this.autoSaveTimer) {\n            clearInterval(this.autoSaveTimer);\n            this.autoSaveTimer = null;\n        }\n    }\n    // CSV Export functionality\n    exportToCSV(questionsToExport) {\n        const questions = questionsToExport || this.getQuestions();\n        const headers = [\n            'ID',\n            'Question',\n            'Option 1',\n            'Option 2',\n            'Option 3',\n            'Option 4',\n            'Correct Answer (1-4)',\n            'Category',\n            'Difficulty',\n            'Type',\n            'Fun Fact',\n            'Tags',\n            'Created At',\n            'Updated At'\n        ];\n        const csvRows = [\n            headers.join(',')\n        ];\n        questions.forEach((question)=>{\n            var _question_options_, _question_options_1, _question_options_2, _question_options_3;\n            const row = [\n                question.id,\n                '\"'.concat(question.question.replace(/\"/g, '\"\"'), '\"'),\n                '\"'.concat(((_question_options_ = question.options[0]) === null || _question_options_ === void 0 ? void 0 : _question_options_.replace(/\"/g, '\"\"')) || '', '\"'),\n                '\"'.concat(((_question_options_1 = question.options[1]) === null || _question_options_1 === void 0 ? void 0 : _question_options_1.replace(/\"/g, '\"\"')) || '', '\"'),\n                '\"'.concat(((_question_options_2 = question.options[2]) === null || _question_options_2 === void 0 ? void 0 : _question_options_2.replace(/\"/g, '\"\"')) || '', '\"'),\n                '\"'.concat(((_question_options_3 = question.options[3]) === null || _question_options_3 === void 0 ? void 0 : _question_options_3.replace(/\"/g, '\"\"')) || '', '\"'),\n                question.correctAnswer + 1,\n                question.category,\n                question.difficulty,\n                question.type,\n                '\"'.concat((question.funFact || '').replace(/\"/g, '\"\"'), '\"'),\n                '\"'.concat((question.tags || []).join(';'), '\"'),\n                new Date(question.createdAt).toISOString(),\n                new Date(question.updatedAt).toISOString()\n            ];\n            csvRows.push(row.join(','));\n        });\n        return csvRows.join('\\n');\n    }\n    // Download CSV file\n    downloadCSV() {\n        try {\n            const csvContent = this.exportToCSV();\n            const blob = new Blob([\n                csvContent\n            ], {\n                type: 'text/csv;charset=utf-8;'\n            });\n            const link = document.createElement('a');\n            if (link.download !== undefined) {\n                const url = URL.createObjectURL(blob);\n                link.setAttribute('href', url);\n                link.setAttribute('download', \"techkwiz-questions-\".concat(new Date().toISOString().split('T')[0], \".csv\"));\n                link.style.visibility = 'hidden';\n                document.body.appendChild(link);\n                link.click();\n                document.body.removeChild(link);\n                URL.revokeObjectURL(url);\n            }\n        } catch (error) {\n            throw new QuizDataError('Failed to download CSV file', 'EXPORT_ERROR');\n        }\n    }\n    // Parse CSV content\n    parseCSV(csvContent) {\n        const lines = csvContent.split('\\n').filter((line)=>line.trim());\n        const errors = [];\n        const questions = [];\n        if (lines.length < 2) {\n            errors.push('CSV file must contain at least a header row and one data row');\n            return {\n                questions,\n                errors\n            };\n        }\n        // Skip header row\n        const dataLines = lines.slice(1);\n        dataLines.forEach((line, index)=>{\n            try {\n                const values = this.parseCSVLine(line);\n                if (values.length < 8) {\n                    errors.push(\"Row \".concat(index + 2, \": Insufficient columns (minimum 8 required)\"));\n                    return;\n                }\n                const [id, question, opt1, opt2, opt3, opt4, correctAnswer, category, difficulty, type, funFact, tags, createdAt, updatedAt] = values;\n                // Validate required fields\n                if (!(question === null || question === void 0 ? void 0 : question.trim())) {\n                    errors.push(\"Row \".concat(index + 2, \": Question is required\"));\n                    return;\n                }\n                if (!(opt1 === null || opt1 === void 0 ? void 0 : opt1.trim()) || !(opt2 === null || opt2 === void 0 ? void 0 : opt2.trim()) || !(opt3 === null || opt3 === void 0 ? void 0 : opt3.trim()) || !(opt4 === null || opt4 === void 0 ? void 0 : opt4.trim())) {\n                    errors.push(\"Row \".concat(index + 2, \": All 4 options are required\"));\n                    return;\n                }\n                const correctAnswerNum = parseInt(correctAnswer) - 1 // Convert 1-based to 0-based\n                ;\n                if (isNaN(correctAnswerNum) || correctAnswerNum < 0 || correctAnswerNum > 3) {\n                    errors.push(\"Row \".concat(index + 2, \": Correct answer must be 1, 2, 3, or 4\"));\n                    return;\n                }\n                if (!(category === null || category === void 0 ? void 0 : category.trim())) {\n                    errors.push(\"Row \".concat(index + 2, \": Category is required\"));\n                    return;\n                }\n                if (![\n                    'beginner',\n                    'intermediate',\n                    'advanced'\n                ].includes(difficulty)) {\n                    errors.push(\"Row \".concat(index + 2, \": Difficulty must be 'beginner', 'intermediate', or 'advanced'\"));\n                    return;\n                }\n                if (![\n                    'regular',\n                    'bonus'\n                ].includes(type)) {\n                    errors.push(\"Row \".concat(index + 2, \": Type must be 'regular' or 'bonus'\"));\n                    return;\n                }\n                const questionData = {\n                    id: id || \"imported_\".concat(Date.now(), \"_\").concat(index),\n                    question: question.trim(),\n                    options: [\n                        opt1.trim(),\n                        opt2.trim(),\n                        opt3.trim(),\n                        opt4.trim()\n                    ],\n                    correctAnswer: correctAnswerNum,\n                    category: category.trim(),\n                    difficulty: difficulty,\n                    type: type,\n                    funFact: (funFact === null || funFact === void 0 ? void 0 : funFact.trim()) || undefined,\n                    tags: tags ? tags.split(';').map((tag)=>tag.trim()).filter(Boolean) : [],\n                    createdAt: createdAt ? new Date(createdAt).getTime() : Date.now(),\n                    updatedAt: updatedAt ? new Date(updatedAt).getTime() : Date.now()\n                };\n                questions.push(questionData);\n            } catch (error) {\n                errors.push(\"Row \".concat(index + 2, \": \").concat(error instanceof Error ? error.message : 'Parse error'));\n            }\n        });\n        return {\n            questions,\n            errors\n        };\n    }\n    // Helper to parse CSV line with proper quote handling\n    parseCSVLine(line) {\n        const result = [];\n        let current = '';\n        let inQuotes = false;\n        let i = 0;\n        while(i < line.length){\n            const char = line[i];\n            if (char === '\"') {\n                if (inQuotes && line[i + 1] === '\"') {\n                    // Escaped quote\n                    current += '\"';\n                    i += 2;\n                } else {\n                    // Toggle quote state\n                    inQuotes = !inQuotes;\n                    i++;\n                }\n            } else if (char === ',' && !inQuotes) {\n                // End of field\n                result.push(current);\n                current = '';\n                i++;\n            } else {\n                current += char;\n                i++;\n            }\n        }\n        result.push(current); // Add last field\n        return result;\n    }\n    // Import from CSV\n    importFromCSV(csvContent) {\n        try {\n            const { questions, errors } = this.parseCSV(csvContent);\n            if (errors.length > 0) {\n                return {\n                    success: false,\n                    processedCount: 0,\n                    errorCount: errors.length,\n                    errors\n                };\n            }\n            let successCount = 0;\n            const importErrors = [];\n            questions.forEach((questionData, index)=>{\n                try {\n                    const fullQuestion = {\n                        id: questionData.id,\n                        question: questionData.question,\n                        options: questionData.options,\n                        correctAnswer: questionData.correctAnswer,\n                        category: questionData.category,\n                        difficulty: questionData.difficulty,\n                        type: questionData.type,\n                        funFact: questionData.funFact,\n                        tags: questionData.tags || [],\n                        createdAt: questionData.createdAt,\n                        updatedAt: questionData.updatedAt\n                    };\n                    // Validate the complete question\n                    const validation = this.validateQuestion(fullQuestion);\n                    if (!validation.isValid) {\n                        importErrors.push(\"Question \".concat(index + 1, \": \").concat(validation.errors.join(', ')));\n                        return;\n                    }\n                    this.saveQuestion(fullQuestion);\n                    successCount++;\n                } catch (error) {\n                    importErrors.push(\"Question \".concat(index + 1, \": \").concat(error instanceof Error ? error.message : 'Save error'));\n                }\n            });\n            return {\n                success: importErrors.length === 0,\n                processedCount: successCount,\n                errorCount: importErrors.length,\n                errors: importErrors\n            };\n        } catch (error) {\n            return {\n                success: false,\n                processedCount: 0,\n                errorCount: 1,\n                errors: [\n                    error instanceof Error ? error.message : 'Import failed'\n                ]\n            };\n        }\n    }\n    constructor(){\n        this.autoSaveTimer = null;\n    }\n}\n// Export singleton instance\nconst quizDataManager = QuizDataManager.getInstance();\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy91dGlscy9xdWl6RGF0YU1hbmFnZXIudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQVNzQjtBQUV0QiwwQkFBMEI7QUFDbkIsTUFBTUUsbUJBQW1CO0lBQzlCQyxxQkFBcUI7SUFDckJDLHFCQUFxQjtJQUNyQkMsbUJBQW1CO0lBQ25CQyxtQkFBbUI7SUFDbkJDLGFBQWE7SUFDYkMsYUFBYTtJQUNiQyxxQkFBcUI7SUFDckJDLGVBQWUsSUFBSSxPQUFPO0lBQzFCQyxvQkFBb0IsTUFBTSxhQUFhO0FBQ3pDLEVBQVU7QUFFVixjQUFjO0FBQ1AsTUFBTUMsc0JBQXNCQztJQUNqQyxZQUFZQyxPQUFlLEVBQUUsSUFBbUIsQ0FBRTtRQUNoRCxLQUFLLENBQUNBLGVBRDRCQyxPQUFBQTtRQUVsQyxJQUFJLENBQUNDLElBQUksR0FBRztJQUNkO0FBQ0Y7QUFFQSxnREFBZ0Q7QUFDaEQsTUFBTUM7SUFJSixPQUFPQyxjQUErQjtRQUNwQyxJQUFJLENBQUNELGdCQUFnQkUsUUFBUSxFQUFFO1lBQzdCRixnQkFBZ0JFLFFBQVEsR0FBRyxJQUFJRjtRQUNqQztRQUNBLE9BQU9BLGdCQUFnQkUsUUFBUTtJQUNqQztJQUVBLG1EQUFtRDtJQUMzQ0MsWUFBWUMsR0FBVyxFQUFpQjtRQUM5QyxvQ0FBb0M7UUFDcEMsSUFBSSxLQUE2QixFQUFFLEVBRWxDO1FBRUQsSUFBSTtZQUNGLE9BQU9DLGFBQWFDLE9BQU8sQ0FBQ0Y7UUFDOUIsRUFBRSxPQUFPRyxPQUFPO1lBQ2RDLFFBQVFELEtBQUssQ0FBQyx1Q0FBMkMsT0FBSkgsS0FBSSxNQUFJRztZQUM3RCxPQUFPO1FBQ1Q7SUFDRjtJQUVRRSxZQUFZTCxHQUFXLEVBQUVNLEtBQWEsRUFBVztRQUN2RCxxQ0FBcUM7UUFDckMsSUFBSSxLQUE2QixFQUFFLEVBRWxDO1FBRUQsSUFBSTtZQUNGTCxhQUFhTSxPQUFPLENBQUNQLEtBQUtNO1lBQzFCLE9BQU87UUFDVCxFQUFFLE9BQU9ILE9BQU87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QUFpQztvQkFDakMsTUFBTXlKLGFBQWEsSUFBSSxDQUFDaEssZ0JBQWdCLENBQUMrSjtvQkFDekMsSUFBSSxDQUFDQyxXQUFXQyxPQUFPLEVBQUU7d0JBQ3ZCSCxhQUFhdEosSUFBSSxDQUFDLFlBQTBCd0osT0FBZHBKLFFBQVEsR0FBRSxNQUFpQyxPQUE3Qm9KLFdBQVdwSSxNQUFNLENBQUN1RCxJQUFJLENBQUM7d0JBQ25FO29CQUNGO29CQUVBLElBQUksQ0FBQ3JGLFlBQVksQ0FBQ2lLO29CQUNsQkY7Z0JBQ0YsRUFBRSxPQUFPOUssT0FBTztvQkFDZCtLLGFBQWF0SixJQUFJLENBQUMsWUFBMEJ6QixPQUFkNkIsUUFBUSxHQUFFLE1BQTBELE9BQXREN0IsaUJBQWlCWCxRQUFRVyxNQUFNVixPQUFPLEdBQUc7Z0JBQ3ZGO1lBQ0Y7WUFFQSxPQUFPO2dCQUNMb0QsU0FBU3FJLGFBQWEzSSxNQUFNLEtBQUs7Z0JBQ2pDTyxnQkFBZ0JtSTtnQkFDaEJsSSxZQUFZbUksYUFBYTNJLE1BQU07Z0JBQy9CUyxRQUFRa0k7WUFDVjtRQUNGLEVBQUUsT0FBTy9LLE9BQU87WUFDZCxPQUFPO2dCQUNMMEMsU0FBUztnQkFDVEMsZ0JBQWdCO2dCQUNoQkMsWUFBWTtnQkFDWkMsUUFBUTtvQkFBQzdDLGlCQUFpQlgsUUFBUVcsTUFBTVYsT0FBTyxHQUFHO2lCQUFnQjtZQUNwRTtRQUNGO0lBQ0Y7O2FBbHlCUXVKLGdCQUF1Qzs7QUFteUJqRDtBQUVBLDRCQUE0QjtBQUNyQixNQUFNc0Msa0JBQWtCMUwsZ0JBQWdCQyxXQUFXLEdBQUUiLCJzb3VyY2VzIjpbIi9Vc2Vycy9qYXNlZW0vRG9jdW1lbnRzL0dpdEh1Yi9UZWNoa3dpei12Ny9mcm9udGVuZC9zcmMvdXRpbHMvcXVpekRhdGFNYW5hZ2VyLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFxuICBRdWl6UXVlc3Rpb24sIFxuICBRdWl6Q2F0ZWdvcnksIFxuICBTZWFyY2hGaWx0ZXJzLCBcbiAgQnVsa09wZXJhdGlvblJlc3VsdCwgXG4gIFF1ZXN0aW9uRHJhZnQsXG4gIFF1aXpNYW5hZ2VtZW50U2V0dGluZ3MsXG4gIFFVSVpfU1RPUkFHRV9LRVlTLFxuICBERUZBVUxUX0NBVEVHT1JJRVMgXG59IGZyb20gJ0AvdHlwZXMvYWRtaW4nXG5cbi8vIERhdGEgdmFsaWRhdGlvbiBzY2hlbWFzXG5leHBvcnQgY29uc3QgVkFMSURBVElPTl9SVUxFUyA9IHtcbiAgUVVFU1RJT05fTUlOX0xFTkdUSDogMTAsXG4gIFFVRVNUSU9OX01BWF9MRU5HVEg6IDUwMCxcbiAgT1BUSU9OX01JTl9MRU5HVEg6IDEsXG4gIE9QVElPTl9NQVhfTEVOR1RIOiAxMDAsXG4gIE1JTl9PUFRJT05TOiA0LFxuICBNQVhfT1BUSU9OUzogNCxcbiAgTUFYX0JVTEtfT1BFUkFUSU9OUzogNTAsXG4gIE1BWF9GSUxFX1NJWkU6IDUgKiAxMDI0ICogMTAyNCwgLy8gNU1CXG4gIEFVVE9fU0FWRV9JTlRFUlZBTDogMzAwMDAgLy8gMzAgc2Vjb25kc1xufSBhcyBjb25zdFxuXG4vLyBFcnJvciB0eXBlc1xuZXhwb3J0IGNsYXNzIFF1aXpEYXRhRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yKG1lc3NhZ2U6IHN0cmluZywgcHVibGljIGNvZGU6IHN0cmluZykge1xuICAgIHN1cGVyKG1lc3NhZ2UpXG4gICAgdGhpcy5uYW1lID0gJ1F1aXpEYXRhRXJyb3InXG4gIH1cbn1cblxuLy8gVXRpbGl0eSBmdW5jdGlvbnMgZm9yIGxvY2FsU3RvcmFnZSBvcGVyYXRpb25zXG5jbGFzcyBRdWl6RGF0YU1hbmFnZXIge1xuICBwcml2YXRlIHN0YXRpYyBpbnN0YW5jZTogUXVpekRhdGFNYW5hZ2VyXG4gIHByaXZhdGUgYXV0b1NhdmVUaW1lcjogTm9kZUpTLlRpbWVvdXQgfCBudWxsID0gbnVsbFxuXG4gIHN0YXRpYyBnZXRJbnN0YW5jZSgpOiBRdWl6RGF0YU1hbmFnZXIge1xuICAgIGlmICghUXVpekRhdGFNYW5hZ2VyLmluc3RhbmNlKSB7XG4gICAgICBRdWl6RGF0YU1hbmFnZXIuaW5zdGFuY2UgPSBuZXcgUXVpekRhdGFNYW5hZ2VyKClcbiAgICB9XG4gICAgcmV0dXJuIFF1aXpEYXRhTWFuYWdlci5pbnN0YW5jZVxuICB9XG5cbiAgLy8gU2FmZSBsb2NhbFN0b3JhZ2Ugb3BlcmF0aW9ucyB3aXRoIGVycm9yIGhhbmRsaW5nXG4gIHByaXZhdGUgc2FmZUdldEl0ZW0oa2V5OiBzdHJpbmcpOiBzdHJpbmcgfCBudWxsIHtcbiAgICAvLyBSZXR1cm4gbnVsbCBpZiBub3Qgb24gY2xpZW50IHNpZGVcbiAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHJldHVybiBudWxsXG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBsb2NhbFN0b3JhZ2UuZ2V0SXRlbShrZXkpXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yIHJlYWRpbmcgZnJvbSBsb2NhbFN0b3JhZ2Uga2V5ICR7a2V5fTpgLCBlcnJvcilcbiAgICAgIHJldHVybiBudWxsXG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBzYWZlU2V0SXRlbShrZXk6IHN0cmluZywgdmFsdWU6IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgIC8vIFJldHVybiBmYWxzZSBpZiBub3Qgb24gY2xpZW50IHNpZGVcbiAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbShrZXksIHZhbHVlKVxuICAgICAgcmV0dXJuIHRydWVcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcihgRXJyb3Igd3JpdGluZyB0byBsb2NhbFN0b3JhZ2Uga2V5ICR7a2V5fTpgLCBlcnJvcilcbiAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIERPTUV4Y2VwdGlvbiAmJiBlcnJvci5jb2RlID09PSAyMikge1xuICAgICAgICB0aHJvdyBuZXcgUXVpekRhdGFFcnJvcignU3RvcmFnZSBxdW90YSBleGNlZWRlZC4gUGxlYXNlIGNsZWFyIHNvbWUgZGF0YS4nLCAnUVVPVEFfRVhDRUVERUQnKVxuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuICB9XG5cbiAgLy8gUXVlc3Rpb24gQ1JVRCBvcGVyYXRpb25zXG4gIGdldFF1ZXN0aW9ucygpOiBRdWl6UXVlc3Rpb25bXSB7XG4gICAgY29uc3QgZGF0YSA9IHRoaXMuc2FmZUdldEl0ZW0oUVVJWl9TVE9SQUdFX0tFWVMuUVVFU1RJT05TKVxuICAgIGlmICghZGF0YSkgcmV0dXJuIHRoaXMuaW5pdGlhbGl6ZVdpdGhTYW1wbGVEYXRhKClcbiAgICBcbiAgICB0cnkge1xuICAgICAgY29uc3QgcXVlc3Rpb25zID0gSlNPTi5wYXJzZShkYXRhKVxuICAgICAgcmV0dXJuIEFycmF5LmlzQXJyYXkocXVlc3Rpb25zKSA/IHF1ZXN0aW9ucyA6IFtdXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIHBhcnNpbmcgcXVlc3Rpb25zIGRhdGE6JywgZXJyb3IpXG4gICAgICByZXR1cm4gdGhpcy5pbml0aWFsaXplV2l0aFNhbXBsZURhdGEoKVxuICAgIH1cbiAgfVxuXG4gIHNhdmVRdWVzdGlvbihxdWVzdGlvbjogT21pdDxRdWl6UXVlc3Rpb24sICdpZCcgfCAnY3JlYXRlZEF0JyB8ICd1cGRhdGVkQXQnPik6IFF1aXpRdWVzdGlvbiB7XG4gICAgdGhpcy52YWxpZGF0ZVF1ZXN0aW9uKHF1ZXN0aW9uKVxuICAgIFxuICAgIGNvbnN0IHF1ZXN0aW9ucyA9IHRoaXMuZ2V0UXVlc3Rpb25zKClcbiAgICBjb25zdCBub3cgPSBEYXRlLm5vdygpXG4gICAgY29uc3QgbmV3UXVlc3Rpb246IFF1aXpRdWVzdGlvbiA9IHtcbiAgICAgIC4uLnF1ZXN0aW9uLFxuICAgICAgaWQ6IHRoaXMuZ2VuZXJhdGVJZCgpLFxuICAgICAgY3JlYXRlZEF0OiBub3csXG4gICAgICB1cGRhdGVkQXQ6IG5vd1xuICAgIH1cbiAgICBcbiAgICBxdWVzdGlvbnMucHVzaChuZXdRdWVzdGlvbilcbiAgICB0aGlzLnNhdmVRdWVzdGlvbnMocXVlc3Rpb25zKVxuICAgIHJldHVybiBuZXdRdWVzdGlvblxuICB9XG5cbiAgdXBkYXRlUXVlc3Rpb24oaWQ6IHN0cmluZywgdXBkYXRlczogUGFydGlhbDxPbWl0PFF1aXpRdWVzdGlvbiwgJ2lkJyB8ICdjcmVhdGVkQXQnPj4pOiBRdWl6UXVlc3Rpb24ge1xuICAgIGNvbnN0IHF1ZXN0aW9ucyA9IHRoaXMuZ2V0UXVlc3Rpb25zKClcbiAgICBjb25zdCBpbmRleCA9IHF1ZXN0aW9ucy5maW5kSW5kZXgocSA9PiBxLmlkID09PSBpZClcbiAgICBcbiAgICBpZiAoaW5kZXggPT09IC0xKSB7XG4gICAgICB0aHJvdyBuZXcgUXVpekRhdGFFcnJvcihgUXVlc3Rpb24gd2l0aCBpZCAke2lkfSBub3QgZm91bmRgLCAnTk9UX0ZPVU5EJylcbiAgICB9XG4gICAgXG4gICAgY29uc3QgdXBkYXRlZFF1ZXN0aW9uID0ge1xuICAgICAgLi4ucXVlc3Rpb25zW2luZGV4XSxcbiAgICAgIC4uLnVwZGF0ZXMsXG4gICAgICB1cGRhdGVkQXQ6IERhdGUubm93KClcbiAgICB9XG4gICAgXG4gICAgdGhpcy52YWxpZGF0ZVF1ZXN0aW9uKHVwZGF0ZWRRdWVzdGlvbilcbiAgICBxdWVzdGlvbnNbaW5kZXhdID0gdXBkYXRlZFF1ZXN0aW9uXG4gICAgdGhpcy5zYXZlUXVlc3Rpb25zKHF1ZXN0aW9ucylcbiAgICByZXR1cm4gdXBkYXRlZFF1ZXN0aW9uXG4gIH1cblxuICBkZWxldGVRdWVzdGlvbihpZDogc3RyaW5nKTogYm9vbGVhbiB7XG4gICAgY29uc3QgcXVlc3Rpb25zID0gdGhpcy5nZXRRdWVzdGlvbnMoKVxuICAgIGNvbnN0IGZpbHRlcmVkUXVlc3Rpb25zID0gcXVlc3Rpb25zLmZpbHRlcihxID0+IHEuaWQgIT09IGlkKVxuICAgIFxuICAgIGlmIChmaWx0ZXJlZFF1ZXN0aW9ucy5sZW5ndGggPT09IHF1ZXN0aW9ucy5sZW5ndGgpIHtcbiAgICAgIHRocm93IG5ldyBRdWl6RGF0YUVycm9yKGBRdWVzdGlvbiB3aXRoIGlkICR7aWR9IG5vdCBmb3VuZGAsICdOT1RfRk9VTkQnKVxuICAgIH1cbiAgICBcbiAgICB0aGlzLnNhdmVRdWVzdGlvbnMoZmlsdGVyZWRRdWVzdGlvbnMpXG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIGJ1bGtEZWxldGUoaWRzOiBzdHJpbmdbXSk6IEJ1bGtPcGVyYXRpb25SZXN1bHQge1xuICAgIGlmIChpZHMubGVuZ3RoID4gVkFMSURBVElPTl9SVUxFUy5NQVhfQlVMS19PUEVSQVRJT05TKSB7XG4gICAgICB0aHJvdyBuZXcgUXVpekRhdGFFcnJvcihcbiAgICAgICAgYENhbm5vdCBkZWxldGUgbW9yZSB0aGFuICR7VkFMSURBVElPTl9SVUxFUy5NQVhfQlVMS19PUEVSQVRJT05TfSBxdWVzdGlvbnMgYXQgb25jZWAsXG4gICAgICAgICdCVUxLX0xJTUlUX0VYQ0VFREVEJ1xuICAgICAgKVxuICAgIH1cblxuICAgIGNvbnN0IHF1ZXN0aW9ucyA9IHRoaXMuZ2V0UXVlc3Rpb25zKClcbiAgICBjb25zdCBpbml0aWFsQ291bnQgPSBxdWVzdGlvbnMubGVuZ3RoXG4gICAgY29uc3QgZmlsdGVyZWRRdWVzdGlvbnMgPSBxdWVzdGlvbnMuZmlsdGVyKHEgPT4gIWlkcy5pbmNsdWRlcyhxLmlkKSlcbiAgICBjb25zdCBkZWxldGVkQ291bnQgPSBpbml0aWFsQ291bnQgLSBmaWx0ZXJlZFF1ZXN0aW9ucy5sZW5ndGhcbiAgICBcbiAgICB0aGlzLnNhdmVRdWVzdGlvbnMoZmlsdGVyZWRRdWVzdGlvbnMpXG4gICAgXG4gICAgcmV0dXJuIHtcbiAgICAgIHN1Y2Nlc3M6IHRydWUsXG4gICAgICBwcm9jZXNzZWRDb3VudDogZGVsZXRlZENvdW50LFxuICAgICAgZXJyb3JDb3VudDogaWRzLmxlbmd0aCAtIGRlbGV0ZWRDb3VudCxcbiAgICAgIGVycm9yczogaWRzLmxlbmd0aCA+IGRlbGV0ZWRDb3VudCA/IFsnU29tZSBxdWVzdGlvbnMgd2VyZSBub3QgZm91bmQnXSA6IFtdXG4gICAgfVxuICB9XG5cbiAgLy8gU2VhcmNoIGFuZCBmaWx0ZXIgb3BlcmF0aW9uc1xuICBzZWFyY2hRdWVzdGlvbnMoZmlsdGVyczogU2VhcmNoRmlsdGVycyk6IFF1aXpRdWVzdGlvbltdIHtcbiAgICBjb25zdCBxdWVzdGlvbnMgPSB0aGlzLmdldFF1ZXN0aW9ucygpXG4gICAgXG4gICAgcmV0dXJuIHF1ZXN0aW9ucy5maWx0ZXIocXVlc3Rpb24gPT4ge1xuICAgICAgLy8gVGV4dCBzZWFyY2hcbiAgICAgIGlmIChmaWx0ZXJzLnNlYXJjaFRleHQpIHtcbiAgICAgICAgY29uc3Qgc2VhcmNoTG93ZXIgPSBmaWx0ZXJzLnNlYXJjaFRleHQudG9Mb3dlckNhc2UoKVxuICAgICAgICBpZiAoIXF1ZXN0aW9uLnF1ZXN0aW9uLnRvTG93ZXJDYXNlKCkuaW5jbHVkZXMoc2VhcmNoTG93ZXIpKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gQ2F0ZWdvcnkgZmlsdGVyXG4gICAgICBpZiAoZmlsdGVycy5jYXRlZ29yeSAhPT0gJ2FsbCcgJiYgcXVlc3Rpb24uY2F0ZWdvcnkgIT09IGZpbHRlcnMuY2F0ZWdvcnkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIERpZmZpY3VsdHkgZmlsdGVyXG4gICAgICBpZiAoZmlsdGVycy5kaWZmaWN1bHR5ICE9PSAnYWxsJyAmJiBxdWVzdGlvbi5kaWZmaWN1bHR5ICE9PSBmaWx0ZXJzLmRpZmZpY3VsdHkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIFR5cGUgZmlsdGVyXG4gICAgICBpZiAoZmlsdGVycy50eXBlICE9PSAnYWxsJyAmJiBxdWVzdGlvbi50eXBlICE9PSBmaWx0ZXJzLnR5cGUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG4gICAgICBcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfSlcbiAgfVxuXG4gIC8vIENhdGVnb3JpZXMgbWFuYWdlbWVudFxuICBnZXRDYXRlZ29yaWVzKCk6IFF1aXpDYXRlZ29yeVtdIHtcbiAgICBjb25zdCBxdWVzdGlvbnMgPSB0aGlzLmdldFF1ZXN0aW9ucygpXG4gICAgY29uc3QgY2F0ZWdvcnlDb3VudHMgPSBxdWVzdGlvbnMucmVkdWNlKChhY2MsIHF1ZXN0aW9uKSA9PiB7XG4gICAgICBhY2NbcXVlc3Rpb24uY2F0ZWdvcnldID0gKGFjY1txdWVzdGlvbi5jYXRlZ29yeV0gfHwgMCkgKyAxXG4gICAgICByZXR1cm4gYWNjXG4gICAgfSwge30gYXMgUmVjb3JkPHN0cmluZywgbnVtYmVyPilcbiAgICBcbiAgICByZXR1cm4gREVGQVVMVF9DQVRFR09SSUVTLm1hcChjYXRlZ29yeSA9PiAoe1xuICAgICAgLi4uY2F0ZWdvcnksXG4gICAgICBxdWVzdGlvbkNvdW50OiBjYXRlZ29yeUNvdW50c1tjYXRlZ29yeS5pZF0gfHwgMFxuICAgIH0pKVxuICB9XG5cbiAgLy8gRHJhZnQgbWFuYWdlbWVudFxuICBzYXZlRHJhZnQoZHJhZnQ6IFF1ZXN0aW9uRHJhZnQpOiB2b2lkIHtcbiAgICBjb25zdCBkcmFmdHMgPSB0aGlzLmdldERyYWZ0cygpXG4gICAgY29uc3QgZXhpc3RpbmdJbmRleCA9IGRyYWZ0cy5maW5kSW5kZXgoZCA9PiBkLmlkID09PSBkcmFmdC5pZClcbiAgICBcbiAgICBpZiAoZXhpc3RpbmdJbmRleCA+PSAwKSB7XG4gICAgICBkcmFmdHNbZXhpc3RpbmdJbmRleF0gPSB7IC4uLmRyYWZ0LCBsYXN0U2F2ZWQ6IERhdGUubm93KCkgfVxuICAgIH0gZWxzZSB7XG4gICAgICBkcmFmdHMucHVzaCh7IC4uLmRyYWZ0LCBsYXN0U2F2ZWQ6IERhdGUubm93KCkgfSlcbiAgICB9XG4gICAgXG4gICAgdGhpcy5zYWZlU2V0SXRlbShRVUlaX1NUT1JBR0VfS0VZUy5EUkFGVFMsIEpTT04uc3RyaW5naWZ5KGRyYWZ0cykpXG4gIH1cblxuICBnZXREcmFmdHMoKTogUXVlc3Rpb25EcmFmdFtdIHtcbiAgICBjb25zdCBkYXRhID0gdGhpcy5zYWZlR2V0SXRlbShRVUlaX1NUT1JBR0VfS0VZUy5EUkFGVFMpXG4gICAgaWYgKCFkYXRhKSByZXR1cm4gW11cbiAgICBcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIEpTT04ucGFyc2UoZGF0YSlcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgcGFyc2luZyBkcmFmdHMgZGF0YTonLCBlcnJvcilcbiAgICAgIHJldHVybiBbXVxuICAgIH1cbiAgfVxuXG4gIGRlbGV0ZURyYWZ0KGlkOiBzdHJpbmcpOiB2b2lkIHtcbiAgICBjb25zdCBkcmFmdHMgPSB0aGlzLmdldERyYWZ0cygpLmZpbHRlcihkID0+IGQuaWQgIT09IGlkKVxuICAgIHRoaXMuc2FmZVNldEl0ZW0oUVVJWl9TVE9SQUdFX0tFWVMuRFJBRlRTLCBKU09OLnN0cmluZ2lmeShkcmFmdHMpKVxuICB9XG5cbiAgLy8gU2V0dGluZ3MgbWFuYWdlbWVudFxuICBnZXRTZXR0aW5ncygpOiBRdWl6TWFuYWdlbWVudFNldHRpbmdzIHtcbiAgICBjb25zdCBkYXRhID0gdGhpcy5zYWZlR2V0SXRlbShRVUlaX1NUT1JBR0VfS0VZUy5TRVRUSU5HUylcbiAgICBpZiAoIWRhdGEpIHJldHVybiB0aGlzLmdldERlZmF1bHRTZXR0aW5ncygpXG4gICAgXG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiB7IC4uLnRoaXMuZ2V0RGVmYXVsdFNldHRpbmdzKCksIC4uLkpTT04ucGFyc2UoZGF0YSkgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBwYXJzaW5nIHNldHRpbmdzIGRhdGE6JywgZXJyb3IpXG4gICAgICByZXR1cm4gdGhpcy5nZXREZWZhdWx0U2V0dGluZ3MoKVxuICAgIH1cbiAgfVxuXG4gIHNhdmVTZXR0aW5ncyhzZXR0aW5nczogUGFydGlhbDxRdWl6TWFuYWdlbWVudFNldHRpbmdzPik6IHZvaWQge1xuICAgIGNvbnN0IGN1cnJlbnRTZXR0aW5ncyA9IHRoaXMuZ2V0U2V0dGluZ3MoKVxuICAgIGNvbnN0IHVwZGF0ZWRTZXR0aW5ncyA9IHsgLi4uY3VycmVudFNldHRpbmdzLCAuLi5zZXR0aW5ncyB9XG4gICAgdGhpcy5zYWZlU2V0SXRlbShRVUlaX1NUT1JBR0VfS0VZUy5TRVRUSU5HUywgSlNPTi5zdHJpbmdpZnkodXBkYXRlZFNldHRpbmdzKSlcbiAgfVxuXG4gIHByaXZhdGUgZ2V0RGVmYXVsdFNldHRpbmdzKCk6IFF1aXpNYW5hZ2VtZW50U2V0dGluZ3Mge1xuICAgIHJldHVybiB7XG4gICAgICBwYWdlU2l6ZTogMTAsXG4gICAgICBzb3J0Qnk6ICd1cGRhdGVkQXQnLFxuICAgICAgc29ydE9yZGVyOiAnZGVzYycsXG4gICAgICBmaWx0ZXJzOiB7XG4gICAgICAgIHNlYXJjaFRleHQ6ICcnLFxuICAgICAgICBjYXRlZ29yeTogJ2FsbCcsXG4gICAgICAgIGRpZmZpY3VsdHk6ICdhbGwnLFxuICAgICAgICB0eXBlOiAnYWxsJ1xuICAgICAgfSxcbiAgICAgIHNlbGVjdGVkUXVlc3Rpb25zOiBbXVxuICAgIH1cbiAgfVxuXG4gIC8vIFZhbGlkYXRpb25cbiAgcHJpdmF0ZSB2YWxpZGF0ZVF1ZXN0aW9uKHF1ZXN0aW9uOiBQYXJ0aWFsPFF1aXpRdWVzdGlvbj4pOiB2b2lkIHtcbiAgICBpZiAoIXF1ZXN0aW9uLnF1ZXN0aW9uIHx8IHF1ZXN0aW9uLnF1ZXN0aW9uLmxlbmd0aCA8IFZBTElEQVRJT05fUlVMRVMuUVVFU1RJT05fTUlOX0xFTkdUSCkge1xuICAgICAgdGhyb3cgbmV3IFF1aXpEYXRhRXJyb3IoXG4gICAgICAgIGBRdWVzdGlvbiBtdXN0IGJlIGF0IGxlYXN0ICR7VkFMSURBVElPTl9SVUxFUy5RVUVTVElPTl9NSU5fTEVOR1RIfSBjaGFyYWN0ZXJzIGxvbmdgLFxuICAgICAgICAnSU5WQUxJRF9RVUVTVElPTl9MRU5HVEgnXG4gICAgICApXG4gICAgfVxuICAgIFxuICAgIGlmIChxdWVzdGlvbi5xdWVzdGlvbi5sZW5ndGggPiBWQUxJREFUSU9OX1JVTEVTLlFVRVNUSU9OX01BWF9MRU5HVEgpIHtcbiAgICAgIHRocm93IG5ldyBRdWl6RGF0YUVycm9yKFxuICAgICAgICBgUXVlc3Rpb24gbXVzdCBiZSBubyBtb3JlIHRoYW4gJHtWQUxJREFUSU9OX1JVTEVTLlFVRVNUSU9OX01BWF9MRU5HVEh9IGNoYXJhY3RlcnMgbG9uZ2AsXG4gICAgICAgICdJTlZBTElEX1FVRVNUSU9OX0xFTkdUSCdcbiAgICAgIClcbiAgICB9XG4gICAgXG4gICAgaWYgKCFxdWVzdGlvbi5vcHRpb25zIHx8IHF1ZXN0aW9uLm9wdGlvbnMubGVuZ3RoICE9PSBWQUxJREFUSU9OX1JVTEVTLk1JTl9PUFRJT05TKSB7XG4gICAgICB0aHJvdyBuZXcgUXVpekRhdGFFcnJvcihcbiAgICAgICAgYFF1ZXN0aW9uIG11c3QgaGF2ZSBleGFjdGx5ICR7VkFMSURBVElPTl9SVUxFUy5NSU5fT1BUSU9OU30gb3B0aW9uc2AsXG4gICAgICAgICdJTlZBTElEX09QVElPTlNfQ09VTlQnXG4gICAgICApXG4gICAgfVxuICAgIFxuICAgIC8vIFZhbGlkYXRlIGVhY2ggb3B0aW9uXG4gICAgcXVlc3Rpb24ub3B0aW9ucy5mb3JFYWNoKChvcHRpb24sIGluZGV4KSA9PiB7XG4gICAgICBpZiAoIW9wdGlvbiB8fCBvcHRpb24ubGVuZ3RoIDwgVkFMSURBVElPTl9SVUxFUy5PUFRJT05fTUlOX0xFTkdUSCkge1xuICAgICAgICB0aHJvdyBuZXcgUXVpekRhdGFFcnJvcihcbiAgICAgICAgICBgT3B0aW9uICR7aW5kZXggKyAxfSBtdXN0IGJlIGF0IGxlYXN0ICR7VkFMSURBVElPTl9SVUxFUy5PUFRJT05fTUlOX0xFTkdUSH0gY2hhcmFjdGVyIGxvbmdgLFxuICAgICAgICAgICdJTlZBTElEX09QVElPTl9MRU5HVEgnXG4gICAgICAgIClcbiAgICAgIH1cbiAgICAgIFxuICAgICAgaWYgKG9wdGlvbi5sZW5ndGggPiBWQUxJREFUSU9OX1JVTEVTLk9QVElPTl9NQVhfTEVOR1RIKSB7XG4gICAgICAgIHRocm93IG5ldyBRdWl6RGF0YUVycm9yKFxuICAgICAgICAgIGBPcHRpb24gJHtpbmRleCArIDF9IG11c3QgYmUgbm8gbW9yZSB0aGFuICR7VkFMSURBVElPTl9SVUxFUy5PUFRJT05fTUFYX0xFTkdUSH0gY2hhcmFjdGVycyBsb25nYCxcbiAgICAgICAgICAnSU5WQUxJRF9PUFRJT05fTEVOR1RIJ1xuICAgICAgICApXG4gICAgICB9XG4gICAgfSlcbiAgICBcbiAgICAvLyBDaGVjayBmb3IgZHVwbGljYXRlIG9wdGlvbnNcbiAgICBjb25zdCB1bmlxdWVPcHRpb25zID0gbmV3IFNldChxdWVzdGlvbi5vcHRpb25zLm1hcChvcHQgPT4gb3B0LnRvTG93ZXJDYXNlKCkudHJpbSgpKSlcbiAgICBpZiAodW5pcXVlT3B0aW9ucy5zaXplICE9PSBxdWVzdGlvbi5vcHRpb25zLmxlbmd0aCkge1xuICAgICAgdGhyb3cgbmV3IFF1aXpEYXRhRXJyb3IoJ0FsbCBvcHRpb25zIG11c3QgYmUgdW5pcXVlJywgJ0RVUExJQ0FURV9PUFRJT05TJylcbiAgICB9XG4gICAgXG4gICAgLy8gVmFsaWRhdGUgY29ycmVjdCBhbnN3ZXJcbiAgICBpZiAodHlwZW9mIHF1ZXN0aW9uLmNvcnJlY3RBbnN3ZXIgIT09ICdudW1iZXInIHx8IFxuICAgICAgICBxdWVzdGlvbi5jb3JyZWN0QW5zd2VyIDwgMCB8fCBcbiAgICAgICAgcXVlc3Rpb24uY29ycmVjdEFuc3dlciA+PSBxdWVzdGlvbi5vcHRpb25zLmxlbmd0aCkge1xuICAgICAgdGhyb3cgbmV3IFF1aXpEYXRhRXJyb3IoJ0ludmFsaWQgY29ycmVjdCBhbnN3ZXIgc2VsZWN0aW9uJywgJ0lOVkFMSURfQ09SUkVDVF9BTlNXRVInKVxuICAgIH1cbiAgICBcbiAgICAvLyBWYWxpZGF0ZSBjYXRlZ29yeVxuICAgIGNvbnN0IHZhbGlkQ2F0ZWdvcmllcyA9IERFRkFVTFRfQ0FURUdPUklFUy5tYXAoYyA9PiBjLmlkKVxuICAgIGlmICghcXVlc3Rpb24uY2F0ZWdvcnkgfHwgIXZhbGlkQ2F0ZWdvcmllcy5pbmNsdWRlcyhxdWVzdGlvbi5jYXRlZ29yeSkpIHtcbiAgICAgIHRocm93IG5ldyBRdWl6RGF0YUVycm9yKCdJbnZhbGlkIGNhdGVnb3J5IHNlbGVjdGlvbicsICdJTlZBTElEX0NBVEVHT1JZJylcbiAgICB9XG4gIH1cblxuICAvLyBVdGlsaXR5IG1ldGhvZHNcbiAgcHJpdmF0ZSBzYXZlUXVlc3Rpb25zKHF1ZXN0aW9uczogUXVpelF1ZXN0aW9uW10pOiB2b2lkIHtcbiAgICB0aGlzLnNhZmVTZXRJdGVtKFFVSVpfU1RPUkFHRV9LRVlTLlFVRVNUSU9OUywgSlNPTi5zdHJpbmdpZnkocXVlc3Rpb25zKSlcbiAgfVxuXG4gIHByaXZhdGUgZ2VuZXJhdGVJZCgpOiBzdHJpbmcge1xuICAgIHJldHVybiBgcV8ke0RhdGUubm93KCl9XyR7TWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc3Vic3RyKDIsIDkpfWBcbiAgfVxuXG4gIC8vIENTViBFeHBvcnQvSW1wb3J0IGZ1bmN0aW9uYWxpdHlcbiAgZXhwb3J0VG9DU1YocXVlc3Rpb25zPzogUXVpelF1ZXN0aW9uW10pOiBzdHJpbmcge1xuICAgIGNvbnN0IHF1ZXN0aW9uc1RvRXhwb3J0ID0gcXVlc3Rpb25zIHx8IHRoaXMuZ2V0UXVlc3Rpb25zKClcblxuICAgIGNvbnN0IGhlYWRlcnMgPSBbXG4gICAgICAnSUQnLCAnUXVlc3Rpb24nLCAnT3B0aW9uIDEnLCAnT3B0aW9uIDInLCAnT3B0aW9uIDMnLCAnT3B0aW9uIDQnLFxuICAgICAgJ0NvcnJlY3QgQW5zd2VyJywgJ0NhdGVnb3J5JywgJ0RpZmZpY3VsdHknLCAnVHlwZScsICdGdW4gRmFjdCcsICdUYWdzJyxcbiAgICAgICdDcmVhdGVkIEF0JywgJ1VwZGF0ZWQgQXQnXG4gICAgXVxuXG4gICAgY29uc3QgY3N2Um93cyA9IFtcbiAgICAgIGhlYWRlcnMuam9pbignLCcpLFxuICAgICAgLi4ucXVlc3Rpb25zVG9FeHBvcnQubWFwKHEgPT4gW1xuICAgICAgICBxLmlkLFxuICAgICAgICBgXCIke3EucXVlc3Rpb24ucmVwbGFjZSgvXCIvZywgJ1wiXCInKX1cImAsXG4gICAgICAgIGBcIiR7cS5vcHRpb25zWzBdLnJlcGxhY2UoL1wiL2csICdcIlwiJyl9XCJgLFxuICAgICAgICBgXCIke3Eub3B0aW9uc1sxXS5yZXBsYWNlKC9cIi9nLCAnXCJcIicpfVwiYCxcbiAgICAgICAgYFwiJHtxLm9wdGlvbnNbMl0ucmVwbGFjZSgvXCIvZywgJ1wiXCInKX1cImAsXG4gICAgICAgIGBcIiR7cS5vcHRpb25zWzNdLnJlcGxhY2UoL1wiL2csICdcIlwiJyl9XCJgLFxuICAgICAgICBxLmNvcnJlY3RBbnN3ZXIgKyAxLCAvLyAxLWJhc2VkIGZvciBodW1hbiByZWFkYWJpbGl0eVxuICAgICAgICBxLmNhdGVnb3J5LFxuICAgICAgICBxLmRpZmZpY3VsdHksXG4gICAgICAgIHEudHlwZSxcbiAgICAgICAgYFwiJHsocS5mdW5GYWN0IHx8ICcnKS5yZXBsYWNlKC9cIi9nLCAnXCJcIicpfVwiYCxcbiAgICAgICAgYFwiJHsocS50YWdzIHx8IFtdKS5qb2luKCc7Jyl9XCJgLFxuICAgICAgICBuZXcgRGF0ZShxLmNyZWF0ZWRBdCkudG9JU09TdHJpbmcoKSxcbiAgICAgICAgbmV3IERhdGUocS51cGRhdGVkQXQpLnRvSVNPU3RyaW5nKClcbiAgICAgIF0uam9pbignLCcpKVxuICAgIF1cblxuICAgIC8vIEFkZCBVVEYtOCBCT00gZm9yIEV4Y2VsIGNvbXBhdGliaWxpdHlcbiAgICByZXR1cm4gJ1xcdUZFRkYnICsgY3N2Um93cy5qb2luKCdcXG4nKVxuICB9XG5cbiAgYXN5bmMgaW1wb3J0RnJvbUNTVihjc3ZDb250ZW50OiBzdHJpbmcpOiBQcm9taXNlPEJ1bGtPcGVyYXRpb25SZXN1bHQ+IHtcbiAgICBjb25zdCBsaW5lcyA9IGNzdkNvbnRlbnQuc3BsaXQoJ1xcbicpLmZpbHRlcihsaW5lID0+IGxpbmUudHJpbSgpKVxuICAgIGlmIChsaW5lcy5sZW5ndGggPCAyKSB7XG4gICAgICB0aHJvdyBuZXcgUXVpekRhdGFFcnJvcignQ1NWIGZpbGUgbXVzdCBjb250YWluIGF0IGxlYXN0IGEgaGVhZGVyIGFuZCBvbmUgZGF0YSByb3cnLCAnSU5WQUxJRF9DU1ZfRk9STUFUJylcbiAgICB9XG5cbiAgICBjb25zdCBoZWFkZXJzID0gbGluZXNbMF0uc3BsaXQoJywnKS5tYXAoaCA9PiBoLnRyaW0oKS5yZXBsYWNlKC9cIi9nLCAnJykpXG4gICAgY29uc3QgZGF0YUxpbmVzID0gbGluZXMuc2xpY2UoMSlcblxuICAgIGNvbnN0IHJlc3VsdHM6IEJ1bGtPcGVyYXRpb25SZXN1bHQgPSB7XG4gICAgICBzdWNjZXNzOiB0cnVlLFxuICAgICAgcHJvY2Vzc2VkQ291bnQ6IDAsXG4gICAgICBlcnJvckNvdW50OiAwLFxuICAgICAgZXJyb3JzOiBbXVxuICAgIH1cblxuICAgIGNvbnN0IHZhbGlkUXVlc3Rpb25zOiBRdWl6UXVlc3Rpb25bXSA9IFtdXG4gICAgY29uc3QgZXhpc3RpbmdRdWVzdGlvbnMgPSB0aGlzLmdldFF1ZXN0aW9ucygpXG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRhdGFMaW5lcy5sZW5ndGg7IGkrKykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgdmFsdWVzID0gdGhpcy5wYXJzZUNTVkxpbmUoZGF0YUxpbmVzW2ldKVxuICAgICAgICBpZiAodmFsdWVzLmxlbmd0aCA8IDgpIHtcbiAgICAgICAgICByZXN1bHRzLmVycm9ycy5wdXNoKGBMaW5lICR7aSArIDJ9OiBJbnN1ZmZpY2llbnQgZGF0YSBjb2x1bW5zYClcbiAgICAgICAgICByZXN1bHRzLmVycm9yQ291bnQrK1xuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBxdWVzdGlvbjogUXVpelF1ZXN0aW9uID0ge1xuICAgICAgICAgIGlkOiB2YWx1ZXNbMF0gfHwgdGhpcy5nZW5lcmF0ZUlkKCksXG4gICAgICAgICAgcXVlc3Rpb246IHZhbHVlc1sxXSxcbiAgICAgICAgICBvcHRpb25zOiBbdmFsdWVzWzJdLCB2YWx1ZXNbM10sIHZhbHVlc1s0XSwgdmFsdWVzWzVdXSxcbiAgICAgICAgICBjb3JyZWN0QW5zd2VyOiBwYXJzZUludCh2YWx1ZXNbNl0pIC0gMSwgLy8gQ29udmVydCBiYWNrIHRvIDAtYmFzZWRcbiAgICAgICAgICBjYXRlZ29yeTogdmFsdWVzWzddLFxuICAgICAgICAgIGRpZmZpY3VsdHk6IHZhbHVlc1s4XSBhcyAnYmVnaW5uZXInIHwgJ2ludGVybWVkaWF0ZScgfCAnYWR2YW5jZWQnLFxuICAgICAgICAgIHR5cGU6ICh2YWx1ZXNbOV0gfHwgJ3JlZ3VsYXInKSBhcyAncmVndWxhcicgfCAnYm9udXMnLFxuICAgICAgICAgIGZ1bkZhY3Q6IHZhbHVlc1sxMF0gfHwgdW5kZWZpbmVkLFxuICAgICAgICAgIHRhZ3M6IHZhbHVlc1sxMV0gPyB2YWx1ZXNbMTFdLnNwbGl0KCc7JykuZmlsdGVyKHQgPT4gdC50cmltKCkpIDogdW5kZWZpbmVkLFxuICAgICAgICAgIGNyZWF0ZWRBdDogdmFsdWVzWzEyXSA/IG5ldyBEYXRlKHZhbHVlc1sxMl0pLmdldFRpbWUoKSA6IERhdGUubm93KCksXG4gICAgICAgICAgdXBkYXRlZEF0OiB2YWx1ZXNbMTNdID8gbmV3IERhdGUodmFsdWVzWzEzXSkuZ2V0VGltZSgpIDogRGF0ZS5ub3coKVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gVmFsaWRhdGUgdGhlIHF1ZXN0aW9uXG4gICAgICAgIHRoaXMudmFsaWRhdGVRdWVzdGlvbihxdWVzdGlvbilcblxuICAgICAgICAvLyBDaGVjayBmb3IgZHVwbGljYXRlc1xuICAgICAgICBjb25zdCBleGlzdGluZ0luZGV4ID0gZXhpc3RpbmdRdWVzdGlvbnMuZmluZEluZGV4KHEgPT4gcS5pZCA9PT0gcXVlc3Rpb24uaWQpXG4gICAgICAgIGlmIChleGlzdGluZ0luZGV4ID49IDApIHtcbiAgICAgICAgICAvLyBVcGRhdGUgZXhpc3RpbmcgcXVlc3Rpb25cbiAgICAgICAgICBleGlzdGluZ1F1ZXN0aW9uc1tleGlzdGluZ0luZGV4XSA9IHF1ZXN0aW9uXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFsaWRRdWVzdGlvbnMucHVzaChxdWVzdGlvbilcbiAgICAgICAgfVxuXG4gICAgICAgIHJlc3VsdHMucHJvY2Vzc2VkQ291bnQrK1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgcmVzdWx0cy5lcnJvcnMucHVzaChgTGluZSAke2kgKyAyfTogJHtlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6ICdVbmtub3duIGVycm9yJ31gKVxuICAgICAgICByZXN1bHRzLmVycm9yQ291bnQrK1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFNhdmUgYWxsIHZhbGlkIHF1ZXN0aW9uc1xuICAgIGlmICh2YWxpZFF1ZXN0aW9ucy5sZW5ndGggPiAwKSB7XG4gICAgICBjb25zdCBhbGxRdWVzdGlvbnMgPSBbLi4uZXhpc3RpbmdRdWVzdGlvbnMsIC4uLnZhbGlkUXVlc3Rpb25zXVxuICAgICAgdGhpcy5zYXZlUXVlc3Rpb25zKGFsbFF1ZXN0aW9ucylcbiAgICB9XG5cbiAgICByZXN1bHRzLnN1Y2Nlc3MgPSByZXN1bHRzLmVycm9yQ291bnQgPT09IDBcbiAgICByZXR1cm4gcmVzdWx0c1xuICB9XG5cbiAgcHJpdmF0ZSBwYXJzZUNTVkxpbmUobGluZTogc3RyaW5nKTogc3RyaW5nW10ge1xuICAgIGNvbnN0IHJlc3VsdDogc3RyaW5nW10gPSBbXVxuICAgIGxldCBjdXJyZW50ID0gJydcbiAgICBsZXQgaW5RdW90ZXMgPSBmYWxzZVxuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaW5lLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBjaGFyID0gbGluZVtpXVxuXG4gICAgICBpZiAoY2hhciA9PT0gJ1wiJykge1xuICAgICAgICBpZiAoaW5RdW90ZXMgJiYgbGluZVtpICsgMV0gPT09ICdcIicpIHtcbiAgICAgICAgICBjdXJyZW50ICs9ICdcIidcbiAgICAgICAgICBpKysgLy8gU2tpcCBuZXh0IHF1b3RlXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaW5RdW90ZXMgPSAhaW5RdW90ZXNcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChjaGFyID09PSAnLCcgJiYgIWluUXVvdGVzKSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKGN1cnJlbnQudHJpbSgpKVxuICAgICAgICBjdXJyZW50ID0gJydcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGN1cnJlbnQgKz0gY2hhclxuICAgICAgfVxuICAgIH1cblxuICAgIHJlc3VsdC5wdXNoKGN1cnJlbnQudHJpbSgpKVxuICAgIHJldHVybiByZXN1bHRcbiAgfVxuXG4gIHByaXZhdGUgaW5pdGlhbGl6ZVdpdGhTYW1wbGVEYXRhKCk6IFF1aXpRdWVzdGlvbltdIHtcbiAgICAvLyBJbml0aWFsaXplIHdpdGggYSBmZXcgc2FtcGxlIHF1ZXN0aW9ucyBmb3IgZGVtb25zdHJhdGlvblxuICAgIGNvbnN0IHNhbXBsZVF1ZXN0aW9uczogUXVpelF1ZXN0aW9uW10gPSBbXG4gICAgICB7XG4gICAgICAgIGlkOiAnc2FtcGxlXzEnLFxuICAgICAgICBxdWVzdGlvbjogJ1doaWNoIHNvY2lhbCBtZWRpYSBwbGF0Zm9ybSBpcyBrbm93biBmb3IgaXRzIHNob3J0LWZvcm0gdmlkZW8gY29udGVudCBhbmQgdmlyYWwgZGFuY2VzPycsXG4gICAgICAgIG9wdGlvbnM6IFsnSW5zdGFncmFtJywgJ1Rpa1RvaycsICdUd2l0dGVyJywgJ1NuYXBjaGF0J10sXG4gICAgICAgIGNvcnJlY3RBbnN3ZXI6IDEsXG4gICAgICAgIGNhdGVnb3J5OiAnc29jaWFsLW1lZGlhJyxcbiAgICAgICAgZGlmZmljdWx0eTogJ2JlZ2lubmVyJyxcbiAgICAgICAgdHlwZTogJ3JlZ3VsYXInLFxuICAgICAgICBmdW5GYWN0OiAnVGlrVG9rIHdhcyBvcmlnaW5hbGx5IGNhbGxlZCBNdXNpY2FsLmx5IGJlZm9yZSBiZWluZyBhY3F1aXJlZCBieSBCeXRlRGFuY2UuJyxcbiAgICAgICAgdGFnczogWydzb2NpYWwtbWVkaWEnLCAndmlkZW8nLCAndmlyYWwnXSxcbiAgICAgICAgY3JlYXRlZEF0OiBEYXRlLm5vdygpIC0gODY0MDAwMDAsIC8vIDEgZGF5IGFnb1xuICAgICAgICB1cGRhdGVkQXQ6IERhdGUubm93KCkgLSA4NjQwMDAwMFxuICAgICAgfVxuICAgICAgLy8gQWRkIG1vcmUgc2FtcGxlIHF1ZXN0aW9ucyBhcyBuZWVkZWRcbiAgICBdXG5cbiAgICB0aGlzLnNhdmVRdWVzdGlvbnMoc2FtcGxlUXVlc3Rpb25zKVxuICAgIHJldHVybiBzYW1wbGVRdWVzdGlvbnNcbiAgfVxuXG4gIC8vIEJhY2t1cCBhbmQgcmVzdG9yZSBmdW5jdGlvbmFsaXR5XG4gIGNyZWF0ZUJhY2t1cCgpOiBzdHJpbmcge1xuICAgIGNvbnN0IGJhY2t1cCA9IHtcbiAgICAgIHF1ZXN0aW9uczogdGhpcy5nZXRRdWVzdGlvbnMoKSxcbiAgICAgIHNldHRpbmdzOiB0aGlzLmdldFNldHRpbmdzKCksXG4gICAgICBkcmFmdHM6IHRoaXMuZ2V0RHJhZnRzKCksXG4gICAgICB0aW1lc3RhbXA6IERhdGUubm93KCksXG4gICAgICB2ZXJzaW9uOiAnMS4wJ1xuICAgIH1cblxuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShiYWNrdXAsIG51bGwsIDIpXG4gIH1cblxuICByZXN0b3JlRnJvbUJhY2t1cChiYWNrdXBEYXRhOiBzdHJpbmcpOiBCdWxrT3BlcmF0aW9uUmVzdWx0IHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgYmFja3VwID0gSlNPTi5wYXJzZShiYWNrdXBEYXRhKVxuXG4gICAgICBpZiAoIWJhY2t1cC5xdWVzdGlvbnMgfHwgIUFycmF5LmlzQXJyYXkoYmFja3VwLnF1ZXN0aW9ucykpIHtcbiAgICAgICAgdGhyb3cgbmV3IFF1aXpEYXRhRXJyb3IoJ0ludmFsaWQgYmFja3VwIGZvcm1hdDogbWlzc2luZyBxdWVzdGlvbnMgYXJyYXknLCAnSU5WQUxJRF9CQUNLVVAnKVxuICAgICAgfVxuXG4gICAgICAvLyBWYWxpZGF0ZSBhbGwgcXVlc3Rpb25zIGluIGJhY2t1cFxuICAgICAgYmFja3VwLnF1ZXN0aW9ucy5mb3JFYWNoKChxOiBhbnksIGluZGV4OiBudW1iZXIpID0+IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB0aGlzLnZhbGlkYXRlUXVlc3Rpb24ocSlcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgUXVpekRhdGFFcnJvcihcbiAgICAgICAgICAgIGBJbnZhbGlkIHF1ZXN0aW9uIGF0IGluZGV4ICR7aW5kZXh9OiAke2Vycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogJ1Vua25vd24gZXJyb3InfWAsXG4gICAgICAgICAgICAnSU5WQUxJRF9CQUNLVVBfUVVFU1RJT04nXG4gICAgICAgICAgKVxuICAgICAgICB9XG4gICAgICB9KVxuXG4gICAgICAvLyBDcmVhdGUgY3VycmVudCBiYWNrdXAgYmVmb3JlIHJlc3RvcmVcbiAgICAgIGNvbnN0IGN1cnJlbnRCYWNrdXAgPSB0aGlzLmNyZWF0ZUJhY2t1cCgpXG4gICAgICB0aGlzLnNhZmVTZXRJdGVtKFFVSVpfU1RPUkFHRV9LRVlTLkJBQ0tVUCwgY3VycmVudEJhY2t1cClcblxuICAgICAgLy8gUmVzdG9yZSBkYXRhXG4gICAgICB0aGlzLnNhdmVRdWVzdGlvbnMoYmFja3VwLnF1ZXN0aW9ucylcbiAgICAgIGlmIChiYWNrdXAuc2V0dGluZ3MpIHtcbiAgICAgICAgdGhpcy5zYWZlU2V0SXRlbShRVUlaX1NUT1JBR0VfS0VZUy5TRVRUSU5HUywgSlNPTi5zdHJpbmdpZnkoYmFja3VwLnNldHRpbmdzKSlcbiAgICAgIH1cbiAgICAgIGlmIChiYWNrdXAuZHJhZnRzKSB7XG4gICAgICAgIHRoaXMuc2FmZVNldEl0ZW0oUVVJWl9TVE9SQUdFX0tFWVMuRFJBRlRTLCBKU09OLnN0cmluZ2lmeShiYWNrdXAuZHJhZnRzKSlcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc3VjY2VzczogdHJ1ZSxcbiAgICAgICAgcHJvY2Vzc2VkQ291bnQ6IGJhY2t1cC5xdWVzdGlvbnMubGVuZ3RoLFxuICAgICAgICBlcnJvckNvdW50OiAwLFxuICAgICAgICBlcnJvcnM6IFtdXG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHRocm93IG5ldyBRdWl6RGF0YUVycm9yKFxuICAgICAgICBgRmFpbGVkIHRvIHJlc3RvcmUgYmFja3VwOiAke2Vycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogJ1Vua25vd24gZXJyb3InfWAsXG4gICAgICAgICdSRVNUT1JFX0ZBSUxFRCdcbiAgICAgIClcbiAgICB9XG4gIH1cblxuICAvLyBBdXRvLXNhdmUgZnVuY3Rpb25hbGl0eSBmb3IgZHJhZnRzXG4gIHN0YXJ0QXV0b1NhdmUoZHJhZnRJZDogc3RyaW5nLCBnZXREcmFmdERhdGE6ICgpID0+IFBhcnRpYWw8UXVlc3Rpb25EcmFmdD4pOiB2b2lkIHtcbiAgICB0aGlzLnN0b3BBdXRvU2F2ZSgpXG5cbiAgICB0aGlzLmF1dG9TYXZlVGltZXIgPSBzZXRJbnRlcnZhbCgoKSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBkcmFmdERhdGEgPSBnZXREcmFmdERhdGEoKVxuICAgICAgICBpZiAoZHJhZnREYXRhLnF1ZXN0aW9uICYmIGRyYWZ0RGF0YS5xdWVzdGlvbi5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgY29uc3QgZHJhZnQ6IFF1ZXN0aW9uRHJhZnQgPSB7XG4gICAgICAgICAgICBpZDogZHJhZnRJZCxcbiAgICAgICAgICAgIHF1ZXN0aW9uOiBkcmFmdERhdGEucXVlc3Rpb24gfHwgJycsXG4gICAgICAgICAgICBvcHRpb25zOiBkcmFmdERhdGEub3B0aW9ucyB8fCBbJycsICcnLCAnJywgJyddLFxuICAgICAgICAgICAgY29ycmVjdEFuc3dlcjogZHJhZnREYXRhLmNvcnJlY3RBbnN3ZXIgfHwgMCxcbiAgICAgICAgICAgIGNhdGVnb3J5OiBkcmFmdERhdGEuY2F0ZWdvcnkgfHwgJ2ZhY3RzJyxcbiAgICAgICAgICAgIGRpZmZpY3VsdHk6IGRyYWZ0RGF0YS5kaWZmaWN1bHR5IHx8ICdiZWdpbm5lcicsXG4gICAgICAgICAgICB0eXBlOiBkcmFmdERhdGEudHlwZSB8fCAncmVndWxhcicsXG4gICAgICAgICAgICBmdW5GYWN0OiBkcmFmdERhdGEuZnVuRmFjdCxcbiAgICAgICAgICAgIHRhZ3M6IGRyYWZ0RGF0YS50YWdzLFxuICAgICAgICAgICAgbGFzdFNhdmVkOiBEYXRlLm5vdygpXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGhpcy5zYXZlRHJhZnQoZHJhZnQpXG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0F1dG8tc2F2ZSBmYWlsZWQ6JywgZXJyb3IpXG4gICAgICB9XG4gICAgfSwgVkFMSURBVElPTl9SVUxFUy5BVVRPX1NBVkVfSU5URVJWQUwpXG4gIH1cblxuICBzdG9wQXV0b1NhdmUoKTogdm9pZCB7XG4gICAgaWYgKHRoaXMuYXV0b1NhdmVUaW1lcikge1xuICAgICAgY2xlYXJJbnRlcnZhbCh0aGlzLmF1dG9TYXZlVGltZXIpXG4gICAgICB0aGlzLmF1dG9TYXZlVGltZXIgPSBudWxsXG4gICAgfVxuICB9XG5cbiAgLy8gQ1NWIEV4cG9ydCBmdW5jdGlvbmFsaXR5XG4gIGV4cG9ydFRvQ1NWKHF1ZXN0aW9uc1RvRXhwb3J0PzogUXVpelF1ZXN0aW9uW10pOiBzdHJpbmcge1xuICAgIGNvbnN0IHF1ZXN0aW9ucyA9IHF1ZXN0aW9uc1RvRXhwb3J0IHx8IHRoaXMuZ2V0UXVlc3Rpb25zKClcbiAgICBjb25zdCBoZWFkZXJzID0gW1xuICAgICAgJ0lEJyxcbiAgICAgICdRdWVzdGlvbicsXG4gICAgICAnT3B0aW9uIDEnLFxuICAgICAgJ09wdGlvbiAyJyxcbiAgICAgICdPcHRpb24gMycsXG4gICAgICAnT3B0aW9uIDQnLFxuICAgICAgJ0NvcnJlY3QgQW5zd2VyICgxLTQpJyxcbiAgICAgICdDYXRlZ29yeScsXG4gICAgICAnRGlmZmljdWx0eScsXG4gICAgICAnVHlwZScsXG4gICAgICAnRnVuIEZhY3QnLFxuICAgICAgJ1RhZ3MnLFxuICAgICAgJ0NyZWF0ZWQgQXQnLFxuICAgICAgJ1VwZGF0ZWQgQXQnXG4gICAgXVxuXG4gICAgY29uc3QgY3N2Um93cyA9IFtoZWFkZXJzLmpvaW4oJywnKV1cblxuICAgIHF1ZXN0aW9ucy5mb3JFYWNoKHF1ZXN0aW9uID0+IHtcbiAgICAgIGNvbnN0IHJvdyA9IFtcbiAgICAgICAgcXVlc3Rpb24uaWQsXG4gICAgICAgIGBcIiR7cXVlc3Rpb24ucXVlc3Rpb24ucmVwbGFjZSgvXCIvZywgJ1wiXCInKX1cImAsIC8vIEVzY2FwZSBxdW90ZXNcbiAgICAgICAgYFwiJHtxdWVzdGlvbi5vcHRpb25zWzBdPy5yZXBsYWNlKC9cIi9nLCAnXCJcIicpIHx8ICcnfVwiYCxcbiAgICAgICAgYFwiJHtxdWVzdGlvbi5vcHRpb25zWzFdPy5yZXBsYWNlKC9cIi9nLCAnXCJcIicpIHx8ICcnfVwiYCxcbiAgICAgICAgYFwiJHtxdWVzdGlvbi5vcHRpb25zWzJdPy5yZXBsYWNlKC9cIi9nLCAnXCJcIicpIHx8ICcnfVwiYCxcbiAgICAgICAgYFwiJHtxdWVzdGlvbi5vcHRpb25zWzNdPy5yZXBsYWNlKC9cIi9nLCAnXCJcIicpIHx8ICcnfVwiYCxcbiAgICAgICAgcXVlc3Rpb24uY29ycmVjdEFuc3dlciArIDEsIC8vIENvbnZlcnQgMC1iYXNlZCB0byAxLWJhc2VkXG4gICAgICAgIHF1ZXN0aW9uLmNhdGVnb3J5LFxuICAgICAgICBxdWVzdGlvbi5kaWZmaWN1bHR5LFxuICAgICAgICBxdWVzdGlvbi50eXBlLFxuICAgICAgICBgXCIkeyhxdWVzdGlvbi5mdW5GYWN0IHx8ICcnKS5yZXBsYWNlKC9cIi9nLCAnXCJcIicpfVwiYCxcbiAgICAgICAgYFwiJHsocXVlc3Rpb24udGFncyB8fCBbXSkuam9pbignOycpfVwiYCxcbiAgICAgICAgbmV3IERhdGUocXVlc3Rpb24uY3JlYXRlZEF0KS50b0lTT1N0cmluZygpLFxuICAgICAgICBuZXcgRGF0ZShxdWVzdGlvbi51cGRhdGVkQXQpLnRvSVNPU3RyaW5nKClcbiAgICAgIF1cbiAgICAgIGNzdlJvd3MucHVzaChyb3cuam9pbignLCcpKVxuICAgIH0pXG5cbiAgICByZXR1cm4gY3N2Um93cy5qb2luKCdcXG4nKVxuICB9XG5cbiAgLy8gRG93bmxvYWQgQ1NWIGZpbGVcbiAgZG93bmxvYWRDU1YoKTogdm9pZCB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGNzdkNvbnRlbnQgPSB0aGlzLmV4cG9ydFRvQ1NWKClcbiAgICAgIGNvbnN0IGJsb2IgPSBuZXcgQmxvYihbY3N2Q29udGVudF0sIHsgdHlwZTogJ3RleHQvY3N2O2NoYXJzZXQ9dXRmLTg7JyB9KVxuICAgICAgY29uc3QgbGluayA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2EnKVxuXG4gICAgICBpZiAobGluay5kb3dubG9hZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNvbnN0IHVybCA9IFVSTC5jcmVhdGVPYmplY3RVUkwoYmxvYilcbiAgICAgICAgbGluay5zZXRBdHRyaWJ1dGUoJ2hyZWYnLCB1cmwpXG4gICAgICAgIGxpbmsuc2V0QXR0cmlidXRlKCdkb3dubG9hZCcsIGB0ZWNoa3dpei1xdWVzdGlvbnMtJHtuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCkuc3BsaXQoJ1QnKVswXX0uY3N2YClcbiAgICAgICAgbGluay5zdHlsZS52aXNpYmlsaXR5ID0gJ2hpZGRlbidcbiAgICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChsaW5rKVxuICAgICAgICBsaW5rLmNsaWNrKClcbiAgICAgICAgZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZChsaW5rKVxuICAgICAgICBVUkwucmV2b2tlT2JqZWN0VVJMKHVybClcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgdGhyb3cgbmV3IFF1aXpEYXRhRXJyb3IoJ0ZhaWxlZCB0byBkb3dubG9hZCBDU1YgZmlsZScsICdFWFBPUlRfRVJST1InKVxuICAgIH1cbiAgfVxuXG4gIC8vIFBhcnNlIENTViBjb250ZW50XG4gIHBhcnNlQ1NWKGNzdkNvbnRlbnQ6IHN0cmluZyk6IHsgcXVlc3Rpb25zOiBQYXJ0aWFsPFF1aXpRdWVzdGlvbj5bXTsgZXJyb3JzOiBzdHJpbmdbXSB9IHtcbiAgICBjb25zdCBsaW5lcyA9IGNzdkNvbnRlbnQuc3BsaXQoJ1xcbicpLmZpbHRlcihsaW5lID0+IGxpbmUudHJpbSgpKVxuICAgIGNvbnN0IGVycm9yczogc3RyaW5nW10gPSBbXVxuICAgIGNvbnN0IHF1ZXN0aW9uczogUGFydGlhbDxRdWl6UXVlc3Rpb24+W10gPSBbXVxuXG4gICAgaWYgKGxpbmVzLmxlbmd0aCA8IDIpIHtcbiAgICAgIGVycm9ycy5wdXNoKCdDU1YgZmlsZSBtdXN0IGNvbnRhaW4gYXQgbGVhc3QgYSBoZWFkZXIgcm93IGFuZCBvbmUgZGF0YSByb3cnKVxuICAgICAgcmV0dXJuIHsgcXVlc3Rpb25zLCBlcnJvcnMgfVxuICAgIH1cblxuICAgIC8vIFNraXAgaGVhZGVyIHJvd1xuICAgIGNvbnN0IGRhdGFMaW5lcyA9IGxpbmVzLnNsaWNlKDEpXG5cbiAgICBkYXRhTGluZXMuZm9yRWFjaCgobGluZSwgaW5kZXgpID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHZhbHVlcyA9IHRoaXMucGFyc2VDU1ZMaW5lKGxpbmUpXG5cbiAgICAgICAgaWYgKHZhbHVlcy5sZW5ndGggPCA4KSB7XG4gICAgICAgICAgZXJyb3JzLnB1c2goYFJvdyAke2luZGV4ICsgMn06IEluc3VmZmljaWVudCBjb2x1bW5zIChtaW5pbXVtIDggcmVxdWlyZWQpYClcbiAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IFtpZCwgcXVlc3Rpb24sIG9wdDEsIG9wdDIsIG9wdDMsIG9wdDQsIGNvcnJlY3RBbnN3ZXIsIGNhdGVnb3J5LCBkaWZmaWN1bHR5LCB0eXBlLCBmdW5GYWN0LCB0YWdzLCBjcmVhdGVkQXQsIHVwZGF0ZWRBdF0gPSB2YWx1ZXNcblxuICAgICAgICAvLyBWYWxpZGF0ZSByZXF1aXJlZCBmaWVsZHNcbiAgICAgICAgaWYgKCFxdWVzdGlvbj8udHJpbSgpKSB7XG4gICAgICAgICAgZXJyb3JzLnB1c2goYFJvdyAke2luZGV4ICsgMn06IFF1ZXN0aW9uIGlzIHJlcXVpcmVkYClcbiAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghb3B0MT8udHJpbSgpIHx8ICFvcHQyPy50cmltKCkgfHwgIW9wdDM/LnRyaW0oKSB8fCAhb3B0ND8udHJpbSgpKSB7XG4gICAgICAgICAgZXJyb3JzLnB1c2goYFJvdyAke2luZGV4ICsgMn06IEFsbCA0IG9wdGlvbnMgYXJlIHJlcXVpcmVkYClcbiAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGNvcnJlY3RBbnN3ZXJOdW0gPSBwYXJzZUludChjb3JyZWN0QW5zd2VyKSAtIDEgLy8gQ29udmVydCAxLWJhc2VkIHRvIDAtYmFzZWRcbiAgICAgICAgaWYgKGlzTmFOKGNvcnJlY3RBbnN3ZXJOdW0pIHx8IGNvcnJlY3RBbnN3ZXJOdW0gPCAwIHx8IGNvcnJlY3RBbnN3ZXJOdW0gPiAzKSB7XG4gICAgICAgICAgZXJyb3JzLnB1c2goYFJvdyAke2luZGV4ICsgMn06IENvcnJlY3QgYW5zd2VyIG11c3QgYmUgMSwgMiwgMywgb3IgNGApXG4gICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWNhdGVnb3J5Py50cmltKCkpIHtcbiAgICAgICAgICBlcnJvcnMucHVzaChgUm93ICR7aW5kZXggKyAyfTogQ2F0ZWdvcnkgaXMgcmVxdWlyZWRgKVxuICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFbJ2JlZ2lubmVyJywgJ2ludGVybWVkaWF0ZScsICdhZHZhbmNlZCddLmluY2x1ZGVzKGRpZmZpY3VsdHkpKSB7XG4gICAgICAgICAgZXJyb3JzLnB1c2goYFJvdyAke2luZGV4ICsgMn06IERpZmZpY3VsdHkgbXVzdCBiZSAnYmVnaW5uZXInLCAnaW50ZXJtZWRpYXRlJywgb3IgJ2FkdmFuY2VkJ2ApXG4gICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIVsncmVndWxhcicsICdib251cyddLmluY2x1ZGVzKHR5cGUpKSB7XG4gICAgICAgICAgZXJyb3JzLnB1c2goYFJvdyAke2luZGV4ICsgMn06IFR5cGUgbXVzdCBiZSAncmVndWxhcicgb3IgJ2JvbnVzJ2ApXG4gICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBxdWVzdGlvbkRhdGE6IFBhcnRpYWw8UXVpelF1ZXN0aW9uPiA9IHtcbiAgICAgICAgICBpZDogaWQgfHwgYGltcG9ydGVkXyR7RGF0ZS5ub3coKX1fJHtpbmRleH1gLFxuICAgICAgICAgIHF1ZXN0aW9uOiBxdWVzdGlvbi50cmltKCksXG4gICAgICAgICAgb3B0aW9uczogW29wdDEudHJpbSgpLCBvcHQyLnRyaW0oKSwgb3B0My50cmltKCksIG9wdDQudHJpbSgpXSxcbiAgICAgICAgICBjb3JyZWN0QW5zd2VyOiBjb3JyZWN0QW5zd2VyTnVtLFxuICAgICAgICAgIGNhdGVnb3J5OiBjYXRlZ29yeS50cmltKCksXG4gICAgICAgICAgZGlmZmljdWx0eTogZGlmZmljdWx0eSBhcyAnYmVnaW5uZXInIHwgJ2ludGVybWVkaWF0ZScgfCAnYWR2YW5jZWQnLFxuICAgICAgICAgIHR5cGU6IHR5cGUgYXMgJ3JlZ3VsYXInIHwgJ2JvbnVzJyxcbiAgICAgICAgICBmdW5GYWN0OiBmdW5GYWN0Py50cmltKCkgfHwgdW5kZWZpbmVkLFxuICAgICAgICAgIHRhZ3M6IHRhZ3MgPyB0YWdzLnNwbGl0KCc7JykubWFwKHRhZyA9PiB0YWcudHJpbSgpKS5maWx0ZXIoQm9vbGVhbikgOiBbXSxcbiAgICAgICAgICBjcmVhdGVkQXQ6IGNyZWF0ZWRBdCA/IG5ldyBEYXRlKGNyZWF0ZWRBdCkuZ2V0VGltZSgpIDogRGF0ZS5ub3coKSxcbiAgICAgICAgICB1cGRhdGVkQXQ6IHVwZGF0ZWRBdCA/IG5ldyBEYXRlKHVwZGF0ZWRBdCkuZ2V0VGltZSgpIDogRGF0ZS5ub3coKVxuICAgICAgICB9XG5cbiAgICAgICAgcXVlc3Rpb25zLnB1c2gocXVlc3Rpb25EYXRhKVxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgZXJyb3JzLnB1c2goYFJvdyAke2luZGV4ICsgMn06ICR7ZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiAnUGFyc2UgZXJyb3InfWApXG4gICAgICB9XG4gICAgfSlcblxuICAgIHJldHVybiB7IHF1ZXN0aW9ucywgZXJyb3JzIH1cbiAgfVxuXG4gIC8vIEhlbHBlciB0byBwYXJzZSBDU1YgbGluZSB3aXRoIHByb3BlciBxdW90ZSBoYW5kbGluZ1xuICBwcml2YXRlIHBhcnNlQ1NWTGluZShsaW5lOiBzdHJpbmcpOiBzdHJpbmdbXSB7XG4gICAgY29uc3QgcmVzdWx0OiBzdHJpbmdbXSA9IFtdXG4gICAgbGV0IGN1cnJlbnQgPSAnJ1xuICAgIGxldCBpblF1b3RlcyA9IGZhbHNlXG4gICAgbGV0IGkgPSAwXG5cbiAgICB3aGlsZSAoaSA8IGxpbmUubGVuZ3RoKSB7XG4gICAgICBjb25zdCBjaGFyID0gbGluZVtpXVxuXG4gICAgICBpZiAoY2hhciA9PT0gJ1wiJykge1xuICAgICAgICBpZiAoaW5RdW90ZXMgJiYgbGluZVtpICsgMV0gPT09ICdcIicpIHtcbiAgICAgICAgICAvLyBFc2NhcGVkIHF1b3RlXG4gICAgICAgICAgY3VycmVudCArPSAnXCInXG4gICAgICAgICAgaSArPSAyXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gVG9nZ2xlIHF1b3RlIHN0YXRlXG4gICAgICAgICAgaW5RdW90ZXMgPSAhaW5RdW90ZXNcbiAgICAgICAgICBpKytcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChjaGFyID09PSAnLCcgJiYgIWluUXVvdGVzKSB7XG4gICAgICAgIC8vIEVuZCBvZiBmaWVsZFxuICAgICAgICByZXN1bHQucHVzaChjdXJyZW50KVxuICAgICAgICBjdXJyZW50ID0gJydcbiAgICAgICAgaSsrXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjdXJyZW50ICs9IGNoYXJcbiAgICAgICAgaSsrXG4gICAgICB9XG4gICAgfVxuXG4gICAgcmVzdWx0LnB1c2goY3VycmVudCkgLy8gQWRkIGxhc3QgZmllbGRcbiAgICByZXR1cm4gcmVzdWx0XG4gIH1cblxuICAvLyBJbXBvcnQgZnJvbSBDU1ZcbiAgaW1wb3J0RnJvbUNTVihjc3ZDb250ZW50OiBzdHJpbmcpOiBCdWxrT3BlcmF0aW9uUmVzdWx0IHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgeyBxdWVzdGlvbnMsIGVycm9ycyB9ID0gdGhpcy5wYXJzZUNTVihjc3ZDb250ZW50KVxuXG4gICAgICBpZiAoZXJyb3JzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgICBwcm9jZXNzZWRDb3VudDogMCxcbiAgICAgICAgICBlcnJvckNvdW50OiBlcnJvcnMubGVuZ3RoLFxuICAgICAgICAgIGVycm9yc1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGxldCBzdWNjZXNzQ291bnQgPSAwXG4gICAgICBjb25zdCBpbXBvcnRFcnJvcnM6IHN0cmluZ1tdID0gW11cblxuICAgICAgcXVlc3Rpb25zLmZvckVhY2goKHF1ZXN0aW9uRGF0YSwgaW5kZXgpID0+IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjb25zdCBmdWxsUXVlc3Rpb246IFF1aXpRdWVzdGlvbiA9IHtcbiAgICAgICAgICAgIGlkOiBxdWVzdGlvbkRhdGEuaWQhLFxuICAgICAgICAgICAgcXVlc3Rpb246IHF1ZXN0aW9uRGF0YS5xdWVzdGlvbiEsXG4gICAgICAgICAgICBvcHRpb25zOiBxdWVzdGlvbkRhdGEub3B0aW9ucyEsXG4gICAgICAgICAgICBjb3JyZWN0QW5zd2VyOiBxdWVzdGlvbkRhdGEuY29ycmVjdEFuc3dlciEsXG4gICAgICAgICAgICBjYXRlZ29yeTogcXVlc3Rpb25EYXRhLmNhdGVnb3J5ISxcbiAgICAgICAgICAgIGRpZmZpY3VsdHk6IHF1ZXN0aW9uRGF0YS5kaWZmaWN1bHR5ISxcbiAgICAgICAgICAgIHR5cGU6IHF1ZXN0aW9uRGF0YS50eXBlISxcbiAgICAgICAgICAgIGZ1bkZhY3Q6IHF1ZXN0aW9uRGF0YS5mdW5GYWN0LFxuICAgICAgICAgICAgdGFnczogcXVlc3Rpb25EYXRhLnRhZ3MgfHwgW10sXG4gICAgICAgICAgICBjcmVhdGVkQXQ6IHF1ZXN0aW9uRGF0YS5jcmVhdGVkQXQhLFxuICAgICAgICAgICAgdXBkYXRlZEF0OiBxdWVzdGlvbkRhdGEudXBkYXRlZEF0IVxuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIFZhbGlkYXRlIHRoZSBjb21wbGV0ZSBxdWVzdGlvblxuICAgICAgICAgIGNvbnN0IHZhbGlkYXRpb24gPSB0aGlzLnZhbGlkYXRlUXVlc3Rpb24oZnVsbFF1ZXN0aW9uKVxuICAgICAgICAgIGlmICghdmFsaWRhdGlvbi5pc1ZhbGlkKSB7XG4gICAgICAgICAgICBpbXBvcnRFcnJvcnMucHVzaChgUXVlc3Rpb24gJHtpbmRleCArIDF9OiAke3ZhbGlkYXRpb24uZXJyb3JzLmpvaW4oJywgJyl9YClcbiAgICAgICAgICAgIHJldHVyblxuICAgICAgICAgIH1cblxuICAgICAgICAgIHRoaXMuc2F2ZVF1ZXN0aW9uKGZ1bGxRdWVzdGlvbilcbiAgICAgICAgICBzdWNjZXNzQ291bnQrK1xuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgIGltcG9ydEVycm9ycy5wdXNoKGBRdWVzdGlvbiAke2luZGV4ICsgMX06ICR7ZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiAnU2F2ZSBlcnJvcid9YClcbiAgICAgICAgfVxuICAgICAgfSlcblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc3VjY2VzczogaW1wb3J0RXJyb3JzLmxlbmd0aCA9PT0gMCxcbiAgICAgICAgcHJvY2Vzc2VkQ291bnQ6IHN1Y2Nlc3NDb3VudCxcbiAgICAgICAgZXJyb3JDb3VudDogaW1wb3J0RXJyb3JzLmxlbmd0aCxcbiAgICAgICAgZXJyb3JzOiBpbXBvcnRFcnJvcnNcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICAgIHByb2Nlc3NlZENvdW50OiAwLFxuICAgICAgICBlcnJvckNvdW50OiAxLFxuICAgICAgICBlcnJvcnM6IFtlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6ICdJbXBvcnQgZmFpbGVkJ11cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLy8gRXhwb3J0IHNpbmdsZXRvbiBpbnN0YW5jZVxuZXhwb3J0IGNvbnN0IHF1aXpEYXRhTWFuYWdlciA9IFF1aXpEYXRhTWFuYWdlci5nZXRJbnN0YW5jZSgpXG4iXSwibmFtZXMiOlsiUVVJWl9TVE9SQUdFX0tFWVMiLCJERUZBVUxUX0NBVEVHT1JJRVMiLCJWQUxJREFUSU9OX1JVTEVTIiwiUVVFU1RJT05fTUlOX0xFTkdUSCIsIlFVRVNUSU9OX01BWF9MRU5HVEgiLCJPUFRJT05fTUlOX0xFTkdUSCIsIk9QVElPTl9NQVhfTEVOR1RIIiwiTUlOX09QVElPTlMiLCJNQVhfT1BUSU9OUyIsIk1BWF9CVUxLX09QRVJBVElPTlMiLCJNQVhfRklMRV9TSVpFIiwiQVVUT19TQVZFX0lOVEVSVkFMIiwiUXVpekRhdGFFcnJvciIsIkVycm9yIiwibWVzc2FnZSIsImNvZGUiLCJuYW1lIiwiUXVpekRhdGFNYW5hZ2VyIiwiZ2V0SW5zdGFuY2UiLCJpbnN0YW5jZSIsInNhZmVHZXRJdGVtIiwia2V5IiwibG9jYWxTdG9yYWdlIiwiZ2V0SXRlbSIsImVycm9yIiwiY29uc29sZSIsInNhZmVTZXRJdGVtIiwidmFsdWUiLCJzZXRJdGVtIiwiRE9NRXhjZXB0aW9uIiwiZ2V0UXVlc3Rpb25zIiwiZGF0YSIsIlFVRVNUSU9OUyIsImluaXRpYWxpemVXaXRoU2FtcGxlRGF0YSIsInF1ZXN0aW9ucyIsIkpTT04iLCJwYXJzZSIsIkFycmF5IiwiaXNBcnJheSIsInNhdmVRdWVzdGlvbiIsInF1ZXN0aW9uIiwidmFsaWRhdGVRdWVzdGlvbiIsIm5vdyIsIkRhdGUiLCJuZXdRdWVzdGlvbiIsImlkIiwiZ2VuZXJhdGVJZCIsImNyZWF0ZWRBdCIsInVwZGF0ZWRBdCIsInB1c2giLCJzYXZlUXVlc3Rpb25zIiwidXBkYXRlUXVlc3Rpb24iLCJ1cGRhdGVzIiwiaW5kZXgiLCJmaW5kSW5kZXgiLCJxIiwidXBkYXRlZFF1ZXN0aW9uIiwiZGVsZXRlUXVlc3Rpb24iLCJmaWx0ZXJlZFF1ZXN0aW9ucyIsImZpbHRlciIsImxlbmd0aCIsImJ1bGtEZWxldGUiLCJpZHMiLCJpbml0aWFsQ291bnQiLCJpbmNsdWRlcyIsImRlbGV0ZWRDb3VudCIsInN1Y2Nlc3MiLCJwcm9jZXNzZWRDb3VudCIsImVycm9yQ291bnQiLCJlcnJvcnMiLCJzZWFyY2hRdWVzdGlvbnMiLCJmaWx0ZXJzIiwic2VhcmNoVGV4dCIsInNlYXJjaExvd2VyIiwidG9Mb3dlckNhc2UiLCJjYXRlZ29yeSIsImRpZmZpY3VsdHkiLCJ0eXBlIiwiZ2V0Q2F0ZWdvcmllcyIsImNhdGVnb3J5Q291bnRzIiwicmVkdWNlIiwiYWNjIiwibWFwIiwicXVlc3Rpb25Db3VudCIsInNhdmVEcmFmdCIsImRyYWZ0IiwiZHJhZnRzIiwiZ2V0RHJhZnRzIiwiZXhpc3RpbmdJbmRleCIsImQiLCJsYXN0U2F2ZWQiLCJEUkFGVFMiLCJzdHJpbmdpZnkiLCJkZWxldGVEcmFmdCIsImdldFNldHRpbmdzIiwiU0VUVElOR1MiLCJnZXREZWZhdWx0U2V0dGluZ3MiLCJzYXZlU2V0dGluZ3MiLCJzZXR0aW5ncyIsImN1cnJlbnRTZXR0aW5ncyIsInVwZGF0ZWRTZXR0aW5ncyIsInBhZ2VTaXplIiwic29ydEJ5Iiwic29ydE9yZGVyIiwic2VsZWN0ZWRRdWVzdGlvbnMiLCJvcHRpb25zIiwiZm9yRWFjaCIsIm9wdGlvbiIsInVuaXF1ZU9wdGlvbnMiLCJTZXQiLCJvcHQiLCJ0cmltIiwic2l6ZSIsImNvcnJlY3RBbnN3ZXIiLCJ2YWxpZENhdGVnb3JpZXMiLCJjIiwiTWF0aCIsInJhbmRvbSIsInRvU3RyaW5nIiwic3Vic3RyIiwiZXhwb3J0VG9DU1YiLCJxdWVzdGlvbnNUb0V4cG9ydCIsImhlYWRlcnMiLCJjc3ZSb3dzIiwiam9pbiIsInJlcGxhY2UiLCJmdW5GYWN0IiwidGFncyIsInRvSVNPU3RyaW5nIiwiaW1wb3J0RnJvbUNTViIsImNzdkNvbnRlbnQiLCJsaW5lcyIsInNwbGl0IiwibGluZSIsImgiLCJkYXRhTGluZXMiLCJzbGljZSIsInJlc3VsdHMiLCJ2YWxpZFF1ZXN0aW9ucyIsImV4aXN0aW5nUXVlc3Rpb25zIiwiaSIsInZhbHVlcyIsInBhcnNlQ1NWTGluZSIsInBhcnNlSW50IiwidW5kZWZpbmVkIiwidCIsImdldFRpbWUiLCJhbGxRdWVzdGlvbnMiLCJyZXN1bHQiLCJjdXJyZW50IiwiaW5RdW90ZXMiLCJjaGFyIiwic2FtcGxlUXVlc3Rpb25zIiwiY3JlYXRlQmFja3VwIiwiYmFja3VwIiwidGltZXN0YW1wIiwidmVyc2lvbiIsInJlc3RvcmVGcm9tQmFja3VwIiwiYmFja3VwRGF0YSIsImN1cnJlbnRCYWNrdXAiLCJCQUNLVVAiLCJzdGFydEF1dG9TYXZlIiwiZHJhZnRJZCIsImdldERyYWZ0RGF0YSIsInN0b3BBdXRvU2F2ZSIsImF1dG9TYXZlVGltZXIiLCJzZXRJbnRlcnZhbCIsImRyYWZ0RGF0YSIsImNsZWFySW50ZXJ2YWwiLCJyb3ciLCJkb3dubG9hZENTViIsImJsb2IiLCJCbG9iIiwibGluayIsImRvY3VtZW50IiwiY3JlYXRlRWxlbWVudCIsImRvd25sb2FkIiwidXJsIiwiVVJMIiwiY3JlYXRlT2JqZWN0VVJMIiwic2V0QXR0cmlidXRlIiwic3R5bGUiLCJ2aXNpYmlsaXR5IiwiYm9keSIsImFwcGVuZENoaWxkIiwiY2xpY2siLCJyZW1vdmVDaGlsZCIsInJldm9rZU9iamVjdFVSTCIsInBhcnNlQ1NWIiwib3B0MSIsIm9wdDIiLCJvcHQzIiwib3B0NCIsImNvcnJlY3RBbnN3ZXJOdW0iLCJpc05hTiIsInF1ZXN0aW9uRGF0YSIsInRhZyIsIkJvb2xlYW4iLCJzdWNjZXNzQ291bnQiLCJpbXBvcnRFcnJvcnMiLCJmdWxsUXVlc3Rpb24iLCJ2YWxpZGF0aW9uIiwiaXNWYWxpZCIsInF1aXpEYXRhTWFuYWdlciJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/utils/quizDataManager.ts\n"));

/***/ })

});