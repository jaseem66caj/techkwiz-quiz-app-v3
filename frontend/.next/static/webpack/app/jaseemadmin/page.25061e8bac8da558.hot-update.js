"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/jaseemadmin/page",{

/***/ "(app-pages-browser)/./src/utils/adminAuth.ts":
/*!********************************!*\
  !*** ./src/utils/adminAuth.ts ***!
  \********************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AdminAuth: () => (/* binding */ AdminAuth)\n/* harmony export */ });\n/* provided dependency */ var process = __webpack_require__(/*! process */ \"(app-pages-browser)/./node_modules/next/dist/build/polyfills/process.js\");\n// Simple hash function for password verification\nfunction simpleHash(str) {\n    let hash = 0;\n    for(let i = 0; i < str.length; i++){\n        const char = str.charCodeAt(i);\n        hash = (hash << 5) - hash + char;\n        hash = hash & hash; // Convert to 32bit integer\n    }\n    return Math.abs(hash).toString(16);\n}\n// Default development password\nconst DEFAULT_PASSWORD = 'TechKwiz2024!Admin';\nconst DEFAULT_PASSWORD_HASH = simpleHash(DEFAULT_PASSWORD);\nclass AdminAuth {\n    static getPasswordHash() {\n        // In production, this should come from environment variables\n        return process.env.NEXT_PUBLIC_ADMIN_PASSWORD_HASH || DEFAULT_PASSWORD_HASH;\n    }\n    static verifyPassword(password) {\n        const inputHash = simpleHash(password);\n        const expectedHash = this.getPasswordHash();\n        return inputHash === expectedHash;\n    }\n    static getSession() {\n        if (false) {}\n        try {\n            const sessionData = localStorage.getItem(this.SESSION_KEY);\n            if (!sessionData) return null;\n            const session = JSON.parse(sessionData);\n            // Check if session is expired\n            const now = Date.now();\n            if (now - session.lastActivity > this.SESSION_TIMEOUT) {\n                this.clearSession();\n                return null;\n            }\n            // Check if account is locked out\n            if (session.lockoutUntil && now < session.lockoutUntil) {\n                return session;\n            }\n            // Update last activity\n            session.lastActivity = now;\n            localStorage.setItem(this.SESSION_KEY, JSON.stringify(session));\n            return session;\n        } catch (error) {\n            console.error('Error reading admin session:', error);\n            this.clearSession();\n            return null;\n        }\n    }\n    static login(password) {\n        const startTime = performance.now();\n        const session = this.getSession() || {\n            isAuthenticated: false,\n            loginTime: 0,\n            lastActivity: 0,\n            sessionId: '',\n            failedAttempts: 0\n        };\n        const now = Date.now();\n        // Check if account is locked out\n        if (session.lockoutUntil && now < session.lockoutUntil) {\n            const remainingTime = Math.ceil((session.lockoutUntil - now) / 60000);\n            return {\n                success: false,\n                message: \"Account locked. Try again in \".concat(remainingTime, \" minutes.\"),\n                lockoutUntil: session.lockoutUntil\n            };\n        }\n        // Verify password (optimized)\n        const passwordVerifyStart = performance.now();\n        const isValidPassword = this.verifyPassword(password);\n        const passwordVerifyEnd = performance.now();\n        console.log(\"\\uD83D\\uDD10 Password verification took: \".concat(passwordVerifyEnd - passwordVerifyStart, \"ms\"));\n        if (isValidPassword) {\n            const sessionCreateStart = performance.now();\n            const newSession = {\n                isAuthenticated: true,\n                loginTime: now,\n                lastActivity: now,\n                sessionId: Math.random().toString(36).substring(2, 15),\n                failedAttempts: 0\n            };\n            // Optimized: Use a single localStorage operation\n            const sessionData = JSON.stringify(newSession);\n            localStorage.setItem(this.SESSION_KEY, sessionData);\n            const sessionCreateEnd = performance.now();\n            console.log(\"\\uD83D\\uDD10 Session creation took: \".concat(sessionCreateEnd - sessionCreateStart, \"ms\"));\n            // Log activity asynchronously to avoid blocking\n            setTimeout(()=>{\n                this.logActivity('login_success', 'User logged in successfully');\n            }, 0);\n            const totalTime = performance.now() - startTime;\n            console.log(\"\\uD83D\\uDD10 AdminAuth.login took: \".concat(totalTime, \"ms\"));\n            return {\n                success: true,\n                message: 'Login successful'\n            };\n        } else {\n            // Increment failed attempts\n            session.failedAttempts = (session.failedAttempts || 0) + 1;\n            if (session.failedAttempts >= this.MAX_FAILED_ATTEMPTS) {\n                session.lockoutUntil = now + this.LOCKOUT_DURATION;\n                localStorage.setItem(this.SESSION_KEY, JSON.stringify(session));\n                this.logActivity('account_locked', \"Account locked after \".concat(this.MAX_FAILED_ATTEMPTS, \" failed attempts\"));\n                return {\n                    success: false,\n                    message: \"Too many failed attempts. Account locked for 15 minutes.\",\n                    lockoutUntil: session.lockoutUntil\n                };\n            } else {\n                localStorage.setItem(this.SESSION_KEY, JSON.stringify(session));\n                const remainingAttempts = this.MAX_FAILED_ATTEMPTS - session.failedAttempts;\n                this.logActivity('login_failed', \"Failed login attempt. \".concat(remainingAttempts, \" attempts remaining\"));\n                return {\n                    success: false,\n                    message: \"Invalid password. \".concat(remainingAttempts, \" attempts remaining.\")\n                };\n            }\n        }\n    }\n    static logout() {\n        this.logActivity('logout', 'User logged out');\n        this.clearSession();\n    }\n    static clearSession() {\n        if (true) {\n            localStorage.removeItem(this.SESSION_KEY);\n        }\n    }\n    static isAuthenticated() {\n        const session = this.getSession();\n        return (session === null || session === void 0 ? void 0 : session.isAuthenticated) === true;\n    }\n    static updateActivity() {\n        const session = this.getSession();\n        if (session && session.isAuthenticated) {\n            session.lastActivity = Date.now();\n            localStorage.setItem(this.SESSION_KEY, JSON.stringify(session));\n        }\n    }\n    static logActivity(action, details) {\n        if (false) {}\n        try {\n            var _this_getSession;\n            const logs = JSON.parse(localStorage.getItem('admin_activity_logs') || '[]');\n            const logEntry = {\n                timestamp: Date.now(),\n                action,\n                details,\n                sessionId: ((_this_getSession = this.getSession()) === null || _this_getSession === void 0 ? void 0 : _this_getSession.sessionId) || 'unknown'\n            };\n            logs.push(logEntry);\n            // Keep only last 1000 entries\n            if (logs.length > 1000) {\n                logs.splice(0, logs.length - 1000);\n            }\n            localStorage.setItem('admin_activity_logs', JSON.stringify(logs));\n        } catch (error) {\n            console.error('Error logging admin activity:', error);\n        }\n    }\n    static getActivityLogs() {\n        if (false) {}\n        try {\n            return JSON.parse(localStorage.getItem('admin_activity_logs') || '[]');\n        } catch (error) {\n            console.error('Error reading activity logs:', error);\n            return [];\n        }\n    }\n}\nAdminAuth.SESSION_KEY = 'admin_session';\nAdminAuth.SESSION_TIMEOUT = 30 * 60 * 1000; // 30 minutes\nAdminAuth.MAX_FAILED_ATTEMPTS = 5;\nAdminAuth.LOCKOUT_DURATION = 15 * 60 * 1000; // 15 minutes\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy91dGlscy9hZG1pbkF1dGgudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQSxpREFBaUQ7QUFDakQsU0FBU0EsV0FBV0MsR0FBVztJQUM3QixJQUFJQyxPQUFPO0lBQ1gsSUFBSyxJQUFJQyxJQUFJLEdBQUdBLElBQUlGLElBQUlHLE1BQU0sRUFBRUQsSUFBSztRQUNuQyxNQUFNRSxPQUFPSixJQUFJSyxVQUFVLENBQUNIO1FBQzVCRCxPQUFPLENBQUVBLFFBQVEsS0FBS0EsT0FBUUc7UUFDOUJILE9BQU9BLE9BQU9BLE1BQU0sMkJBQTJCO0lBQ2pEO0lBQ0EsT0FBT0ssS0FBS0MsR0FBRyxDQUFDTixNQUFNTyxRQUFRLENBQUM7QUFDakM7QUFFQSwrQkFBK0I7QUFDL0IsTUFBTUMsbUJBQW1CO0FBQ3pCLE1BQU1DLHdCQUF3QlgsV0FBV1U7QUFXbEMsTUFBTUU7SUFNWCxPQUFPQyxrQkFBMEI7UUFDL0IsNkRBQTZEO1FBQzdELE9BQU9DLE9BQU9BLENBQUNDLEdBQUcsQ0FBQ0MsK0JBQStCLElBQUlMO0lBQ3hEO0lBRUEsT0FBT00sZUFBZUMsUUFBZ0IsRUFBVztRQUMvQyxNQUFNQyxZQUFZbkIsV0FBV2tCO1FBQzdCLE1BQU1FLGVBQWUsSUFBSSxDQUFDUCxlQUFlO1FBQ3pDLE9BQU9NLGNBQWNDO0lBQ3ZCO0lBRUEsT0FBT0MsYUFBa0M7UUFDdkMsSUFBSSxLQUE2QixFQUFFLEVBQVk7UUFFL0MsSUFBSTtZQUNGLE1BQU1DLGNBQWNDLGFBQWFDLE9BQU8sQ0FBQyxJQUFJLENBQUNDLFdBQVc7WUFDekQsSUFBSSxDQUFDSCxhQUFhLE9BQU87WUFFekIsTUFBTUksVUFBd0JDLEtBQUtDLEtBQUssQ0FBQ047WUFFekMsOEJBQThCO1lBQzlCLE1BQU1PLE1BQU1DLEtBQUtELEdBQUc7WUFDcEIsSUFBSUEsTUFBTUgsUUFBUUssWUFBWSxHQUFHLElBQUksQ0FBQ0MsZUFBZSxFQUFFO2dCQUNyRCxJQUFJLENBQUNDLFlBQVk7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QUFhQyxPQUFPLENBQUMsMEJBQTBCO1lBQ3ZFLE1BQU0rQyxXQUFXO2dCQUNmQyxXQUFXMUMsS0FBS0QsR0FBRztnQkFDbkJ1QztnQkFDQUM7Z0JBQ0F6QixXQUFXLHlCQUFJLENBQUN2QixVQUFVLGdCQUFmLHdEQUFtQnVCLFNBQVMsS0FBSTtZQUM3QztZQUVBMEIsS0FBS0csSUFBSSxDQUFDRjtZQUVWLDhCQUE4QjtZQUM5QixJQUFJRCxLQUFLbEUsTUFBTSxHQUFHLE1BQU07Z0JBQ3RCa0UsS0FBS0ksTUFBTSxDQUFDLEdBQUdKLEtBQUtsRSxNQUFNLEdBQUc7WUFDL0I7WUFFQW1CLGFBQWFZLE9BQU8sQ0FBQyx1QkFBdUJSLEtBQUtTLFNBQVMsQ0FBQ2tDO1FBQzdELEVBQUUsT0FBT2pDLE9BQU87WUFDZEMsUUFBUUQsS0FBSyxDQUFDLGlDQUFpQ0E7UUFDakQ7SUFDRjtJQUVBLE9BQU9zQyxrQkFLSjtRQUNELElBQUksS0FBNkIsRUFBRSxFQUFVO1FBRTdDLElBQUk7WUFDRixPQUFPaEQsS0FBS0MsS0FBSyxDQUFDTCxhQUFhQyxPQUFPLENBQUMsMEJBQTBCO1FBQ25FLEVBQUUsT0FBT2EsT0FBTztZQUNkQyxRQUFRRCxLQUFLLENBQUMsZ0NBQWdDQTtZQUM5QyxPQUFPLEVBQUU7UUFDWDtJQUNGO0FBQ0Y7QUFyTWF6QixVQUNhYSxjQUFjO0FBRDNCYixVQUVhb0Isa0JBQWtCLEtBQUssS0FBSyxNQUFNLGFBQWE7QUFGNURwQixVQUdha0Qsc0JBQXNCO0FBSG5DbEQsVUFJYW1ELG1CQUFtQixLQUFLLEtBQUssTUFBTSxhQUFhIiwic291cmNlcyI6WyIvVXNlcnMvamFzZWVtL0RvY3VtZW50cy9HaXRIdWIvVGVjaGt3aXotdjcvZnJvbnRlbmQvc3JjL3V0aWxzL2FkbWluQXV0aC50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBTaW1wbGUgaGFzaCBmdW5jdGlvbiBmb3IgcGFzc3dvcmQgdmVyaWZpY2F0aW9uXG5mdW5jdGlvbiBzaW1wbGVIYXNoKHN0cjogc3RyaW5nKTogc3RyaW5nIHtcbiAgbGV0IGhhc2ggPSAwO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGNoYXIgPSBzdHIuY2hhckNvZGVBdChpKTtcbiAgICBoYXNoID0gKChoYXNoIDw8IDUpIC0gaGFzaCkgKyBjaGFyO1xuICAgIGhhc2ggPSBoYXNoICYgaGFzaDsgLy8gQ29udmVydCB0byAzMmJpdCBpbnRlZ2VyXG4gIH1cbiAgcmV0dXJuIE1hdGguYWJzKGhhc2gpLnRvU3RyaW5nKDE2KTtcbn1cblxuLy8gRGVmYXVsdCBkZXZlbG9wbWVudCBwYXNzd29yZFxuY29uc3QgREVGQVVMVF9QQVNTV09SRCA9ICdUZWNoS3dpejIwMjQhQWRtaW4nO1xuY29uc3QgREVGQVVMVF9QQVNTV09SRF9IQVNIID0gc2ltcGxlSGFzaChERUZBVUxUX1BBU1NXT1JEKTtcblxuZXhwb3J0IGludGVyZmFjZSBBZG1pblNlc3Npb24ge1xuICBpc0F1dGhlbnRpY2F0ZWQ6IGJvb2xlYW47XG4gIGxvZ2luVGltZTogbnVtYmVyO1xuICBsYXN0QWN0aXZpdHk6IG51bWJlcjtcbiAgc2Vzc2lvbklkOiBzdHJpbmc7XG4gIGZhaWxlZEF0dGVtcHRzOiBudW1iZXI7XG4gIGxvY2tvdXRVbnRpbD86IG51bWJlcjtcbn1cblxuZXhwb3J0IGNsYXNzIEFkbWluQXV0aCB7XG4gIHByaXZhdGUgc3RhdGljIHJlYWRvbmx5IFNFU1NJT05fS0VZID0gJ2FkbWluX3Nlc3Npb24nO1xuICBwcml2YXRlIHN0YXRpYyByZWFkb25seSBTRVNTSU9OX1RJTUVPVVQgPSAzMCAqIDYwICogMTAwMDsgLy8gMzAgbWludXRlc1xuICBwcml2YXRlIHN0YXRpYyByZWFkb25seSBNQVhfRkFJTEVEX0FUVEVNUFRTID0gNTtcbiAgcHJpdmF0ZSBzdGF0aWMgcmVhZG9ubHkgTE9DS09VVF9EVVJBVElPTiA9IDE1ICogNjAgKiAxMDAwOyAvLyAxNSBtaW51dGVzXG5cbiAgc3RhdGljIGdldFBhc3N3b3JkSGFzaCgpOiBzdHJpbmcge1xuICAgIC8vIEluIHByb2R1Y3Rpb24sIHRoaXMgc2hvdWxkIGNvbWUgZnJvbSBlbnZpcm9ubWVudCB2YXJpYWJsZXNcbiAgICByZXR1cm4gcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfQURNSU5fUEFTU1dPUkRfSEFTSCB8fCBERUZBVUxUX1BBU1NXT1JEX0hBU0g7XG4gIH1cblxuICBzdGF0aWMgdmVyaWZ5UGFzc3dvcmQocGFzc3dvcmQ6IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgIGNvbnN0IGlucHV0SGFzaCA9IHNpbXBsZUhhc2gocGFzc3dvcmQpO1xuICAgIGNvbnN0IGV4cGVjdGVkSGFzaCA9IHRoaXMuZ2V0UGFzc3dvcmRIYXNoKCk7XG4gICAgcmV0dXJuIGlucHV0SGFzaCA9PT0gZXhwZWN0ZWRIYXNoO1xuICB9XG5cbiAgc3RhdGljIGdldFNlc3Npb24oKTogQWRtaW5TZXNzaW9uIHwgbnVsbCB7XG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSByZXR1cm4gbnVsbDtcbiAgICBcbiAgICB0cnkge1xuICAgICAgY29uc3Qgc2Vzc2lvbkRhdGEgPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbSh0aGlzLlNFU1NJT05fS0VZKTtcbiAgICAgIGlmICghc2Vzc2lvbkRhdGEpIHJldHVybiBudWxsO1xuICAgICAgXG4gICAgICBjb25zdCBzZXNzaW9uOiBBZG1pblNlc3Npb24gPSBKU09OLnBhcnNlKHNlc3Npb25EYXRhKTtcbiAgICAgIFxuICAgICAgLy8gQ2hlY2sgaWYgc2Vzc2lvbiBpcyBleHBpcmVkXG4gICAgICBjb25zdCBub3cgPSBEYXRlLm5vdygpO1xuICAgICAgaWYgKG5vdyAtIHNlc3Npb24ubGFzdEFjdGl2aXR5ID4gdGhpcy5TRVNTSU9OX1RJTUVPVVQpIHtcbiAgICAgICAgdGhpcy5jbGVhclNlc3Npb24oKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIENoZWNrIGlmIGFjY291bnQgaXMgbG9ja2VkIG91dFxuICAgICAgaWYgKHNlc3Npb24ubG9ja291dFVudGlsICYmIG5vdyA8IHNlc3Npb24ubG9ja291dFVudGlsKSB7XG4gICAgICAgIHJldHVybiBzZXNzaW9uO1xuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBVcGRhdGUgbGFzdCBhY3Rpdml0eVxuICAgICAgc2Vzc2lvbi5sYXN0QWN0aXZpdHkgPSBub3c7XG4gICAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbSh0aGlzLlNFU1NJT05fS0VZLCBKU09OLnN0cmluZ2lmeShzZXNzaW9uKSk7XG4gICAgICBcbiAgICAgIHJldHVybiBzZXNzaW9uO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciByZWFkaW5nIGFkbWluIHNlc3Npb246JywgZXJyb3IpO1xuICAgICAgdGhpcy5jbGVhclNlc3Npb24oKTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfVxuXG4gIHN0YXRpYyBsb2dpbihwYXNzd29yZDogc3RyaW5nKTogeyBzdWNjZXNzOiBib29sZWFuOyBtZXNzYWdlOiBzdHJpbmc7IGxvY2tvdXRVbnRpbD86IG51bWJlciB9IHtcbiAgICBjb25zdCBzdGFydFRpbWUgPSBwZXJmb3JtYW5jZS5ub3coKVxuXG4gICAgY29uc3Qgc2Vzc2lvbiA9IHRoaXMuZ2V0U2Vzc2lvbigpIHx8IHtcbiAgICAgIGlzQXV0aGVudGljYXRlZDogZmFsc2UsXG4gICAgICBsb2dpblRpbWU6IDAsXG4gICAgICBsYXN0QWN0aXZpdHk6IDAsXG4gICAgICBzZXNzaW9uSWQ6ICcnLFxuICAgICAgZmFpbGVkQXR0ZW1wdHM6IDBcbiAgICB9O1xuXG4gICAgY29uc3Qgbm93ID0gRGF0ZS5ub3coKTtcblxuICAgIC8vIENoZWNrIGlmIGFjY291bnQgaXMgbG9ja2VkIG91dFxuICAgIGlmIChzZXNzaW9uLmxvY2tvdXRVbnRpbCAmJiBub3cgPCBzZXNzaW9uLmxvY2tvdXRVbnRpbCkge1xuICAgICAgY29uc3QgcmVtYWluaW5nVGltZSA9IE1hdGguY2VpbCgoc2Vzc2lvbi5sb2Nrb3V0VW50aWwgLSBub3cpIC8gNjAwMDApO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICAgIG1lc3NhZ2U6IGBBY2NvdW50IGxvY2tlZC4gVHJ5IGFnYWluIGluICR7cmVtYWluaW5nVGltZX0gbWludXRlcy5gLFxuICAgICAgICBsb2Nrb3V0VW50aWw6IHNlc3Npb24ubG9ja291dFVudGlsXG4gICAgICB9O1xuICAgIH1cblxuICAgIC8vIFZlcmlmeSBwYXNzd29yZCAob3B0aW1pemVkKVxuICAgIGNvbnN0IHBhc3N3b3JkVmVyaWZ5U3RhcnQgPSBwZXJmb3JtYW5jZS5ub3coKVxuICAgIGNvbnN0IGlzVmFsaWRQYXNzd29yZCA9IHRoaXMudmVyaWZ5UGFzc3dvcmQocGFzc3dvcmQpXG4gICAgY29uc3QgcGFzc3dvcmRWZXJpZnlFbmQgPSBwZXJmb3JtYW5jZS5ub3coKVxuICAgIGNvbnNvbGUubG9nKGDwn5SQIFBhc3N3b3JkIHZlcmlmaWNhdGlvbiB0b29rOiAke3Bhc3N3b3JkVmVyaWZ5RW5kIC0gcGFzc3dvcmRWZXJpZnlTdGFydH1tc2ApXG5cbiAgICBpZiAoaXNWYWxpZFBhc3N3b3JkKSB7XG4gICAgICBjb25zdCBzZXNzaW9uQ3JlYXRlU3RhcnQgPSBwZXJmb3JtYW5jZS5ub3coKVxuXG4gICAgICBjb25zdCBuZXdTZXNzaW9uOiBBZG1pblNlc3Npb24gPSB7XG4gICAgICAgIGlzQXV0aGVudGljYXRlZDogdHJ1ZSxcbiAgICAgICAgbG9naW5UaW1lOiBub3csXG4gICAgICAgIGxhc3RBY3Rpdml0eTogbm93LFxuICAgICAgICBzZXNzaW9uSWQ6IE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnN1YnN0cmluZygyLCAxNSksXG4gICAgICAgIGZhaWxlZEF0dGVtcHRzOiAwXG4gICAgICB9O1xuXG4gICAgICAvLyBPcHRpbWl6ZWQ6IFVzZSBhIHNpbmdsZSBsb2NhbFN0b3JhZ2Ugb3BlcmF0aW9uXG4gICAgICBjb25zdCBzZXNzaW9uRGF0YSA9IEpTT04uc3RyaW5naWZ5KG5ld1Nlc3Npb24pXG4gICAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbSh0aGlzLlNFU1NJT05fS0VZLCBzZXNzaW9uRGF0YSk7XG5cbiAgICAgIGNvbnN0IHNlc3Npb25DcmVhdGVFbmQgPSBwZXJmb3JtYW5jZS5ub3coKVxuICAgICAgY29uc29sZS5sb2coYPCflJAgU2Vzc2lvbiBjcmVhdGlvbiB0b29rOiAke3Nlc3Npb25DcmVhdGVFbmQgLSBzZXNzaW9uQ3JlYXRlU3RhcnR9bXNgKVxuXG4gICAgICAvLyBMb2cgYWN0aXZpdHkgYXN5bmNocm9ub3VzbHkgdG8gYXZvaWQgYmxvY2tpbmdcbiAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICB0aGlzLmxvZ0FjdGl2aXR5KCdsb2dpbl9zdWNjZXNzJywgJ1VzZXIgbG9nZ2VkIGluIHN1Y2Nlc3NmdWxseScpO1xuICAgICAgfSwgMClcblxuICAgICAgY29uc3QgdG90YWxUaW1lID0gcGVyZm9ybWFuY2Uubm93KCkgLSBzdGFydFRpbWVcbiAgICAgIGNvbnNvbGUubG9nKGDwn5SQIEFkbWluQXV0aC5sb2dpbiB0b29rOiAke3RvdGFsVGltZX1tc2ApXG5cbiAgICAgIHJldHVybiB7IHN1Y2Nlc3M6IHRydWUsIG1lc3NhZ2U6ICdMb2dpbiBzdWNjZXNzZnVsJyB9O1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBJbmNyZW1lbnQgZmFpbGVkIGF0dGVtcHRzXG4gICAgICBzZXNzaW9uLmZhaWxlZEF0dGVtcHRzID0gKHNlc3Npb24uZmFpbGVkQXR0ZW1wdHMgfHwgMCkgKyAxO1xuICAgICAgXG4gICAgICBpZiAoc2Vzc2lvbi5mYWlsZWRBdHRlbXB0cyA+PSB0aGlzLk1BWF9GQUlMRURfQVRURU1QVFMpIHtcbiAgICAgICAgc2Vzc2lvbi5sb2Nrb3V0VW50aWwgPSBub3cgKyB0aGlzLkxPQ0tPVVRfRFVSQVRJT047XG4gICAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKHRoaXMuU0VTU0lPTl9LRVksIEpTT04uc3RyaW5naWZ5KHNlc3Npb24pKTtcbiAgICAgICAgdGhpcy5sb2dBY3Rpdml0eSgnYWNjb3VudF9sb2NrZWQnLCBgQWNjb3VudCBsb2NrZWQgYWZ0ZXIgJHt0aGlzLk1BWF9GQUlMRURfQVRURU1QVFN9IGZhaWxlZCBhdHRlbXB0c2ApO1xuICAgICAgICBcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgICBtZXNzYWdlOiBgVG9vIG1hbnkgZmFpbGVkIGF0dGVtcHRzLiBBY2NvdW50IGxvY2tlZCBmb3IgMTUgbWludXRlcy5gLFxuICAgICAgICAgIGxvY2tvdXRVbnRpbDogc2Vzc2lvbi5sb2Nrb3V0VW50aWxcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKHRoaXMuU0VTU0lPTl9LRVksIEpTT04uc3RyaW5naWZ5KHNlc3Npb24pKTtcbiAgICAgICAgY29uc3QgcmVtYWluaW5nQXR0ZW1wdHMgPSB0aGlzLk1BWF9GQUlMRURfQVRURU1QVFMgLSBzZXNzaW9uLmZhaWxlZEF0dGVtcHRzO1xuICAgICAgICB0aGlzLmxvZ0FjdGl2aXR5KCdsb2dpbl9mYWlsZWQnLCBgRmFpbGVkIGxvZ2luIGF0dGVtcHQuICR7cmVtYWluaW5nQXR0ZW1wdHN9IGF0dGVtcHRzIHJlbWFpbmluZ2ApO1xuICAgICAgICBcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgICBtZXNzYWdlOiBgSW52YWxpZCBwYXNzd29yZC4gJHtyZW1haW5pbmdBdHRlbXB0c30gYXR0ZW1wdHMgcmVtYWluaW5nLmBcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBzdGF0aWMgbG9nb3V0KCk6IHZvaWQge1xuICAgIHRoaXMubG9nQWN0aXZpdHkoJ2xvZ291dCcsICdVc2VyIGxvZ2dlZCBvdXQnKTtcbiAgICB0aGlzLmNsZWFyU2Vzc2lvbigpO1xuICB9XG5cbiAgc3RhdGljIGNsZWFyU2Vzc2lvbigpOiB2b2lkIHtcbiAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKHRoaXMuU0VTU0lPTl9LRVkpO1xuICAgIH1cbiAgfVxuXG4gIHN0YXRpYyBpc0F1dGhlbnRpY2F0ZWQoKTogYm9vbGVhbiB7XG4gICAgY29uc3Qgc2Vzc2lvbiA9IHRoaXMuZ2V0U2Vzc2lvbigpO1xuICAgIHJldHVybiBzZXNzaW9uPy5pc0F1dGhlbnRpY2F0ZWQgPT09IHRydWU7XG4gIH1cblxuICBzdGF0aWMgdXBkYXRlQWN0aXZpdHkoKTogdm9pZCB7XG4gICAgY29uc3Qgc2Vzc2lvbiA9IHRoaXMuZ2V0U2Vzc2lvbigpO1xuICAgIGlmIChzZXNzaW9uICYmIHNlc3Npb24uaXNBdXRoZW50aWNhdGVkKSB7XG4gICAgICBzZXNzaW9uLmxhc3RBY3Rpdml0eSA9IERhdGUubm93KCk7XG4gICAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbSh0aGlzLlNFU1NJT05fS0VZLCBKU09OLnN0cmluZ2lmeShzZXNzaW9uKSk7XG4gICAgfVxuICB9XG5cbiAgc3RhdGljIGxvZ0FjdGl2aXR5KGFjdGlvbjogc3RyaW5nLCBkZXRhaWxzOiBzdHJpbmcpOiB2b2lkIHtcbiAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpIHJldHVybjtcblxuICAgIHRyeSB7XG4gICAgICBjb25zdCBsb2dzID0gSlNPTi5wYXJzZShsb2NhbFN0b3JhZ2UuZ2V0SXRlbSgnYWRtaW5fYWN0aXZpdHlfbG9ncycpIHx8ICdbXScpO1xuICAgICAgY29uc3QgbG9nRW50cnkgPSB7XG4gICAgICAgIHRpbWVzdGFtcDogRGF0ZS5ub3coKSxcbiAgICAgICAgYWN0aW9uLFxuICAgICAgICBkZXRhaWxzLFxuICAgICAgICBzZXNzaW9uSWQ6IHRoaXMuZ2V0U2Vzc2lvbigpPy5zZXNzaW9uSWQgfHwgJ3Vua25vd24nXG4gICAgICB9O1xuXG4gICAgICBsb2dzLnB1c2gobG9nRW50cnkpO1xuXG4gICAgICAvLyBLZWVwIG9ubHkgbGFzdCAxMDAwIGVudHJpZXNcbiAgICAgIGlmIChsb2dzLmxlbmd0aCA+IDEwMDApIHtcbiAgICAgICAgbG9ncy5zcGxpY2UoMCwgbG9ncy5sZW5ndGggLSAxMDAwKTtcbiAgICAgIH1cblxuICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oJ2FkbWluX2FjdGl2aXR5X2xvZ3MnLCBKU09OLnN0cmluZ2lmeShsb2dzKSk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGxvZ2dpbmcgYWRtaW4gYWN0aXZpdHk6JywgZXJyb3IpO1xuICAgIH1cbiAgfVxuXG4gIHN0YXRpYyBnZXRBY3Rpdml0eUxvZ3MoKTogQXJyYXk8e1xuICAgIHRpbWVzdGFtcDogbnVtYmVyO1xuICAgIGFjdGlvbjogc3RyaW5nO1xuICAgIGRldGFpbHM6IHN0cmluZztcbiAgICBzZXNzaW9uSWQ6IHN0cmluZztcbiAgfT4ge1xuICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykgcmV0dXJuIFtdO1xuXG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBKU09OLnBhcnNlKGxvY2FsU3RvcmFnZS5nZXRJdGVtKCdhZG1pbl9hY3Rpdml0eV9sb2dzJykgfHwgJ1tdJyk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIHJlYWRpbmcgYWN0aXZpdHkgbG9nczonLCBlcnJvcik7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuICB9XG59XG4iXSwibmFtZXMiOlsic2ltcGxlSGFzaCIsInN0ciIsImhhc2giLCJpIiwibGVuZ3RoIiwiY2hhciIsImNoYXJDb2RlQXQiLCJNYXRoIiwiYWJzIiwidG9TdHJpbmciLCJERUZBVUxUX1BBU1NXT1JEIiwiREVGQVVMVF9QQVNTV09SRF9IQVNIIiwiQWRtaW5BdXRoIiwiZ2V0UGFzc3dvcmRIYXNoIiwicHJvY2VzcyIsImVudiIsIk5FWFRfUFVCTElDX0FETUlOX1BBU1NXT1JEX0hBU0giLCJ2ZXJpZnlQYXNzd29yZCIsInBhc3N3b3JkIiwiaW5wdXRIYXNoIiwiZXhwZWN0ZWRIYXNoIiwiZ2V0U2Vzc2lvbiIsInNlc3Npb25EYXRhIiwibG9jYWxTdG9yYWdlIiwiZ2V0SXRlbSIsIlNFU1NJT05fS0VZIiwic2Vzc2lvbiIsIkpTT04iLCJwYXJzZSIsIm5vdyIsIkRhdGUiLCJsYXN0QWN0aXZpdHkiLCJTRVNTSU9OX1RJTUVPVVQiLCJjbGVhclNlc3Npb24iLCJsb2Nrb3V0VW50aWwiLCJzZXRJdGVtIiwic3RyaW5naWZ5IiwiZXJyb3IiLCJjb25zb2xlIiwibG9naW4iLCJzdGFydFRpbWUiLCJwZXJmb3JtYW5jZSIsImlzQXV0aGVudGljYXRlZCIsImxvZ2luVGltZSIsInNlc3Npb25JZCIsImZhaWxlZEF0dGVtcHRzIiwicmVtYWluaW5nVGltZSIsImNlaWwiLCJzdWNjZXNzIiwibWVzc2FnZSIsInBhc3N3b3JkVmVyaWZ5U3RhcnQiLCJpc1ZhbGlkUGFzc3dvcmQiLCJwYXNzd29yZFZlcmlmeUVuZCIsImxvZyIsInNlc3Npb25DcmVhdGVTdGFydCIsIm5ld1Nlc3Npb24iLCJyYW5kb20iLCJzdWJzdHJpbmciLCJzZXNzaW9uQ3JlYXRlRW5kIiwic2V0VGltZW91dCIsImxvZ0FjdGl2aXR5IiwidG90YWxUaW1lIiwiTUFYX0ZBSUxFRF9BVFRFTVBUUyIsIkxPQ0tPVVRfRFVSQVRJT04iLCJyZW1haW5pbmdBdHRlbXB0cyIsImxvZ291dCIsInJlbW92ZUl0ZW0iLCJ1cGRhdGVBY3Rpdml0eSIsImFjdGlvbiIsImRldGFpbHMiLCJsb2dzIiwibG9nRW50cnkiLCJ0aW1lc3RhbXAiLCJwdXNoIiwic3BsaWNlIiwiZ2V0QWN0aXZpdHlMb2dzIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/utils/adminAuth.ts\n"));

/***/ })

});