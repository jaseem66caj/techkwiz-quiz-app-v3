"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/jaseemadmin/page",{

/***/ "(app-pages-browser)/./src/utils/realTimeSync.ts":
/*!***********************************!*\
  !*** ./src/utils/realTimeSync.ts ***!
  \***********************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   realTimeSyncService: () => (/* binding */ realTimeSyncService)\n/* harmony export */ });\n/* harmony import */ var _quizDataManager__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./quizDataManager */ \"(app-pages-browser)/./src/utils/quizDataManager.ts\");\n/* harmony import */ var _rewardDataManager__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./rewardDataManager */ \"(app-pages-browser)/./src/utils/rewardDataManager.ts\");\n/* harmony import */ var _analyticsDataManager__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./analyticsDataManager */ \"(app-pages-browser)/./src/utils/analyticsDataManager.ts\");\n// Real-time data synchronization between admin dashboard and quiz game\n\n\n\nclass RealTimeSyncService {\n    static getInstance() {\n        if (!RealTimeSyncService.instance) {\n            RealTimeSyncService.instance = new RealTimeSyncService();\n        }\n        return RealTimeSyncService.instance;\n    }\n    // Start the sync loop\n    startSyncLoop() {\n        if (false) {}\n        this.syncInterval = setInterval(()=>{\n            this.processSyncQueue();\n        }, 1000); // Process every second\n    }\n    // Setup localStorage change listener for cross-tab sync\n    setupStorageListener() {\n        if (false) {}\n        window.addEventListener('storage', (e)=>{\n            var _e_key;\n            if (((_e_key = e.key) === null || _e_key === void 0 ? void 0 : _e_key.startsWith('admin_')) && e.newValue !== e.oldValue) {\n                this.handleStorageChange(e.key, e.newValue);\n            }\n        });\n    }\n    // Handle localStorage changes from other tabs\n    handleStorageChange(key, newValue) {\n        if (!newValue) return;\n        try {\n            const data = JSON.parse(newValue);\n            let eventType;\n            if (key.includes('quiz')) {\n                eventType = 'quiz_updated';\n            } else if (key.includes('reward')) {\n                eventType = 'reward_updated';\n            } else if (key.includes('analytics')) {\n                eventType = 'analytics_updated';\n            } else if (key.includes('settings')) {\n                eventType = 'settings_updated';\n            } else {\n                return;\n            }\n            const syncEvent = {\n                type: eventType,\n                data,\n                timestamp: Date.now(),\n                source: 'admin'\n            };\n            this.notifyListeners(eventType, syncEvent);\n        } catch (error) {\n            console.error('Failed to parse storage change:', error);\n        }\n    }\n    // Add event listener\n    addEventListener(eventType, callback) {\n        if (!this.eventListeners.has(eventType)) {\n            this.eventListeners.set(eventType, []);\n        }\n        this.eventListeners.get(eventType).push(callback);\n    }\n    // Remove event listener\n    removeEventListener(eventType, callback) {\n        const listeners = this.eventListeners.get(eventType);\n        if (listeners) {\n            const index = listeners.indexOf(callback);\n            if (index > -1) {\n                listeners.splice(index, 1);\n            }\n        }\n    }\n    // Notify listeners of events\n    notifyListeners(eventType, event) {\n        const listeners = this.eventListeners.get(eventType) || [];\n        listeners.forEach((callback)=>{\n            try {\n                callback(event);\n            } catch (error) {\n                console.error('Error in sync event listener:', error);\n            }\n        });\n    }\n    // Queue sync event\n    queueSync(event) {\n        const syncEvent = {\n            ...event,\n            timestamp: Date.now()\n        };\n        this.syncQueue.push(syncEvent);\n    }\n    // Process sync queue\n    async processSyncQueue() {\n        if (this.isProcessing || this.syncQueue.length === 0) {\n            return;\n        }\n        this.isProcessing = true;\n        try {\n            const events = [\n                ...this.syncQueue\n            ];\n            this.syncQueue = [];\n            for (const event of events){\n                await this.processEvent(event);\n            }\n            this.lastSyncTime = Date.now();\n        } catch (error) {\n            console.error('Error processing sync queue:', error);\n        } finally{\n            this.isProcessing = false;\n        }\n    }\n    // Process individual sync event\n    async processEvent(event) {\n        try {\n            switch(event.type){\n                case 'quiz_updated':\n                    await this.syncQuizData(event);\n                    break;\n                case 'reward_updated':\n                    await this.syncRewardData(event);\n                    break;\n                case 'analytics_updated':\n                    await this.syncAnalyticsData(event);\n                    break;\n                case 'settings_updated':\n                    await this.syncSettingsData(event);\n                    break;\n            }\n            this.notifyListeners(event.type, event);\n        } catch (error) {\n            console.error(\"Error processing \".concat(event.type, \" event:\"), error);\n        }\n    }\n    // Sync quiz data\n    async syncQuizData(event) {\n        if (event.source === 'admin') {\n            // Admin updated quiz data, sync to game\n            const gameQuizData = localStorage.getItem('game_quiz_data');\n            const adminQuizData = JSON.stringify(event.data);\n            if (gameQuizData !== adminQuizData) {\n                localStorage.setItem('game_quiz_data', adminQuizData);\n                localStorage.setItem('game_last_sync', Date.now().toString());\n            }\n        }\n    }\n    // Sync reward data\n    async syncRewardData(event) {\n        if (event.source === 'admin') {\n            // Admin updated reward data, sync to game\n            const gameRewardData = localStorage.getItem('game_reward_data');\n            const adminRewardData = JSON.stringify(event.data);\n            if (gameRewardData !== adminRewardData) {\n                localStorage.setItem('game_reward_data', adminRewardData);\n                localStorage.setItem('game_last_sync', Date.now().toString());\n            }\n        }\n    }\n    // Sync analytics data\n    async syncAnalyticsData(event) {\n        // Analytics data flows from game to admin\n        if (event.source === 'game') {\n            _analyticsDataManager__WEBPACK_IMPORTED_MODULE_2__.analyticsDataManager.importGameData(event.data);\n        }\n    }\n    // Sync settings data\n    async syncSettingsData(event) {\n        if (event.source === 'admin') {\n            // Admin updated settings, sync to game\n            const gameSettingsData = localStorage.getItem('game_settings_data');\n            const adminSettingsData = JSON.stringify(event.data);\n            if (gameSettingsData !== adminSettingsData) {\n                localStorage.setItem('game_settings_data', adminSettingsData);\n                localStorage.setItem('game_last_sync', Date.now().toString());\n            }\n        }\n    }\n    // Manual sync trigger\n    async triggerSync() {\n        try {\n            // Sync all data from admin to game\n            const quizData = _quizDataManager__WEBPACK_IMPORTED_MODULE_0__.quizDataManager.getQuestions();\n            const rewardData = _rewardDataManager__WEBPACK_IMPORTED_MODULE_1__.rewardDataManager.getAllAchievements();\n            this.queueSync({\n                type: 'quiz_updated',\n                data: quizData,\n                source: 'admin'\n            });\n            this.queueSync({\n                type: 'reward_updated',\n                data: rewardData,\n                source: 'admin'\n            });\n            await this.processSyncQueue();\n            return {\n                success: true,\n                message: 'Data synchronized successfully'\n            };\n        } catch (error) {\n            return {\n                success: false,\n                message: error instanceof Error ? error.message : 'Sync failed'\n            };\n        }\n    }\n    // Get sync status\n    getSyncStatus() {\n        const gameLastSync = parseInt(localStorage.getItem('game_last_sync') || '0');\n        return {\n            lastSyncTime: this.lastSyncTime,\n            queueLength: this.syncQueue.length,\n            isProcessing: this.isProcessing,\n            gameLastSync\n        };\n    }\n    // Check if game data is in sync\n    isGameInSync() {\n        const gameLastSync = parseInt(localStorage.getItem('game_last_sync') || '0');\n        const adminLastUpdate = Math.max(parseInt(localStorage.getItem('admin_quiz_questions_updated') || '0'), parseInt(localStorage.getItem('admin_reward_config_updated') || '0'));\n        return gameLastSync >= adminLastUpdate;\n    }\n    // Force sync all data\n    async forceSyncAll() {\n        const quizData = _quizDataManager__WEBPACK_IMPORTED_MODULE_0__.quizDataManager.getQuestions();\n        const rewardData = _rewardDataManager__WEBPACK_IMPORTED_MODULE_1__.rewardDataManager.getAllAchievements();\n        // Update game data directly\n        localStorage.setItem('game_quiz_data', JSON.stringify(quizData));\n        localStorage.setItem('game_reward_data', JSON.stringify(rewardData));\n        localStorage.setItem('game_last_sync', Date.now().toString());\n        // Notify listeners\n        this.notifyListeners('quiz_updated', {\n            type: 'quiz_updated',\n            data: quizData,\n            timestamp: Date.now(),\n            source: 'admin'\n        });\n        this.notifyListeners('reward_updated', {\n            type: 'reward_updated',\n            data: rewardData,\n            timestamp: Date.now(),\n            source: 'admin'\n        });\n    }\n    // Cleanup\n    destroy() {\n        if (this.syncInterval) {\n            clearInterval(this.syncInterval);\n            this.syncInterval = null;\n        }\n        this.eventListeners.clear();\n        this.syncQueue = [];\n    }\n    constructor(){\n        this.eventListeners = new Map();\n        this.syncQueue = [];\n        this.isProcessing = false;\n        this.lastSyncTime = 0;\n        this.syncInterval = null;\n        // Only initialize on client side\n        if (true) {\n            this.startSyncLoop();\n            this.setupStorageListener();\n        }\n    }\n}\nconst realTimeSyncService = RealTimeSyncService.getInstance();\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy91dGlscy9yZWFsVGltZVN5bmMudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFBLHVFQUF1RTtBQUVwQjtBQUNJO0FBQ007QUFTN0QsTUFBTUc7SUFRSixPQUFPQyxjQUFtQztRQUN4QyxJQUFJLENBQUNELG9CQUFvQkUsUUFBUSxFQUFFO1lBQ2pDRixvQkFBb0JFLFFBQVEsR0FBRyxJQUFJRjtRQUNyQztRQUNBLE9BQU9BLG9CQUFvQkUsUUFBUTtJQUNyQztJQVVBLHNCQUFzQjtJQUNkQyxnQkFBc0I7UUFDNUIsSUFBSSxLQUE2QixFQUFFO1FBRW5DLElBQUksQ0FBQ0MsWUFBWSxHQUFHQyxZQUFZO1lBQzlCLElBQUksQ0FBQ0MsZ0JBQWdCO1FBQ3ZCLEdBQUcsT0FBTSx1QkFBdUI7SUFDbEM7SUFFQSx3REFBd0Q7SUFDaERDLHVCQUE2QjtRQUNuQyxJQUFJLEtBQTZCLEVBQUU7UUFFbkNDLE9BQU9DLGdCQUFnQixDQUFDLFdBQVcsQ0FBQ0M7Z0JBQzlCQTtZQUFKLElBQUlBLEVBQUFBLFNBQUFBLEVBQUVDLEdBQUcsY0FBTEQsNkJBQUFBLE9BQU9FLFVBQVUsQ0FBQyxjQUFhRixFQUFFRyxRQUFRLEtBQUtILEVBQUVJLFFBQVEsRUFBRTtnQkFDNUQsSUFBSSxDQUFDQyxtQkFBbUIsQ0FBQ0wsRUFBRUMsR0FBRyxFQUFFRCxFQUFFRyxRQUFRO1lBQzVDO1FBQ0Y7SUFDRjtJQUVBLDhDQUE4QztJQUN0Q0Usb0JBQW9CSixHQUFXLEVBQUVFLFFBQXVCLEVBQVE7UUFDdEUsSUFBSSxDQUFDQSxVQUFVO1FBRWYsSUFBSTtZQUNGLE1BQU1HLE9BQU9DLEtBQUtDLEtBQUssQ0FBQ0w7WUFDeEIsSUFBSU07WUFFSixJQUFJUixJQUFJUyxRQUFRLENBQUMsU0FBUztnQkFDeEJELFlBQVk7WUFDZCxPQUFPLElBQUlSLElBQUlTLFFBQVEsQ0FBQyxXQUFXO2dCQUNqQ0QsWUFBWTtZQUNkLE9BQU8sSUFBSVIsSUFBSVMsUUFBUSxDQUFDLGNBQWM7Z0JBQ3BDRCxZQUFZO1lBQ2QsT0FBTyxJQUFJUixJQUFJUyxRQUFRLENBQUMsYUFBYTtnQkFDbkNELFlBQVk7WUFDZCxPQUFPO2dCQUNMO1lBQ0Y7WUFFQSxNQUFNRSxZQUF1QjtnQkFDM0JDLE1BQU1IO2dCQUNOSDtnQkFDQU8sV0FBV0MsS0FBS0MsR0FBRztnQkFDbkJDLFFBQVE7WUFDVjtZQUVBLElBQUksQ0FBQ0MsZUFBZSxDQUFDUixXQUFXRTtRQUNsQyxFQUFFLE9BQU9PLE9BQU87WUFDZEMsUUFBUUQsS0FBSyxDQUFDLG1DQUFtQ0E7UUFDbkQ7SUFDRjtJQUVBLHFCQUFxQjtJQUNyQm5CLGlCQUFpQlUsU0FBNEIsRUFBRVcsUUFBb0MsRUFBUTtRQUN6RixJQUFJLENBQUMsSUFBSSxDQUFDQyxjQUFjLENBQUNDLEdBQUcsQ0FBQ2IsWUFBWTtZQUN2QyxJQUFJLENBQUNZLGNBQWMsQ0FBQ0UsR0FBRyxDQUFDZCxXQUFXLEVBQUU7UUFDdkM7UUFDQSxJQUFJLENBQUNZLGNBQWMsQ0FBQ0csR0FBRyxDQUFDZixXQUFZZ0IsSUFBSSxDQUFDTDtJQUMzQztJQUVBLHdCQUF3QjtJQUN4Qk0sb0JBQW9CakIsU0FBNEIsRUFBRVcsUUFBb0MsRUFBUTtRQUM1RixNQUFNTyxZQUFZLElBQUksQ0FBQ04sY0FBYyxDQUFDRyxHQUFHLENBQUNmO1FBQzFDLElBQUlrQixXQUFXO1lBQ2IsTUFBTUMsUUFBUUQsVUFBVUUsT0FBTyxDQUFDVDtZQUNoQyxJQUFJUSxRQUFRLENBQUMsR0FBRztnQkFDZEQsVUFBVUcsTUFBTSxDQUFDRixPQUFPO1lBQzFCO1FBQ0Y7SUFDRjtJQUVBLDZCQUE2QjtJQUNyQlgsZ0JBQWdCUixTQUE0QixFQUFFc0IsS0FBZ0IsRUFBUTtRQUM1RSxNQUFNSixZQUFZLElBQUksQ0FBQ04sY0FBYyxDQUFDRyxHQUFHLENBQUNmLGNBQWMsRUFBRTtRQUMxRGtCLFVBQVVLLE9BQU8sQ0FBQ1osQ0FBQUE7WUFDaEIsSUFBSTtnQkFDRkEsU0FBU1c7WUFDWCxFQUFFLE9BQU9iLE9BQU87Z0JBQ2RDLFFBQVFELEtBQUssQ0FBQyxpQ0FBaUNBO1lBQ2pEO1FBQ0Y7SUFDRjtJQUVBLG1CQUFtQjtJQUNuQmUsVUFBVUYsS0FBbUMsRUFBUTtRQUNuRCxNQUFNcEIsWUFBdUI7WUFDM0IsR0FBR29CLEtBQUs7WUFDUmxCLFdBQVdDLEtBQUtDLEdBQUc7UUFDckI7UUFFQSxJQUFJLENBQUNtQixTQUFTLENBQUNULElBQUksQ0FBQ2Q7SUFDdEI7SUFFQSxxQkFBcUI7SUFDckIsTUFBY2YsbUJBQWtDO1FBQzlDLElBQUksSUFBSSxDQUFDdUMsWUFBWSxJQUFJLElBQUksQ0FBQ0QsU0FBUyxDQUFDRSxNQUFNLEtBQUssR0FBRztZQUNwRDtRQUNGO1FBRUEsSUFBSSxDQUFDRCxZQUFZLEdBQUc7UUFFcEIsSUFBSTtZQUNGLE1BQU1FLFNBQVM7bUJBQUksSUFBSSxDQUFDSCxTQUFTO2FBQUM7WUFDbEMsSUFBSSxDQUFDQSxTQUFTLEdBQUcsRUFBRTtZQUVuQixLQUFLLE1BQU1ILFNBQVNNLE9BQVE7Z0JBQzFCLE1BQU0sSUFBSSxDQUFDQyxZQUFZLENBQUNQO1lBQzFCO1lBRUEsSUFBSSxDQUFDUSxZQUFZLEdBQUd6QixLQUFLQyxHQUFHO1FBQzlCLEVBQUUsT0FBT0csT0FBTztZQUNkQyxRQUFRRCxLQUFLLENBQUMsZ0NBQWdDQTtRQUNoRCxTQUFVO1lBQ1IsSUFBSSxDQUFDaUIsWUFBWSxHQUFHO1FBQ3RCO0lBQ0Y7SUFFQSxnQ0FBZ0M7SUFDaEMsTUFBY0csYUFBYVAsS0FBZ0IsRUFBaUI7UUFDMUQsSUFBSTtZQUNGLE9BQVFBLE1BQU1uQixJQUFJO2dCQUNoQixLQUFLO29CQUNILE1BQU0sSUFBSSxDQUFDNEIsWUFBWSxDQUFDVDtvQkFDeEI7Z0JBQ0YsS0FBSztvQkFDSCxNQUFNLElBQUksQ0FBQ1UsY0FBYyxDQUFDVjtvQkFDMUI7Z0JBQ0YsS0FBSztvQkFDSCxNQUFNLElBQUksQ0FBQ1csaUJBQWlCLENBQUNYO29CQUM3QjtnQkFDRixLQUFLO29CQUNILE1BQU0sSUFBSSxDQUFDWSxnQkFBZ0IsQ0FBQ1o7b0JBQzVCO1lBQ0o7WUFFQSxJQUFJLENBQUNkLGVBQWUsQ0FBQ2MsTUFBTW5CLElBQUksRUFBRW1CO1FBQ25DLEVBQUUsT0FBT2IsT0FBTztZQUNkQyxRQUFRRCxLQUFLLENBQUMsb0JBQStCLE9BQVhhLE1BQU1uQixJQUFJLEVBQUMsWUFBVU07UUFDekQ7SUFDRjtJQUVBLGlCQUFpQjtJQUNqQixNQUFjc0IsYUFBYVQsS0FBZ0IsRUFBaUI7UUFDMUQsSUFBSUEsTUFBTWYsTUFBTSxLQUFLLFNBQVM7WUFDNUIsd0NBQXdDO1lBQ3hDLE1BQU00QixlQUFlQyxhQUFhQyxPQUFPLENBQUM7WUFDMUMsTUFBTUMsZ0JBQWdCeEMsS0FBS3lDLFNBQVMsQ0FBQ2pCLE1BQU16QixJQUFJO1lBRS9DLElBQUlzQyxpQkFBaUJHLGVBQWU7Z0JBQ2xDRixhQUFhSSxPQUFPLENBQUMsa0JBQWtCRjtnQkFDdkNGLGFBQWFJLE9BQU8sQ0FBQyxrQkFBa0JuQyxLQUFLQyxHQUFHLEdBQUdtQyxRQUFRO1lBQzVEO1FBQ0Y7SUFDRjtJQUVBLG1CQUFtQjtJQUNuQixNQUFjVCxlQUFlVixLQUFnQixFQUFpQjtRQUM1RCxJQUFJQSxNQUFNZixNQUFNLEtBQUssU0FBUztZQUM1QiwwQ0FBMEM7WUFDMUMsTUFBTW1DLGlCQUFpQk4sYUFBYUMsT0FBTyxDQUFDO1lBQzVDLE1BQU1NLGtCQUFrQjdDLEtBQUt5QyxTQUFTLENBQUNqQixNQUFNekIsSUFBSTtZQUVqRCxJQUFJNkMsbUJBQW1CQyxpQkFBaUI7Z0JBQ3RDUCxhQUFhSSxPQUFPLENBQUMsb0JBQW9CRztnQkFDekNQLGFBQWFJLE9BQU8sQ0FBQyxrQkFBa0JuQyxLQUFLQyxHQUFHLEdBQUdtQyxRQUFRO1lBQzVEO1FBQ0Y7SUFDRjtJQUVBLHNCQUFzQjtJQUN0QixNQUFjUixrQkFBa0JYLEtBQWdCLEVBQWlCO1FBQy9ELDBDQUEwQztRQUMxQyxJQUFJQSxNQUFNZixNQUFNLEtBQUssUUFBUTtZQUMzQjNCLHVFQUFvQkEsQ0FBQ2dFLGNBQWMsQ0FBQ3RCLE1BQU16QixJQUFJO1FBQ2hEO0lBQ0Y7SUFFQSxxQkFBcUI7SUFDckIsTUFBY3FDLGlCQUFpQlosS0FBZ0IsRUFBaUI7UUFDOUQsSUFBSUEsTUFBTWYsTUFBTSxLQUFLLFNBQVM7WUFDNUIsdUNBQXVDO1lBQ3ZDLE1BQU1zQyxtQkFBbUJULGFBQWFDLE9BQU8sQ0FBQztZQUM5QyxNQUFNUyxvQkFBb0JoRCxLQUFLeUMsU0FBUyxDQUFDakIsTUFBTXpCLElBQUk7WUFFbkQsSUFBSWdELHFCQUFxQkMsbUJBQW1CO2dCQUMxQ1YsYUFBYUksT0FBTyxDQUFDLHNCQUFzQk07Z0JBQzNDVixhQUFhSSxPQUFPLENBQUMsa0JBQWtCbkMsS0FBS0MsR0FBRyxHQUFHbUMsUUFBUTtZQUM1RDtRQUNGO0lBQ0Y7SUFFQSxzQkFBc0I7SUFDdEIsTUFBTU0sY0FBOEQ7UUFDbEUsSUFBSTtZQUNGLG1DQUFtQztZQUNuQyxNQUFNQyxXQUFXdEUsNkRBQWVBLENBQUN1RSxZQUFZO1lBQzdDLE1BQU1DLGFBQWF2RSxpRUFBaUJBLENBQUN3RSxrQkFBa0I7WUFFdkQsSUFBSSxDQUFDM0IsU0FBUyxDQUFDO2dCQUNickIsTUFBTTtnQkFDTk4sTUFBTW1EO2dCQUNOekMsUUFBUTtZQUNWO1lBRUEsSUFBSSxDQUFDaUIsU0FBUyxDQUFDO2dCQUNickIsTUFBTTtnQkFDTk4sTUFBTXFEO2dCQUNOM0MsUUFBUTtZQUNWO1lBRUEsTUFBTSxJQUFJLENBQUNwQixnQkFBZ0I7WUFFM0IsT0FBTztnQkFDTGlFLFNBQVM7Z0JBQ1RDLFNBQVM7WUFDWDtRQUNGLEVBQUUsT0FBTzVDLE9BQU87WUFDZCxPQUFPO2dCQUNMMkMsU0FBUztnQkFDVEMsU0FBUzVDLGlCQUFpQjZDLFFBQVE3QyxNQUFNNEMsT0FBTyxHQUFHO1lBQ3BEO1FBQ0Y7SUFDRjtJQUVBLGtCQUFrQjtJQUNsQkUsZ0JBS0U7UUFDQSxNQUFNQyxlQUFlQyxTQUFTckIsYUFBYUMsT0FBTyxDQUFDLHFCQUFxQjtRQUV4RSxPQUFPO1lBQ0xQLGNBQWMsSUFBSSxDQUFDQSxZQUFZO1lBQy9CNEIsYUFBYSxJQUFJLENBQUNqQyxTQUFTLENBQUNFLE1BQU07WUFDbENELGNBQWMsSUFBSSxDQUFDQSxZQUFZO1lBQy9COEI7UUFDRjtJQUNGO0lBRUEsZ0NBQWdDO0lBQ2hDRyxlQUF3QjtRQUN0QixNQUFNSCxlQUFlQyxTQUFTckIsYUFBYUMsT0FBTyxDQUFDLHFCQUFxQjtRQUN4RSxNQUFNdUIsa0JBQWtCQyxLQUFLQyxHQUFHLENBQzlCTCxTQUFTckIsYUFBYUMsT0FBTyxDQUFDLG1DQUFtQyxNQUNqRW9CLFNBQVNyQixhQUFhQyxPQUFPLENBQUMsa0NBQWtDO1FBR2xFLE9BQU9tQixnQkFBZ0JJO0lBQ3pCO0lBRUEsc0JBQXNCO0lBQ3RCLE1BQU1HLGVBQThCO1FBQ2xDLE1BQU1mLFdBQVd0RSw2REFBZUEsQ0FBQ3VFLFlBQVk7UUFDN0MsTUFBTUMsYUFBYXZFLGlFQUFpQkEsQ0FBQ3dFLGtCQUFrQjtRQUV2RCw0QkFBNEI7UUFDNUJmLGFBQWFJLE9BQU8sQ0FBQyxrQkFBa0IxQyxLQUFLeUMsU0FBUyxDQUFDUztRQUN0RFosYUFBYUksT0FBTyxDQUFDLG9CQUFvQjFDLEtBQUt5QyxTQUFTLENBQUNXO1FBQ3hEZCxhQUFhSSxPQUFPLENBQUMsa0JBQWtCbkMsS0FBS0MsR0FBRyxHQUFHbUMsUUFBUTtRQUUxRCxtQkFBbUI7UUFDbkIsSUFBSSxDQUFDakMsZUFBZSxDQUFDLGdCQUFnQjtZQUNuQ0wsTUFBTTtZQUNOTixNQUFNbUQ7WUFDTjVDLFdBQVdDLEtBQUtDLEdBQUc7WUFDbkJDLFFBQVE7UUFDVjtRQUVBLElBQUksQ0FBQ0MsZUFBZSxDQUFDLGtCQUFrQjtZQUNyQ0wsTUFBTTtZQUNOTixNQUFNcUQ7WUFDTjlDLFdBQVdDLEtBQUtDLEdBQUc7WUFDbkJDLFFBQVE7UUFDVjtJQUNGO0lBRUEsVUFBVTtJQUNWeUQsVUFBZ0I7UUFDZCxJQUFJLElBQUksQ0FBQy9FLFlBQVksRUFBRTtZQUNyQmdGLGNBQWMsSUFBSSxDQUFDaEYsWUFBWTtZQUMvQixJQUFJLENBQUNBLFlBQVksR0FBRztRQUN0QjtRQUNBLElBQUksQ0FBQzJCLGNBQWMsQ0FBQ3NELEtBQUs7UUFDekIsSUFBSSxDQUFDekMsU0FBUyxHQUFHLEVBQUU7SUFDckI7SUF2U0EsYUFBYzthQWJOYixpQkFBOEQsSUFBSXVEO2FBQ2xFMUMsWUFBeUIsRUFBRTthQUMzQkMsZUFBZTthQUNmSSxlQUFlO2FBQ2Y3QyxlQUFzQztRQVU1QyxpQ0FBaUM7UUFDakMsSUFBSSxJQUE2QixFQUFFO1lBQ2pDLElBQUksQ0FBQ0QsYUFBYTtZQUNsQixJQUFJLENBQUNJLG9CQUFvQjtRQUMzQjtJQUNGO0FBa1NGO0FBRU8sTUFBTWdGLHNCQUFzQnZGLG9CQUFvQkMsV0FBVyxHQUFFIiwic291cmNlcyI6WyIvVXNlcnMvamFzZWVtL0RvY3VtZW50cy9HaXRIdWIvVGVjaGt3aXotdjcvZnJvbnRlbmQvc3JjL3V0aWxzL3JlYWxUaW1lU3luYy50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBSZWFsLXRpbWUgZGF0YSBzeW5jaHJvbml6YXRpb24gYmV0d2VlbiBhZG1pbiBkYXNoYm9hcmQgYW5kIHF1aXogZ2FtZVxuaW1wb3J0IHsgUXVpelF1ZXN0aW9uIH0gZnJvbSAnQC90eXBlcy9hZG1pbidcbmltcG9ydCB7IHF1aXpEYXRhTWFuYWdlciB9IGZyb20gJy4vcXVpekRhdGFNYW5hZ2VyJ1xuaW1wb3J0IHsgcmV3YXJkRGF0YU1hbmFnZXIgfSBmcm9tICcuL3Jld2FyZERhdGFNYW5hZ2VyJ1xuaW1wb3J0IHsgYW5hbHl0aWNzRGF0YU1hbmFnZXIgfSBmcm9tICcuL2FuYWx5dGljc0RhdGFNYW5hZ2VyJ1xuXG5pbnRlcmZhY2UgU3luY0V2ZW50IHtcbiAgdHlwZTogJ3F1aXpfdXBkYXRlZCcgfCAncmV3YXJkX3VwZGF0ZWQnIHwgJ2FuYWx5dGljc191cGRhdGVkJyB8ICdzZXR0aW5nc191cGRhdGVkJ1xuICBkYXRhOiBhbnlcbiAgdGltZXN0YW1wOiBudW1iZXJcbiAgc291cmNlOiAnYWRtaW4nIHwgJ2dhbWUnXG59XG5cbmNsYXNzIFJlYWxUaW1lU3luY1NlcnZpY2Uge1xuICBwcml2YXRlIHN0YXRpYyBpbnN0YW5jZTogUmVhbFRpbWVTeW5jU2VydmljZVxuICBwcml2YXRlIGV2ZW50TGlzdGVuZXJzOiBNYXA8c3RyaW5nLCAoKGV2ZW50OiBTeW5jRXZlbnQpID0+IHZvaWQpW10+ID0gbmV3IE1hcCgpXG4gIHByaXZhdGUgc3luY1F1ZXVlOiBTeW5jRXZlbnRbXSA9IFtdXG4gIHByaXZhdGUgaXNQcm9jZXNzaW5nID0gZmFsc2VcbiAgcHJpdmF0ZSBsYXN0U3luY1RpbWUgPSAwXG4gIHByaXZhdGUgc3luY0ludGVydmFsOiBOb2RlSlMuVGltZW91dCB8IG51bGwgPSBudWxsXG5cbiAgc3RhdGljIGdldEluc3RhbmNlKCk6IFJlYWxUaW1lU3luY1NlcnZpY2Uge1xuICAgIGlmICghUmVhbFRpbWVTeW5jU2VydmljZS5pbnN0YW5jZSkge1xuICAgICAgUmVhbFRpbWVTeW5jU2VydmljZS5pbnN0YW5jZSA9IG5ldyBSZWFsVGltZVN5bmNTZXJ2aWNlKClcbiAgICB9XG4gICAgcmV0dXJuIFJlYWxUaW1lU3luY1NlcnZpY2UuaW5zdGFuY2VcbiAgfVxuXG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIC8vIE9ubHkgaW5pdGlhbGl6ZSBvbiBjbGllbnQgc2lkZVxuICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgdGhpcy5zdGFydFN5bmNMb29wKClcbiAgICAgIHRoaXMuc2V0dXBTdG9yYWdlTGlzdGVuZXIoKVxuICAgIH1cbiAgfVxuXG4gIC8vIFN0YXJ0IHRoZSBzeW5jIGxvb3BcbiAgcHJpdmF0ZSBzdGFydFN5bmNMb29wKCk6IHZvaWQge1xuICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykgcmV0dXJuXG5cbiAgICB0aGlzLnN5bmNJbnRlcnZhbCA9IHNldEludGVydmFsKCgpID0+IHtcbiAgICAgIHRoaXMucHJvY2Vzc1N5bmNRdWV1ZSgpXG4gICAgfSwgMTAwMCkgLy8gUHJvY2VzcyBldmVyeSBzZWNvbmRcbiAgfVxuXG4gIC8vIFNldHVwIGxvY2FsU3RvcmFnZSBjaGFuZ2UgbGlzdGVuZXIgZm9yIGNyb3NzLXRhYiBzeW5jXG4gIHByaXZhdGUgc2V0dXBTdG9yYWdlTGlzdGVuZXIoKTogdm9pZCB7XG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSByZXR1cm5cblxuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdzdG9yYWdlJywgKGUpID0+IHtcbiAgICAgIGlmIChlLmtleT8uc3RhcnRzV2l0aCgnYWRtaW5fJykgJiYgZS5uZXdWYWx1ZSAhPT0gZS5vbGRWYWx1ZSkge1xuICAgICAgICB0aGlzLmhhbmRsZVN0b3JhZ2VDaGFuZ2UoZS5rZXksIGUubmV3VmFsdWUpXG4gICAgICB9XG4gICAgfSlcbiAgfVxuXG4gIC8vIEhhbmRsZSBsb2NhbFN0b3JhZ2UgY2hhbmdlcyBmcm9tIG90aGVyIHRhYnNcbiAgcHJpdmF0ZSBoYW5kbGVTdG9yYWdlQ2hhbmdlKGtleTogc3RyaW5nLCBuZXdWYWx1ZTogc3RyaW5nIHwgbnVsbCk6IHZvaWQge1xuICAgIGlmICghbmV3VmFsdWUpIHJldHVyblxuXG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGRhdGEgPSBKU09OLnBhcnNlKG5ld1ZhbHVlKVxuICAgICAgbGV0IGV2ZW50VHlwZTogU3luY0V2ZW50Wyd0eXBlJ11cblxuICAgICAgaWYgKGtleS5pbmNsdWRlcygncXVpeicpKSB7XG4gICAgICAgIGV2ZW50VHlwZSA9ICdxdWl6X3VwZGF0ZWQnXG4gICAgICB9IGVsc2UgaWYgKGtleS5pbmNsdWRlcygncmV3YXJkJykpIHtcbiAgICAgICAgZXZlbnRUeXBlID0gJ3Jld2FyZF91cGRhdGVkJ1xuICAgICAgfSBlbHNlIGlmIChrZXkuaW5jbHVkZXMoJ2FuYWx5dGljcycpKSB7XG4gICAgICAgIGV2ZW50VHlwZSA9ICdhbmFseXRpY3NfdXBkYXRlZCdcbiAgICAgIH0gZWxzZSBpZiAoa2V5LmluY2x1ZGVzKCdzZXR0aW5ncycpKSB7XG4gICAgICAgIGV2ZW50VHlwZSA9ICdzZXR0aW5nc191cGRhdGVkJ1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHN5bmNFdmVudDogU3luY0V2ZW50ID0ge1xuICAgICAgICB0eXBlOiBldmVudFR5cGUsXG4gICAgICAgIGRhdGEsXG4gICAgICAgIHRpbWVzdGFtcDogRGF0ZS5ub3coKSxcbiAgICAgICAgc291cmNlOiAnYWRtaW4nXG4gICAgICB9XG5cbiAgICAgIHRoaXMubm90aWZ5TGlzdGVuZXJzKGV2ZW50VHlwZSwgc3luY0V2ZW50KVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdGYWlsZWQgdG8gcGFyc2Ugc3RvcmFnZSBjaGFuZ2U6JywgZXJyb3IpXG4gICAgfVxuICB9XG5cbiAgLy8gQWRkIGV2ZW50IGxpc3RlbmVyXG4gIGFkZEV2ZW50TGlzdGVuZXIoZXZlbnRUeXBlOiBTeW5jRXZlbnRbJ3R5cGUnXSwgY2FsbGJhY2s6IChldmVudDogU3luY0V2ZW50KSA9PiB2b2lkKTogdm9pZCB7XG4gICAgaWYgKCF0aGlzLmV2ZW50TGlzdGVuZXJzLmhhcyhldmVudFR5cGUpKSB7XG4gICAgICB0aGlzLmV2ZW50TGlzdGVuZXJzLnNldChldmVudFR5cGUsIFtdKVxuICAgIH1cbiAgICB0aGlzLmV2ZW50TGlzdGVuZXJzLmdldChldmVudFR5cGUpIS5wdXNoKGNhbGxiYWNrKVxuICB9XG5cbiAgLy8gUmVtb3ZlIGV2ZW50IGxpc3RlbmVyXG4gIHJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnRUeXBlOiBTeW5jRXZlbnRbJ3R5cGUnXSwgY2FsbGJhY2s6IChldmVudDogU3luY0V2ZW50KSA9PiB2b2lkKTogdm9pZCB7XG4gICAgY29uc3QgbGlzdGVuZXJzID0gdGhpcy5ldmVudExpc3RlbmVycy5nZXQoZXZlbnRUeXBlKVxuICAgIGlmIChsaXN0ZW5lcnMpIHtcbiAgICAgIGNvbnN0IGluZGV4ID0gbGlzdGVuZXJzLmluZGV4T2YoY2FsbGJhY2spXG4gICAgICBpZiAoaW5kZXggPiAtMSkge1xuICAgICAgICBsaXN0ZW5lcnMuc3BsaWNlKGluZGV4LCAxKVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIE5vdGlmeSBsaXN0ZW5lcnMgb2YgZXZlbnRzXG4gIHByaXZhdGUgbm90aWZ5TGlzdGVuZXJzKGV2ZW50VHlwZTogU3luY0V2ZW50Wyd0eXBlJ10sIGV2ZW50OiBTeW5jRXZlbnQpOiB2b2lkIHtcbiAgICBjb25zdCBsaXN0ZW5lcnMgPSB0aGlzLmV2ZW50TGlzdGVuZXJzLmdldChldmVudFR5cGUpIHx8IFtdXG4gICAgbGlzdGVuZXJzLmZvckVhY2goY2FsbGJhY2sgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY2FsbGJhY2soZXZlbnQpXG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBpbiBzeW5jIGV2ZW50IGxpc3RlbmVyOicsIGVycm9yKVxuICAgICAgfVxuICAgIH0pXG4gIH1cblxuICAvLyBRdWV1ZSBzeW5jIGV2ZW50XG4gIHF1ZXVlU3luYyhldmVudDogT21pdDxTeW5jRXZlbnQsICd0aW1lc3RhbXAnPik6IHZvaWQge1xuICAgIGNvbnN0IHN5bmNFdmVudDogU3luY0V2ZW50ID0ge1xuICAgICAgLi4uZXZlbnQsXG4gICAgICB0aW1lc3RhbXA6IERhdGUubm93KClcbiAgICB9XG4gICAgXG4gICAgdGhpcy5zeW5jUXVldWUucHVzaChzeW5jRXZlbnQpXG4gIH1cblxuICAvLyBQcm9jZXNzIHN5bmMgcXVldWVcbiAgcHJpdmF0ZSBhc3luYyBwcm9jZXNzU3luY1F1ZXVlKCk6IFByb21pc2U8dm9pZD4ge1xuICAgIGlmICh0aGlzLmlzUHJvY2Vzc2luZyB8fCB0aGlzLnN5bmNRdWV1ZS5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIHRoaXMuaXNQcm9jZXNzaW5nID0gdHJ1ZVxuXG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGV2ZW50cyA9IFsuLi50aGlzLnN5bmNRdWV1ZV1cbiAgICAgIHRoaXMuc3luY1F1ZXVlID0gW11cblxuICAgICAgZm9yIChjb25zdCBldmVudCBvZiBldmVudHMpIHtcbiAgICAgICAgYXdhaXQgdGhpcy5wcm9jZXNzRXZlbnQoZXZlbnQpXG4gICAgICB9XG5cbiAgICAgIHRoaXMubGFzdFN5bmNUaW1lID0gRGF0ZS5ub3coKVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBwcm9jZXNzaW5nIHN5bmMgcXVldWU6JywgZXJyb3IpXG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHRoaXMuaXNQcm9jZXNzaW5nID0gZmFsc2VcbiAgICB9XG4gIH1cblxuICAvLyBQcm9jZXNzIGluZGl2aWR1YWwgc3luYyBldmVudFxuICBwcml2YXRlIGFzeW5jIHByb2Nlc3NFdmVudChldmVudDogU3luY0V2ZW50KTogUHJvbWlzZTx2b2lkPiB7XG4gICAgdHJ5IHtcbiAgICAgIHN3aXRjaCAoZXZlbnQudHlwZSkge1xuICAgICAgICBjYXNlICdxdWl6X3VwZGF0ZWQnOlxuICAgICAgICAgIGF3YWl0IHRoaXMuc3luY1F1aXpEYXRhKGV2ZW50KVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgJ3Jld2FyZF91cGRhdGVkJzpcbiAgICAgICAgICBhd2FpdCB0aGlzLnN5bmNSZXdhcmREYXRhKGV2ZW50KVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgJ2FuYWx5dGljc191cGRhdGVkJzpcbiAgICAgICAgICBhd2FpdCB0aGlzLnN5bmNBbmFseXRpY3NEYXRhKGV2ZW50KVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgJ3NldHRpbmdzX3VwZGF0ZWQnOlxuICAgICAgICAgIGF3YWl0IHRoaXMuc3luY1NldHRpbmdzRGF0YShldmVudClcbiAgICAgICAgICBicmVha1xuICAgICAgfVxuXG4gICAgICB0aGlzLm5vdGlmeUxpc3RlbmVycyhldmVudC50eXBlLCBldmVudClcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcihgRXJyb3IgcHJvY2Vzc2luZyAke2V2ZW50LnR5cGV9IGV2ZW50OmAsIGVycm9yKVxuICAgIH1cbiAgfVxuXG4gIC8vIFN5bmMgcXVpeiBkYXRhXG4gIHByaXZhdGUgYXN5bmMgc3luY1F1aXpEYXRhKGV2ZW50OiBTeW5jRXZlbnQpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBpZiAoZXZlbnQuc291cmNlID09PSAnYWRtaW4nKSB7XG4gICAgICAvLyBBZG1pbiB1cGRhdGVkIHF1aXogZGF0YSwgc3luYyB0byBnYW1lXG4gICAgICBjb25zdCBnYW1lUXVpekRhdGEgPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbSgnZ2FtZV9xdWl6X2RhdGEnKVxuICAgICAgY29uc3QgYWRtaW5RdWl6RGF0YSA9IEpTT04uc3RyaW5naWZ5KGV2ZW50LmRhdGEpXG4gICAgICBcbiAgICAgIGlmIChnYW1lUXVpekRhdGEgIT09IGFkbWluUXVpekRhdGEpIHtcbiAgICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oJ2dhbWVfcXVpel9kYXRhJywgYWRtaW5RdWl6RGF0YSlcbiAgICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oJ2dhbWVfbGFzdF9zeW5jJywgRGF0ZS5ub3coKS50b1N0cmluZygpKVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIFN5bmMgcmV3YXJkIGRhdGFcbiAgcHJpdmF0ZSBhc3luYyBzeW5jUmV3YXJkRGF0YShldmVudDogU3luY0V2ZW50KTogUHJvbWlzZTx2b2lkPiB7XG4gICAgaWYgKGV2ZW50LnNvdXJjZSA9PT0gJ2FkbWluJykge1xuICAgICAgLy8gQWRtaW4gdXBkYXRlZCByZXdhcmQgZGF0YSwgc3luYyB0byBnYW1lXG4gICAgICBjb25zdCBnYW1lUmV3YXJkRGF0YSA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKCdnYW1lX3Jld2FyZF9kYXRhJylcbiAgICAgIGNvbnN0IGFkbWluUmV3YXJkRGF0YSA9IEpTT04uc3RyaW5naWZ5KGV2ZW50LmRhdGEpXG4gICAgICBcbiAgICAgIGlmIChnYW1lUmV3YXJkRGF0YSAhPT0gYWRtaW5SZXdhcmREYXRhKSB7XG4gICAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKCdnYW1lX3Jld2FyZF9kYXRhJywgYWRtaW5SZXdhcmREYXRhKVxuICAgICAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbSgnZ2FtZV9sYXN0X3N5bmMnLCBEYXRlLm5vdygpLnRvU3RyaW5nKCkpXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gU3luYyBhbmFseXRpY3MgZGF0YVxuICBwcml2YXRlIGFzeW5jIHN5bmNBbmFseXRpY3NEYXRhKGV2ZW50OiBTeW5jRXZlbnQpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICAvLyBBbmFseXRpY3MgZGF0YSBmbG93cyBmcm9tIGdhbWUgdG8gYWRtaW5cbiAgICBpZiAoZXZlbnQuc291cmNlID09PSAnZ2FtZScpIHtcbiAgICAgIGFuYWx5dGljc0RhdGFNYW5hZ2VyLmltcG9ydEdhbWVEYXRhKGV2ZW50LmRhdGEpXG4gICAgfVxuICB9XG5cbiAgLy8gU3luYyBzZXR0aW5ncyBkYXRhXG4gIHByaXZhdGUgYXN5bmMgc3luY1NldHRpbmdzRGF0YShldmVudDogU3luY0V2ZW50KTogUHJvbWlzZTx2b2lkPiB7XG4gICAgaWYgKGV2ZW50LnNvdXJjZSA9PT0gJ2FkbWluJykge1xuICAgICAgLy8gQWRtaW4gdXBkYXRlZCBzZXR0aW5ncywgc3luYyB0byBnYW1lXG4gICAgICBjb25zdCBnYW1lU2V0dGluZ3NEYXRhID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0oJ2dhbWVfc2V0dGluZ3NfZGF0YScpXG4gICAgICBjb25zdCBhZG1pblNldHRpbmdzRGF0YSA9IEpTT04uc3RyaW5naWZ5KGV2ZW50LmRhdGEpXG4gICAgICBcbiAgICAgIGlmIChnYW1lU2V0dGluZ3NEYXRhICE9PSBhZG1pblNldHRpbmdzRGF0YSkge1xuICAgICAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbSgnZ2FtZV9zZXR0aW5nc19kYXRhJywgYWRtaW5TZXR0aW5nc0RhdGEpXG4gICAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKCdnYW1lX2xhc3Rfc3luYycsIERhdGUubm93KCkudG9TdHJpbmcoKSlcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBNYW51YWwgc3luYyB0cmlnZ2VyXG4gIGFzeW5jIHRyaWdnZXJTeW5jKCk6IFByb21pc2U8eyBzdWNjZXNzOiBib29sZWFuOyBtZXNzYWdlOiBzdHJpbmcgfT4ge1xuICAgIHRyeSB7XG4gICAgICAvLyBTeW5jIGFsbCBkYXRhIGZyb20gYWRtaW4gdG8gZ2FtZVxuICAgICAgY29uc3QgcXVpekRhdGEgPSBxdWl6RGF0YU1hbmFnZXIuZ2V0UXVlc3Rpb25zKClcbiAgICAgIGNvbnN0IHJld2FyZERhdGEgPSByZXdhcmREYXRhTWFuYWdlci5nZXRBbGxBY2hpZXZlbWVudHMoKVxuICAgICAgXG4gICAgICB0aGlzLnF1ZXVlU3luYyh7XG4gICAgICAgIHR5cGU6ICdxdWl6X3VwZGF0ZWQnLFxuICAgICAgICBkYXRhOiBxdWl6RGF0YSxcbiAgICAgICAgc291cmNlOiAnYWRtaW4nXG4gICAgICB9KVxuXG4gICAgICB0aGlzLnF1ZXVlU3luYyh7XG4gICAgICAgIHR5cGU6ICdyZXdhcmRfdXBkYXRlZCcsXG4gICAgICAgIGRhdGE6IHJld2FyZERhdGEsXG4gICAgICAgIHNvdXJjZTogJ2FkbWluJ1xuICAgICAgfSlcblxuICAgICAgYXdhaXQgdGhpcy5wcm9jZXNzU3luY1F1ZXVlKClcblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc3VjY2VzczogdHJ1ZSxcbiAgICAgICAgbWVzc2FnZTogJ0RhdGEgc3luY2hyb25pemVkIHN1Y2Nlc3NmdWxseSdcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICAgIG1lc3NhZ2U6IGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogJ1N5bmMgZmFpbGVkJ1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIEdldCBzeW5jIHN0YXR1c1xuICBnZXRTeW5jU3RhdHVzKCk6IHtcbiAgICBsYXN0U3luY1RpbWU6IG51bWJlclxuICAgIHF1ZXVlTGVuZ3RoOiBudW1iZXJcbiAgICBpc1Byb2Nlc3Npbmc6IGJvb2xlYW5cbiAgICBnYW1lTGFzdFN5bmM6IG51bWJlclxuICB9IHtcbiAgICBjb25zdCBnYW1lTGFzdFN5bmMgPSBwYXJzZUludChsb2NhbFN0b3JhZ2UuZ2V0SXRlbSgnZ2FtZV9sYXN0X3N5bmMnKSB8fCAnMCcpXG4gICAgXG4gICAgcmV0dXJuIHtcbiAgICAgIGxhc3RTeW5jVGltZTogdGhpcy5sYXN0U3luY1RpbWUsXG4gICAgICBxdWV1ZUxlbmd0aDogdGhpcy5zeW5jUXVldWUubGVuZ3RoLFxuICAgICAgaXNQcm9jZXNzaW5nOiB0aGlzLmlzUHJvY2Vzc2luZyxcbiAgICAgIGdhbWVMYXN0U3luY1xuICAgIH1cbiAgfVxuXG4gIC8vIENoZWNrIGlmIGdhbWUgZGF0YSBpcyBpbiBzeW5jXG4gIGlzR2FtZUluU3luYygpOiBib29sZWFuIHtcbiAgICBjb25zdCBnYW1lTGFzdFN5bmMgPSBwYXJzZUludChsb2NhbFN0b3JhZ2UuZ2V0SXRlbSgnZ2FtZV9sYXN0X3N5bmMnKSB8fCAnMCcpXG4gICAgY29uc3QgYWRtaW5MYXN0VXBkYXRlID0gTWF0aC5tYXgoXG4gICAgICBwYXJzZUludChsb2NhbFN0b3JhZ2UuZ2V0SXRlbSgnYWRtaW5fcXVpel9xdWVzdGlvbnNfdXBkYXRlZCcpIHx8ICcwJyksXG4gICAgICBwYXJzZUludChsb2NhbFN0b3JhZ2UuZ2V0SXRlbSgnYWRtaW5fcmV3YXJkX2NvbmZpZ191cGRhdGVkJykgfHwgJzAnKVxuICAgIClcbiAgICBcbiAgICByZXR1cm4gZ2FtZUxhc3RTeW5jID49IGFkbWluTGFzdFVwZGF0ZVxuICB9XG5cbiAgLy8gRm9yY2Ugc3luYyBhbGwgZGF0YVxuICBhc3luYyBmb3JjZVN5bmNBbGwoKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgY29uc3QgcXVpekRhdGEgPSBxdWl6RGF0YU1hbmFnZXIuZ2V0UXVlc3Rpb25zKClcbiAgICBjb25zdCByZXdhcmREYXRhID0gcmV3YXJkRGF0YU1hbmFnZXIuZ2V0QWxsQWNoaWV2ZW1lbnRzKClcbiAgICBcbiAgICAvLyBVcGRhdGUgZ2FtZSBkYXRhIGRpcmVjdGx5XG4gICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oJ2dhbWVfcXVpel9kYXRhJywgSlNPTi5zdHJpbmdpZnkocXVpekRhdGEpKVxuICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKCdnYW1lX3Jld2FyZF9kYXRhJywgSlNPTi5zdHJpbmdpZnkocmV3YXJkRGF0YSkpXG4gICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oJ2dhbWVfbGFzdF9zeW5jJywgRGF0ZS5ub3coKS50b1N0cmluZygpKVxuICAgIFxuICAgIC8vIE5vdGlmeSBsaXN0ZW5lcnNcbiAgICB0aGlzLm5vdGlmeUxpc3RlbmVycygncXVpel91cGRhdGVkJywge1xuICAgICAgdHlwZTogJ3F1aXpfdXBkYXRlZCcsXG4gICAgICBkYXRhOiBxdWl6RGF0YSxcbiAgICAgIHRpbWVzdGFtcDogRGF0ZS5ub3coKSxcbiAgICAgIHNvdXJjZTogJ2FkbWluJ1xuICAgIH0pXG5cbiAgICB0aGlzLm5vdGlmeUxpc3RlbmVycygncmV3YXJkX3VwZGF0ZWQnLCB7XG4gICAgICB0eXBlOiAncmV3YXJkX3VwZGF0ZWQnLFxuICAgICAgZGF0YTogcmV3YXJkRGF0YSxcbiAgICAgIHRpbWVzdGFtcDogRGF0ZS5ub3coKSxcbiAgICAgIHNvdXJjZTogJ2FkbWluJ1xuICAgIH0pXG4gIH1cblxuICAvLyBDbGVhbnVwXG4gIGRlc3Ryb3koKTogdm9pZCB7XG4gICAgaWYgKHRoaXMuc3luY0ludGVydmFsKSB7XG4gICAgICBjbGVhckludGVydmFsKHRoaXMuc3luY0ludGVydmFsKVxuICAgICAgdGhpcy5zeW5jSW50ZXJ2YWwgPSBudWxsXG4gICAgfVxuICAgIHRoaXMuZXZlbnRMaXN0ZW5lcnMuY2xlYXIoKVxuICAgIHRoaXMuc3luY1F1ZXVlID0gW11cbiAgfVxufVxuXG5leHBvcnQgY29uc3QgcmVhbFRpbWVTeW5jU2VydmljZSA9IFJlYWxUaW1lU3luY1NlcnZpY2UuZ2V0SW5zdGFuY2UoKVxuIl0sIm5hbWVzIjpbInF1aXpEYXRhTWFuYWdlciIsInJld2FyZERhdGFNYW5hZ2VyIiwiYW5hbHl0aWNzRGF0YU1hbmFnZXIiLCJSZWFsVGltZVN5bmNTZXJ2aWNlIiwiZ2V0SW5zdGFuY2UiLCJpbnN0YW5jZSIsInN0YXJ0U3luY0xvb3AiLCJzeW5jSW50ZXJ2YWwiLCJzZXRJbnRlcnZhbCIsInByb2Nlc3NTeW5jUXVldWUiLCJzZXR1cFN0b3JhZ2VMaXN0ZW5lciIsIndpbmRvdyIsImFkZEV2ZW50TGlzdGVuZXIiLCJlIiwia2V5Iiwic3RhcnRzV2l0aCIsIm5ld1ZhbHVlIiwib2xkVmFsdWUiLCJoYW5kbGVTdG9yYWdlQ2hhbmdlIiwiZGF0YSIsIkpTT04iLCJwYXJzZSIsImV2ZW50VHlwZSIsImluY2x1ZGVzIiwic3luY0V2ZW50IiwidHlwZSIsInRpbWVzdGFtcCIsIkRhdGUiLCJub3ciLCJzb3VyY2UiLCJub3RpZnlMaXN0ZW5lcnMiLCJlcnJvciIsImNvbnNvbGUiLCJjYWxsYmFjayIsImV2ZW50TGlzdGVuZXJzIiwiaGFzIiwic2V0IiwiZ2V0IiwicHVzaCIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJsaXN0ZW5lcnMiLCJpbmRleCIsImluZGV4T2YiLCJzcGxpY2UiLCJldmVudCIsImZvckVhY2giLCJxdWV1ZVN5bmMiLCJzeW5jUXVldWUiLCJpc1Byb2Nlc3NpbmciLCJsZW5ndGgiLCJldmVudHMiLCJwcm9jZXNzRXZlbnQiLCJsYXN0U3luY1RpbWUiLCJzeW5jUXVpekRhdGEiLCJzeW5jUmV3YXJkRGF0YSIsInN5bmNBbmFseXRpY3NEYXRhIiwic3luY1NldHRpbmdzRGF0YSIsImdhbWVRdWl6RGF0YSIsImxvY2FsU3RvcmFnZSIsImdldEl0ZW0iLCJhZG1pblF1aXpEYXRhIiwic3RyaW5naWZ5Iiwic2V0SXRlbSIsInRvU3RyaW5nIiwiZ2FtZVJld2FyZERhdGEiLCJhZG1pblJld2FyZERhdGEiLCJpbXBvcnRHYW1lRGF0YSIsImdhbWVTZXR0aW5nc0RhdGEiLCJhZG1pblNldHRpbmdzRGF0YSIsInRyaWdnZXJTeW5jIiwicXVpekRhdGEiLCJnZXRRdWVzdGlvbnMiLCJyZXdhcmREYXRhIiwiZ2V0QWxsQWNoaWV2ZW1lbnRzIiwic3VjY2VzcyIsIm1lc3NhZ2UiLCJFcnJvciIsImdldFN5bmNTdGF0dXMiLCJnYW1lTGFzdFN5bmMiLCJwYXJzZUludCIsInF1ZXVlTGVuZ3RoIiwiaXNHYW1lSW5TeW5jIiwiYWRtaW5MYXN0VXBkYXRlIiwiTWF0aCIsIm1heCIsImZvcmNlU3luY0FsbCIsImRlc3Ryb3kiLCJjbGVhckludGVydmFsIiwiY2xlYXIiLCJNYXAiLCJyZWFsVGltZVN5bmNTZXJ2aWNlIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/utils/realTimeSync.ts\n"));

/***/ })

});