"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./src/utils/quizDataManager.ts":
/*!**************************************!*\
  !*** ./src/utils/quizDataManager.ts ***!
  \**************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   QuizDataError: () => (/* binding */ QuizDataError),\n/* harmony export */   VALIDATION_RULES: () => (/* binding */ VALIDATION_RULES),\n/* harmony export */   quizDataManager: () => (/* binding */ quizDataManager)\n/* harmony export */ });\n/* harmony import */ var _types_admin__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/types/admin */ \"(app-pages-browser)/./src/types/admin.ts\");\n\n// Data validation schemas\nconst VALIDATION_RULES = {\n    QUESTION_MIN_LENGTH: 10,\n    QUESTION_MAX_LENGTH: 500,\n    OPTION_MIN_LENGTH: 1,\n    OPTION_MAX_LENGTH: 100,\n    MIN_OPTIONS: 4,\n    MAX_OPTIONS: 4,\n    MAX_BULK_OPERATIONS: 50,\n    MAX_FILE_SIZE: 5 * 1024 * 1024,\n    AUTO_SAVE_INTERVAL: 30000 // 30 seconds\n};\n// Error types\nclass QuizDataError extends Error {\n    constructor(message, code){\n        super(message), this.code = code;\n        this.name = 'QuizDataError';\n    }\n}\n// Utility functions for localStorage operations\nclass QuizDataManager {\n    static getInstance() {\n        if (!QuizDataManager.instance) {\n            QuizDataManager.instance = new QuizDataManager();\n        }\n        return QuizDataManager.instance;\n    }\n    // Safe localStorage operations with error handling\n    safeGetItem(key) {\n        // Return null if not on client side\n        if (false) {}\n        try {\n            return localStorage.getItem(key);\n        } catch (error) {\n            console.error(\"Error reading from localStorage key \".concat(key, \":\"), error);\n            return null;\n        }\n    }\n    safeSetItem(key, value) {\n        // Return false if not on client side\n        if (false) {}\n        try {\n            localStorage.setItem(key, value);\n            return true;\n        } catch (error) {\n            console.error(\"Error writing to localStorage key \".concat(key, \":\"), error);\n            if (error instanceof DOMException && error.code === 22) {\n                throw new QuizDataError('Storage quota exceeded. Please clear some data.', 'QUOTA_EXCEEDED');\n            }\n            return false;\n        }\n    }\n    // Question CRUD operations\n    getQuestions() {\n        const data = this.safeGetItem(_types_admin__WEBPACK_IMPORTED_MODULE_0__.QUIZ_STORAGE_KEYS.QUESTIONS);\n        if (!data) return this.initializeWithSampleData();\n        try {\n            const questions = JSON.parse(data);\n            return Array.isArray(questions) ? questions : [];\n        } catch (error) {\n            console.error('Error parsing questions data:', error);\n            return this.initializeWithSampleData();\n        }\n    }\n    // Get questions with filtering support\n    getFilteredQuestions(filters) {\n        const questions = this.getQuestions();\n        if (!filters) return questions;\n        return questions.filter((question)=>{\n            if (filters.category && question.category !== filters.category) return false;\n            if (filters.difficulty && question.difficulty !== filters.difficulty) return false;\n            if (filters.type && question.type !== filters.type) return false;\n            if (filters.section && question.section !== filters.section) return false;\n            if (filters.subcategory && question.subcategory !== filters.subcategory) return false;\n            if (filters.tags && !filters.tags.some((tag)=>{\n                var _question_tags;\n                return (_question_tags = question.tags) === null || _question_tags === void 0 ? void 0 : _question_tags.includes(tag);\n            })) return false;\n            return true;\n        });\n    }\n    // Get questions by section\n    getQuestionsBySection(section) {\n        return this.getFilteredQuestions({\n            section\n        });\n    }\n    // Get questions by category and section\n    getQuestionsByCategoryAndSection(category, section) {\n        return this.getFilteredQuestions({\n            category,\n            section\n        });\n    }\n    saveQuestion(question) {\n        this.validateQuestion(question);\n        const questions = this.getQuestions();\n        const now = Date.now();\n        const newQuestion = {\n            ...question,\n            id: this.generateId(),\n            createdAt: now,\n            updatedAt: now\n        };\n        questions.push(newQuestion);\n        this.saveQuestions(questions);\n        return newQuestion;\n    }\n    updateQuestion(id, updates) {\n        const questions = this.getQuestions();\n        const index = questions.findIndex((q)=>q.id === id);\n        if (index === -1) {\n            throw new QuizDataError(\"Question with id \".concat(id, \" not found\"), 'NOT_FOUND');\n        }\n        const updatedQuestion = {\n            ...questions[index],\n            ...updates,\n            updatedAt: Date.now()\n        };\n        this.validateQuestion(updatedQuestion);\n        questions[index] = updatedQuestion;\n        this.saveQuestions(questions);\n        return updatedQuestion;\n    }\n    deleteQuestion(id) {\n        const questions = this.getQuestions();\n        const filteredQuestions = questions.filter((q)=>q.id !== id);\n        if (filteredQuestions.length === questions.length) {\n            throw new QuizDataError(\"Question with id \".concat(id, \" not found\"), 'NOT_FOUND');\n        }\n        this.saveQuestions(filteredQuestions);\n        return true;\n    }\n    bulkDelete(ids) {\n        if (ids.length > VALIDATION_RULES.MAX_BULK_OPERATIONS) {\n            throw new QuizDataError(\"Cannot delete more than \".concat(VALIDATION_RULES.MAX_BULK_OPERATIONS, \" questions at once\"), 'BULK_LIMIT_EXCEEDED');\n        }\n        const questions = this.getQuestions();\n        const initialCount = questions.length;\n        const filteredQuestions = questions.filter((q)=>!ids.includes(q.id));\n        const deletedCount = initialCount - filteredQuestions.length;\n        this.saveQuestions(filteredQuestions);\n        return {\n            success: true,\n            processedCount: deletedCount,\n            errorCount: ids.length - deletedCount,\n            errors: ids.length > deletedCount ? [\n                'Some questions were not found'\n            ] : []\n        };\n    }\n    // Search and filter operations\n    searchQuestions(filters) {\n        const questions = this.getQuestions();\n        return questions.filter((question)=>{\n            // Text search\n            if (filters.searchText) {\n                const searchLower = filters.searchText.toLowerCase();\n                if (!question.question.toLowerCase().includes(searchLower)) {\n                    return false;\n                }\n            }\n            // Category filter\n            if (filters.category !== 'all' && question.category !== filters.category) {\n                return false;\n            }\n            // Difficulty filter\n            if (filters.difficulty !== 'all' && question.difficulty !== filters.difficulty) {\n                return false;\n            }\n            // Type filter\n            if (filters.type !== 'all' && question.type !== filters.type) {\n                return false;\n            }\n            return true;\n        });\n    }\n    // Categories management\n    getCategories() {\n        const questions = this.getQuestions();\n        const categoryCounts = questions.reduce((acc, question)=>{\n            acc[question.category] = (acc[question.category] || 0) + 1;\n            return acc;\n        }, {});\n        return _types_admin__WEBPACK_IMPORTED_MODULE_0__.DEFAULT_CATEGORIES.map((category)=>({\n                ...category,\n                questionCount: categoryCounts[category.id] || 0\n            }));\n    }\n    // Draft management\n    saveDraft(draft) {\n        const drafts = this.getDrafts();\n        const existingIndex = drafts.findIndex((d)=>d.id === draft.id);\n        if (existingIndex >= 0) {\n            drafts[existingIndex] = {\n                ...draft,\n                lastSaved: Date.now()\n            };\n        } else {\n            drafts.push({\n                ...draft,\n                lastSaved: Date.now()\n            });\n        }\n        this.safeSetItem(_types_admin__WEBPACK_IMPORTED_MODULE_0__.QUIZ_STORAGE_KEYS.DRAFTS, JSON.stringify(drafts));\n    }\n    getDrafts() {\n        const data = this.safeGetItem(_types_admin__WEBPACK_IMPORTED_MODULE_0__.QUIZ_STORAGE_KEYS.DRAFTS);\n        if (!data) return [];\n        try {\n            return JSON.parse(data);\n        } catch (error) {\n            console.error('Error parsing drafts data:', error);\n            return [];\n        }\n    }\n    deleteDraft(id) {\n        const drafts = this.getDrafts().filter((d)=>d.id !== id);\n        this.safeSetItem(_types_admin__WEBPACK_IMPORTED_MODULE_0__.QUIZ_STORAGE_KEYS.DRAFTS, JSON.stringify(drafts));\n    }\n    // Settings management\n    getSettings() {\n        const data = this.safeGetItem(_types_admin__WEBPACK_IMPORTED_MODULE_0__.QUIZ_STORAGE_KEYS.SETTINGS);\n        if (!data) return this.getDefaultSettings();\n        try {\n            return {\n                ...this.getDefaultSettings(),\n                ...JSON.parse(data)\n            };\n        } catch (error) {\n            console.error('Error parsing settings data:', error);\n            return this.getDefaultSettings();\n        }\n    }\n    saveSettings(settings) {\n        const currentSettings = this.getSettings();\n        const updatedSettings = {\n            ...currentSettings,\n            ...settings\n        };\n        this.safeSetItem(_types_admin__WEBPACK_IMPORTED_MODULE_0__.QUIZ_STORAGE_KEYS.SETTINGS, JSON.stringify(updatedSettings));\n    }\n    getDefaultSettings() {\n        return {\n            pageSize: 10,\n            sortBy: 'updatedAt',\n            sortOrder: 'desc',\n            filters: {\n                searchText: '',\n                category: 'all',\n                difficulty: 'all',\n                type: 'all'\n            },\n            selectedQuestions: []\n        };\n    }\n    // Validation\n    validateQuestion(question) {\n        if (!question.question || question.question.length < VALIDATION_RULES.QUESTION_MIN_LENGTH) {\n            throw new QuizDataError(\"Question must be at least \".concat(VALIDATION_RULES.QUESTION_MIN_LENGTH, \" characters long\"), 'INVALID_QUESTION_LENGTH');\n        }\n        if (question.question.length > VALIDATION_RULES.QUESTION_MAX_LENGTH) {\n            throw new QuizDataError(\"Question must be no more than \".concat(VALIDATION_RULES.QUESTION_MAX_LENGTH, \" characters long\"), 'INVALID_QUESTION_LENGTH');\n        }\n        if (!question.options || question.options.length !== VALIDATION_RULES.MIN_OPTIONS) {\n            throw new QuizDataError(\"Question must have exactly \".concat(VALIDATION_RULES.MIN_OPTIONS, \" options\"), 'INVALID_OPTIONS_COUNT');\n        }\n        // Validate each option\n        question.options.forEach((option, index)=>{\n            if (!option || option.length < VALIDATION_RULES.OPTION_MIN_LENGTH) {\n                throw new QuizDataError(\"Option \".concat(index + 1, \" must be at least \").concat(VALIDATION_RULES.OPTION_MIN_LENGTH, \" character long\"), 'INVALID_OPTION_LENGTH');\n            }\n            if (option.length > VALIDATION_RULES.OPTION_MAX_LENGTH) {\n                throw new QuizDataError(\"Option \".concat(index + 1, \" must be no more than \").concat(VALIDATION_RULES.OPTION_MAX_LENGTH, \" characters long\"), 'INVALID_OPTION_LENGTH');\n            }\n        });\n        // Check for duplicate options\n        const uniqueOptions = new Set(question.options.map((opt)=>opt.toLowerCase().trim()));\n        if (uniqueOptions.size !== question.options.length) {\n            throw new QuizDataError('All options must be unique', 'DUPLICATE_OPTIONS');\n        }\n        // Validate correct answer\n        if (typeof question.correctAnswer !== 'number' || question.correctAnswer < 0 || question.correctAnswer >= question.options.length) {\n            throw new QuizDataError('Invalid correct answer selection', 'INVALID_CORRECT_ANSWER');\n        }\n        // Validate category\n        const validCategories = _types_admin__WEBPACK_IMPORTED_MODULE_0__.DEFAULT_CATEGORIES.map((c)=>c.id);\n        if (!question.category || !validCategories.includes(question.category)) {\n            throw new QuizDataError('Invalid category selection', 'INVALID_CATEGORY');\n        }\n    }\n    // Utility methods\n    saveQuestions(questions) {\n        this.safeSetItem(_types_admin__WEBPACK_IMPORTED_MODULE_0__.QUIZ_STORAGE_KEYS.QUESTIONS, JSON.stringify(questions));\n    }\n    generateId() {\n        return \"q_\".concat(Date.now(), \"_\").concat(Math.random().toString(36).substr(2, 9));\n    }\n    // CSV Export/Import functionality\n    exportToCSV(questions) {\n        const questionsToExport = questions || this.getQuestions();\n        const headers = [\n            'ID',\n            'Question',\n            'Option 1',\n            'Option 2',\n            'Option 3',\n            'Option 4',\n            'Correct Answer',\n            'Category',\n            'Difficulty',\n            'Type',\n            'Fun Fact',\n            'Tags',\n            'Created At',\n            'Updated At'\n        ];\n        const csvRows = [\n            headers.join(','),\n            ...questionsToExport.map((q)=>[\n                    q.id,\n                    '\"'.concat(q.question.replace(/\"/g, '\"\"'), '\"'),\n                    '\"'.concat(q.options[0].replace(/\"/g, '\"\"'), '\"'),\n                    '\"'.concat(q.options[1].replace(/\"/g, '\"\"'), '\"'),\n                    '\"'.concat(q.options[2].replace(/\"/g, '\"\"'), '\"'),\n                    '\"'.concat(q.options[3].replace(/\"/g, '\"\"'), '\"'),\n                    q.correctAnswer + 1,\n                    q.category,\n                    q.difficulty,\n                    q.type,\n                    '\"'.concat((q.funFact || '').replace(/\"/g, '\"\"'), '\"'),\n                    '\"'.concat((q.tags || []).join(';'), '\"'),\n                    new Date(q.createdAt).toISOString(),\n                    new Date(q.updatedAt).toISOString()\n                ].join(','))\n        ];\n        // Add UTF-8 BOM for Excel compatibility\n        return '\\uFEFF' + csvRows.join('\\n');\n    }\n    async importFromCSV(csvContent) {\n        const lines = csvContent.split('\\n').filter((line)=>line.trim());\n        if (lines.length < 2) {\n            throw new QuizDataError('CSV file must contain at least a header and one data row', 'INVALID_CSV_FORMAT');\n        }\n        const headers = lines[0].split(',').map((h)=>h.trim().replace(/\"/g, ''));\n        const dataLines = lines.slice(1);\n        const results = {\n            success: true,\n            processedCount: 0,\n            errorCount: 0,\n            errors: []\n        };\n        const validQuestions = [];\n        const existingQuestions = this.getQuestions();\n        for(let i = 0; i < dataLines.length; i++){\n            try {\n                const values = this.parseCSVLine(dataLines[i]);\n                if (values.length < 8) {\n                    results.errors.push(\"Line \".concat(i + 2, \": Insufficient data columns\"));\n                    results.errorCount++;\n                    continue;\n                }\n                const question = {\n                    id: values[0] || this.generateId(),\n                    question: values[1],\n                    options: [\n                        values[2],\n                        values[3],\n                        values[4],\n                        values[5]\n                    ],\n                    correctAnswer: parseInt(values[6]) - 1,\n                    category: values[7],\n                    difficulty: values[8],\n                    type: values[9] || 'regular',\n                    funFact: values[10] || undefined,\n                    tags: values[11] ? values[11].split(';').filter((t)=>t.trim()) : undefined,\n                    createdAt: values[12] ? new Date(values[12]).getTime() : Date.now(),\n                    updatedAt: values[13] ? new Date(values[13]).getTime() : Date.now()\n                };\n                // Validate the question\n                this.validateQuestion(question);\n                // Check for duplicates\n                const existingIndex = existingQuestions.findIndex((q)=>q.id === question.id);\n                if (existingIndex >= 0) {\n                    // Update existing question\n                    existingQuestions[existingIndex] = question;\n                } else {\n                    validQuestions.push(question);\n                }\n                results.processedCount++;\n            } catch (error) {\n                results.errors.push(\"Line \".concat(i + 2, \": \").concat(error instanceof Error ? error.message : 'Unknown error'));\n                results.errorCount++;\n            }\n        }\n        // Save all valid questions\n        if (validQuestions.length > 0) {\n            const allQuestions = [\n                ...existingQuestions,\n                ...validQuestions\n            ];\n            this.saveQuestions(allQuestions);\n        }\n        results.success = results.errorCount === 0;\n        return results;\n    }\n    parseCSVLine(line) {\n        const result = [];\n        let current = '';\n        let inQuotes = false;\n        for(let i = 0; i < line.length; i++){\n            const char = line[i];\n            if (char === '\"') {\n                if (inQuotes && line[i + 1] === '\"') {\n                    current += '\"';\n                    i++; // Skip next quote\n                } else {\n                    inQuotes = !inQuotes;\n                }\n            } else if (char === ',' && !inQuotes) {\n                result.push(current.trim());\n                current = '';\n            } else {\n                current += char;\n            }\n        }\n        result.push(current.trim());\n        return result;\n    }\n    initializeWithSampleData() {\n        // Initialize with a few sample questions for demonstration\n        const sampleQuestions = [\n            {\n                id: 'sample_1',\n                question: 'Which social media platform is known for its short-form video content and viral dances?',\n                options: [\n                    'Instagram',\n                    'TikTok',\n                    'Twitter',\n                    'Snapchat'\n                ],\n                correctAnswer: 1,\n                category: 'social-media',\n                difficulty: 'beginner',\n                type: 'regular',\n                funFact: 'TikTok was originally called Musical.ly before being acquired by ByteDance.',\n                tags: [\n                    'social-media',\n                    'video',\n                    'viral'\n                ],\n                createdAt: Date.now() - 86400000,\n                updatedAt: Date.now() - 86400000\n            }\n        ];\n        this.saveQuestions(sampleQuestions);\n        return sampleQuestions;\n    }\n    // Backup and restore functionality\n    createBackup() {\n        const backup = {\n            questions: this.getQuestions(),\n            settings: this.getSettings(),\n            drafts: this.getDrafts(),\n            timestamp: Date.now(),\n            version: '1.0'\n        };\n        return JSON.stringify(backup, null, 2);\n    }\n    restoreFromBackup(backupData) {\n        try {\n            const backup = JSON.parse(backupData);\n            if (!backup.questions || !Array.isArray(backup.questions)) {\n                throw new QuizDataError('Invalid backup format: missing questions array', 'INVALID_BACKUP');\n            }\n            // Validate all questions in backup\n            backup.questions.forEach((q, index)=>{\n                try {\n                    this.validateQuestion(q);\n                } catch (error) {\n                    throw new QuizDataError(\"Invalid question at index \".concat(index, \": \").concat(error instanceof Error ? error.message : 'Unknown error'), 'INVALID_BACKUP_QUESTION');\n                }\n            });\n            // Create current backup before restore\n            const currentBackup = this.createBackup();\n            this.safeSetItem(_types_admin__WEBPACK_IMPORTED_MODULE_0__.QUIZ_STORAGE_KEYS.BACKUP, currentBackup);\n            // Restore data\n            this.saveQuestions(backup.questions);\n            if (backup.settings) {\n                this.safeSetItem(_types_admin__WEBPACK_IMPORTED_MODULE_0__.QUIZ_STORAGE_KEYS.SETTINGS, JSON.stringify(backup.settings));\n            }\n            if (backup.drafts) {\n                this.safeSetItem(_types_admin__WEBPACK_IMPORTED_MODULE_0__.QUIZ_STORAGE_KEYS.DRAFTS, JSON.stringify(backup.drafts));\n            }\n            return {\n                success: true,\n                processedCount: backup.questions.length,\n                errorCount: 0,\n                errors: []\n            };\n        } catch (error) {\n            throw new QuizDataError(\"Failed to restore backup: \".concat(error instanceof Error ? error.message : 'Unknown error'), 'RESTORE_FAILED');\n        }\n    }\n    // Auto-save functionality for drafts\n    startAutoSave(draftId, getDraftData) {\n        this.stopAutoSave();\n        this.autoSaveTimer = setInterval(()=>{\n            try {\n                const draftData = getDraftData();\n                if (draftData.question && draftData.question.length > 0) {\n                    const draft = {\n                        id: draftId,\n                        question: draftData.question || '',\n                        options: draftData.options || [\n                            '',\n                            '',\n                            '',\n                            ''\n                        ],\n                        correctAnswer: draftData.correctAnswer || 0,\n                        category: draftData.category || 'facts',\n                        difficulty: draftData.difficulty || 'beginner',\n                        type: draftData.type || 'regular',\n                        funFact: draftData.funFact,\n                        tags: draftData.tags,\n                        lastSaved: Date.now()\n                    };\n                    this.saveDraft(draft);\n                }\n            } catch (error) {\n                console.error('Auto-save failed:', error);\n            }\n        }, VALIDATION_RULES.AUTO_SAVE_INTERVAL);\n    }\n    stopAutoSave() {\n        if (this.autoSaveTimer) {\n            clearInterval(this.autoSaveTimer);\n            this.autoSaveTimer = null;\n        }\n    }\n    // CSV Export functionality\n    exportToCSV(questionsToExport) {\n        const questions = questionsToExport || this.getQuestions();\n        const headers = [\n            'ID',\n            'Question',\n            'Option 1',\n            'Option 2',\n            'Option 3',\n            'Option 4',\n            'Correct Answer (1-4)',\n            'Category',\n            'Difficulty',\n            'Type',\n            'Fun Fact',\n            'Tags',\n            'Created At',\n            'Updated At'\n        ];\n        const csvRows = [\n            headers.join(',')\n        ];\n        questions.forEach((question)=>{\n            var _question_options_, _question_options_1, _question_options_2, _question_options_3;\n            const row = [\n                question.id,\n                '\"'.concat(question.question.replace(/\"/g, '\"\"'), '\"'),\n                '\"'.concat(((_question_options_ = question.options[0]) === null || _question_options_ === void 0 ? void 0 : _question_options_.replace(/\"/g, '\"\"')) || '', '\"'),\n                '\"'.concat(((_question_options_1 = question.options[1]) === null || _question_options_1 === void 0 ? void 0 : _question_options_1.replace(/\"/g, '\"\"')) || '', '\"'),\n                '\"'.concat(((_question_options_2 = question.options[2]) === null || _question_options_2 === void 0 ? void 0 : _question_options_2.replace(/\"/g, '\"\"')) || '', '\"'),\n                '\"'.concat(((_question_options_3 = question.options[3]) === null || _question_options_3 === void 0 ? void 0 : _question_options_3.replace(/\"/g, '\"\"')) || '', '\"'),\n                question.correctAnswer + 1,\n                question.category,\n                question.difficulty,\n                question.type,\n                '\"'.concat((question.funFact || '').replace(/\"/g, '\"\"'), '\"'),\n                '\"'.concat((question.tags || []).join(';'), '\"'),\n                new Date(question.createdAt).toISOString(),\n                new Date(question.updatedAt).toISOString()\n            ];\n            csvRows.push(row.join(','));\n        });\n        return csvRows.join('\\n');\n    }\n    // Download CSV file\n    downloadCSV() {\n        try {\n            const csvContent = this.exportToCSV();\n            const blob = new Blob([\n                csvContent\n            ], {\n                type: 'text/csv;charset=utf-8;'\n            });\n            const link = document.createElement('a');\n            if (link.download !== undefined) {\n                const url = URL.createObjectURL(blob);\n                link.setAttribute('href', url);\n                link.setAttribute('download', \"techkwiz-questions-\".concat(new Date().toISOString().split('T')[0], \".csv\"));\n                link.style.visibility = 'hidden';\n                document.body.appendChild(link);\n                link.click();\n                document.body.removeChild(link);\n                URL.revokeObjectURL(url);\n            }\n        } catch (error) {\n            throw new QuizDataError('Failed to download CSV file', 'EXPORT_ERROR');\n        }\n    }\n    // Parse CSV content\n    parseCSV(csvContent) {\n        const lines = csvContent.split('\\n').filter((line)=>line.trim());\n        const errors = [];\n        const questions = [];\n        if (lines.length < 2) {\n            errors.push('CSV file must contain at least a header row and one data row');\n            return {\n                questions,\n                errors\n            };\n        }\n        // Skip header row\n        const dataLines = lines.slice(1);\n        dataLines.forEach((line, index)=>{\n            try {\n                const values = this.parseCSVLine(line);\n                if (values.length < 8) {\n                    errors.push(\"Row \".concat(index + 2, \": Insufficient columns (minimum 8 required)\"));\n                    return;\n                }\n                const [id, question, opt1, opt2, opt3, opt4, correctAnswer, category, difficulty, type, funFact, tags, createdAt, updatedAt] = values;\n                // Validate required fields\n                if (!(question === null || question === void 0 ? void 0 : question.trim())) {\n                    errors.push(\"Row \".concat(index + 2, \": Question is required\"));\n                    return;\n                }\n                if (!(opt1 === null || opt1 === void 0 ? void 0 : opt1.trim()) || !(opt2 === null || opt2 === void 0 ? void 0 : opt2.trim()) || !(opt3 === null || opt3 === void 0 ? void 0 : opt3.trim()) || !(opt4 === null || opt4 === void 0 ? void 0 : opt4.trim())) {\n                    errors.push(\"Row \".concat(index + 2, \": All 4 options are required\"));\n                    return;\n                }\n                const correctAnswerNum = parseInt(correctAnswer) - 1 // Convert 1-based to 0-based\n                ;\n                if (isNaN(correctAnswerNum) || correctAnswerNum < 0 || correctAnswerNum > 3) {\n                    errors.push(\"Row \".concat(index + 2, \": Correct answer must be 1, 2, 3, or 4\"));\n                    return;\n                }\n                if (!(category === null || category === void 0 ? void 0 : category.trim())) {\n                    errors.push(\"Row \".concat(index + 2, \": Category is required\"));\n                    return;\n                }\n                if (![\n                    'beginner',\n                    'intermediate',\n                    'advanced'\n                ].includes(difficulty)) {\n                    errors.push(\"Row \".concat(index + 2, \": Difficulty must be 'beginner', 'intermediate', or 'advanced'\"));\n                    return;\n                }\n                if (![\n                    'regular',\n                    'bonus'\n                ].includes(type)) {\n                    errors.push(\"Row \".concat(index + 2, \": Type must be 'regular' or 'bonus'\"));\n                    return;\n                }\n                const questionData = {\n                    id: id || \"imported_\".concat(Date.now(), \"_\").concat(index),\n                    question: question.trim(),\n                    options: [\n                        opt1.trim(),\n                        opt2.trim(),\n                        opt3.trim(),\n                        opt4.trim()\n                    ],\n                    correctAnswer: correctAnswerNum,\n                    category: category.trim(),\n                    difficulty: difficulty,\n                    type: type,\n                    funFact: (funFact === null || funFact === void 0 ? void 0 : funFact.trim()) || undefined,\n                    tags: tags ? tags.split(';').map((tag)=>tag.trim()).filter(Boolean) : [],\n                    createdAt: createdAt ? new Date(createdAt).getTime() : Date.now(),\n                    updatedAt: updatedAt ? new Date(updatedAt).getTime() : Date.now()\n                };\n                questions.push(questionData);\n            } catch (error) {\n                errors.push(\"Row \".concat(index + 2, \": \").concat(error instanceof Error ? error.message : 'Parse error'));\n            }\n        });\n        return {\n            questions,\n            errors\n        };\n    }\n    // Helper to parse CSV line with proper quote handling\n    parseCSVLine(line) {\n        const result = [];\n        let current = '';\n        let inQuotes = false;\n        let i = 0;\n        while(i < line.length){\n            const char = line[i];\n            if (char === '\"') {\n                if (inQuotes && line[i + 1] === '\"') {\n                    // Escaped quote\n                    current += '\"';\n                    i += 2;\n                } else {\n                    // Toggle quote state\n                    inQuotes = !inQuotes;\n                    i++;\n                }\n            } else if (char === ',' && !inQuotes) {\n                // End of field\n                result.push(current);\n                current = '';\n                i++;\n            } else {\n                current += char;\n                i++;\n            }\n        }\n        result.push(current); // Add last field\n        return result;\n    }\n    // Import from CSV\n    importFromCSV(csvContent) {\n        try {\n            const { questions, errors } = this.parseCSV(csvContent);\n            if (errors.length > 0) {\n                return {\n                    success: false,\n                    processedCount: 0,\n                    errorCount: errors.length,\n                    errors\n                };\n            }\n            let successCount = 0;\n            const importErrors = [];\n            questions.forEach((questionData, index)=>{\n                try {\n                    const fullQuestion = {\n                        id: questionData.id,\n                        question: questionData.question,\n                        options: questionData.options,\n                        correctAnswer: questionData.correctAnswer,\n                        category: questionData.category,\n                        difficulty: questionData.difficulty,\n                        type: questionData.type,\n                        funFact: questionData.funFact,\n                        tags: questionData.tags || [],\n                        createdAt: questionData.createdAt,\n                        updatedAt: questionData.updatedAt\n                    };\n                    // Validate the complete question\n                    const validation = this.validateQuestion(fullQuestion);\n                    if (!validation.isValid) {\n                        importErrors.push(\"Question \".concat(index + 1, \": \").concat(validation.errors.join(', ')));\n                        return;\n                    }\n                    this.saveQuestion(fullQuestion);\n                    successCount++;\n                } catch (error) {\n                    importErrors.push(\"Question \".concat(index + 1, \": \").concat(error instanceof Error ? error.message : 'Save error'));\n                }\n            });\n            return {\n                success: importErrors.length === 0,\n                processedCount: successCount,\n                errorCount: importErrors.length,\n                errors: importErrors\n            };\n        } catch (error) {\n            return {\n                success: false,\n                processedCount: 0,\n                errorCount: 1,\n                errors: [\n                    error instanceof Error ? error.message : 'Import failed'\n                ]\n            };\n        }\n    }\n    constructor(){\n        this.autoSaveTimer = null;\n    }\n}\n// Export singleton instance\nconst quizDataManager = QuizDataManager.getInstance();\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy91dGlscy9xdWl6RGF0YU1hbmFnZXIudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQVNzQjtBQUV0QiwwQkFBMEI7QUFDbkIsTUFBTUUsbUJBQW1CO0lBQzlCQyxxQkFBcUI7SUFDckJDLHFCQUFxQjtJQUNyQkMsbUJBQW1CO0lBQ25CQyxtQkFBbUI7SUFDbkJDLGFBQWE7SUFDYkMsYUFBYTtJQUNiQyxxQkFBcUI7SUFDckJDLGVBQWUsSUFBSSxPQUFPO0lBQzFCQyxvQkFBb0IsTUFBTSxhQUFhO0FBQ3pDLEVBQVU7QUFFVixjQUFjO0FBQ1AsTUFBTUMsc0JBQXNCQztJQUNqQyxZQUFZQyxPQUFlLEVBQUUsSUFBbUIsQ0FBRTtRQUNoRCxLQUFLLENBQUNBLGVBRDRCQyxPQUFBQTtRQUVsQyxJQUFJLENBQUNDLElBQUksR0FBRztJQUNkO0FBQ0Y7QUFFQSxnREFBZ0Q7QUFDaEQsTUFBTUM7SUFJSixPQUFPQyxjQUErQjtRQUNwQyxJQUFJLENBQUNELGdCQUFnQkUsUUFBUSxFQUFFO1lBQzdCRixnQkFBZ0JFLFFBQVEsR0FBRyxJQUFJRjtRQUNqQztRQUNBLE9BQU9BLGdCQUFnQkUsUUFBUTtJQUNqQztJQUVBLG1EQUFtRDtJQUMzQ0MsWUFBWUMsR0FBVyxFQUFpQjtRQUM5QyxvQ0FBb0M7UUFDcEMsSUFBSSxLQUE2QixFQUFFLEVBRWxDO1FBRUQsSUFBSTtZQUNGLE9BQU9DLGFBQWFDLE9BQU8sQ0FBQ0Y7UUFDOUIsRUFBRSxPQUFPRyxPQUFPO1lBQ2RDLFFBQVFELEtBQUssQ0FBQyx1Q0FBMkMsT0FBSkgsS0FBSSxNQUFJRztZQUM3RCxPQUFPO1FBQ1Q7SUFDRjtJQUVRRSxZQUFZTCxHQUFXLEVBQUVNLEtBQWEsRUFBVztRQUN2RCxxQ0FBcUM7UUFDckMsSUFBSSxLQUE2QixFQUFFLEVBRWxDO1FBRUQsSUFBSTtZQUNGTCxhQUFhTSxPQUFPLENBQUNQLEtBQUtNO1lBQzFCLE9BQU87UUFDVCxFQUFFLE9BQU9ILE9BQU87WUFDZEMsUUFBUUQsS0FBSyxDQUFDLHFDQUF5QyxPQUFKSCxLQUFJLE1BQUlHO1lBQzNELElBQUlBLGlCQUFpQkssZ0JBQWdCTCxNQUFNVCxJQUFJLEtBQUssSUFBSTtnQkFDdEQsTUFBTSxJQUFJSCxjQUFjLG1EQUFtRDtZQUM3RTtZQUNBLE9BQU87UUFDVDtJQUNGO0lBRUEsMkJBQTJCO0lBQzNCa0IsZUFBK0I7UUFDN0IsTUFBTUMsT0FBTyxJQUFJLENBQUNYLFdBQVcsQ0FBQ3BCLDJEQUFpQkEsQ0FBQ2dDLFNBQVM7UUFDekQsSUFBSSxDQUFDRCxNQUFNLE9BQU8sSUFBSSxDQUFDRSx3QkFBd0I7UUFFL0MsSUFBSTtZQUNGLE1BQU1DLFlBQVlDLEtBQUtDLEtBQUssQ0FBQ0w7WUFDN0IsT0FBT00sTUFBTUMsT0FBTyxDQUFDSixhQUFhQSxZQUFZLEVBQUU7UUFDbEQsRUFBRSxPQUFPVixPQUFPO1lBQ2RDLFFBQVFELEtBQUssQ0FBQyxpQ0FBaUNBO1lBQy9DLE9BQU8sSUFBSSxDQUFDUyx3QkFBd0I7UUFDdEM7SUFDRjtJQUVBLHVDQUF1QztJQUN2Q00scUJBQXFCQyxPQU9wQixFQUFrQjtRQUNqQixNQUFNTixZQUFZLElBQUksQ0FBQ0osWUFBWTtRQUVuQyxJQUFJLENBQUNVLFNBQVMsT0FBT047UUFFckIsT0FBT0EsVUFBVU8sTUFBTSxDQUFDQyxDQUFBQTtZQUN0QixJQUFJRixRQUFRRyxRQUFRLElBQUlELFNBQVNDLFFBQVEsS0FBS0gsUUFBUUcsUUFBUSxFQUFFLE9BQU87WUFDdkUsSUFBSUgsUUFBUUksVUFBVSxJQUFJRixTQUFTRSxVQUFVLEtBQUtKLFFBQVFJLFVBQVUsRUFBRSxPQUFPO1lBQzdFLElBQUlKLFFBQVFLLElBQUksSUFBSUgsU0FBU0csSUFBSSxLQUFLTCxRQUFRSyxJQUFJLEVBQUUsT0FBTztZQUMzRCxJQUFJTCxRQUFRTSxPQUFPLElBQUlKLFNBQVNJLE9BQU8sS0FBS04sUUFBUU0sT0FBTyxFQUFFLE9BQU87WUFDcEUsSUFBSU4sUUFBUU8sV0FBVyxJQUFJTCxTQUFTSyxXQUFXLEtBQUtQLFFBQVFPLFdBQVcsRUFBRSxPQUFPO1lBQ2hGLElBQUlQLFFBQVFRLElBQUksSUFBSSxDQUFDUixRQUFRUSxJQUFJLENBQUNDLElBQUksQ0FBQ0MsQ0FBQUE7b0JBQU9SO3dCQUFBQSxpQkFBQUEsU0FBU00sSUFBSSxjQUFiTixxQ0FBQUEsZUFBZVMsUUFBUSxDQUFDRDtnQkFBTyxPQUFPO1lBQ3BGLE9BQU87UUFDVDtJQUNGO0lBRUEsMkJBQTJCO0lBQzNCRSxzQkFBc0JOLE9BQTJELEVBQWtCO1FBQ2pHLE9BQU8sSUFBSSxDQUFDUCxvQkFBb0IsQ0FBQztZQUFFTztRQUFRO0lBQzdDO0lBRUEsd0NBQXdDO0lBQ3hDTyxpQ0FBaUNWLFFBQWdCLEVBQUVHLE9BQTRELEVBQWtCO1FBQy9ILE9BQU8sSUFBSSxDQUFDUCxvQkFBb0IsQ0FBQztZQUFFSTtZQUFVRztRQUFRO0lBQ3ZEO0lBRUFRLGFBQWFaLFFBQThELEVBQWdCO1FBQ3pGLElBQUksQ0FBQ2EsZ0JBQWdCLENBQUNiO1FBRXRCLE1BQU1SLFlBQVksSUFBSSxDQUFDSixZQUFZO1FBQ25DLE1BQU0wQixNQUFNQyxLQUFLRCxHQUFHO1FBQ3BCLE1BQU1FLGNBQTRCO1lBQ2hDLEdBQUdoQixRQUFRO1lBQ1hpQixJQUFJLElBQUksQ0FBQ0MsVUFBVTtZQUNuQkMsV0FBV0w7WUFDWE0sV0FBV047UUFDYjtRQUVBdEIsVUFBVTZCLElBQUksQ0FBQ0w7UUFDZixJQUFJLENBQUNNLGFBQWEsQ0FBQzlCO1FBQ25CLE9BQU93QjtJQUNUO0lBRUFPLGVBQWVOLEVBQVUsRUFBRU8sT0FBd0QsRUFBZ0I7UUFDakcsTUFBTWhDLFlBQVksSUFBSSxDQUFDSixZQUFZO1FBQ25DLE1BQU1xQyxRQUFRakMsVUFBVWtDLFNBQVMsQ0FBQ0MsQ0FBQUEsSUFBS0EsRUFBRVYsRUFBRSxLQUFLQTtRQUVoRCxJQUFJUSxVQUFVLENBQUMsR0FBRztZQUNoQixNQUFNLElBQUl2RCxjQUFjLG9CQUF1QixPQUFIK0MsSUFBRyxlQUFhO1FBQzlEO1FBRUEsTUFBTVcsa0JBQWtCO1lBQ3RCLEdBQUdwQyxTQUFTLENBQUNpQyxNQUFNO1lBQ25CLEdBQUdELE9BQU87WUFDVkosV0FBV0wsS0FBS0QsR0FBRztRQUNyQjtRQUVBLElBQUksQ0FBQ0QsZ0JBQWdCLENBQUNlO1FBQ3RCcEMsU0FBUyxDQUFDaUMsTUFBTSxHQUFHRztRQUNuQixJQUFJLENBQUNOLGFBQWEsQ0FBQzlCO1FBQ25CLE9BQU9vQztJQUNUO0lBRUFDLGVBQWVaLEVBQVUsRUFBVztRQUNsQyxNQUFNekIsWUFBWSxJQUFJLENBQUNKLFlBQVk7UUFDbkMsTUFBTTBDLG9CQUFvQnRDLFVBQVVPLE1BQU0sQ0FBQzRCLENBQUFBLElBQUtBLEVBQUVWLEVBQUUsS0FBS0E7UUFFekQsSUFBSWEsa0JBQWtCQyxNQUFNLEtBQUt2QyxVQUFVdUMsTUFBTSxFQUFFO1lBQ2pELE1BQU0sSUFBSTdELGNBQWMsb0JBQXVCLE9BQUgrQyxJQUFHLGVBQWE7UUFDOUQ7UUFFQSxJQUFJLENBQUNLLGFBQWEsQ0FBQ1E7UUFDbkIsT0FBTztJQUNUO0lBRUFFLFdBQVdDLEdBQWEsRUFBdUI7UUFDN0MsSUFBSUEsSUFBSUYsTUFBTSxHQUFHdkUsaUJBQWlCTyxtQkFBbUIsRUFBRTtZQUNyRCxNQUFNLElBQUlHLGNBQ1IsMkJBQWdFLE9BQXJDVixpQkFBaUJPLG1CQUFtQixFQUFDLHVCQUNoRTtRQUVKO1FBRUEsTUFBTXlCLFlBQVksSUFBSSxDQUFDSixZQUFZO1FBQ25DLE1BQU04QyxlQUFlMUMsVUFBVXVDLE1BQU07UUFDckMsTUFBTUQsb0JBQW9CdEMsVUFBVU8sTUFBTSxDQUFDNEIsQ0FBQUEsSUFBSyxDQUFDTSxJQUFJeEIsUUFBUSxDQUFDa0IsRUFBRVYsRUFBRTtRQUNsRSxNQUFNa0IsZUFBZUQsZUFBZUosa0JBQWtCQyxNQUFNO1FBRTVELElBQUksQ0FBQ1QsYUFBYSxDQUFDUTtRQUVuQixPQUFPO1lBQ0xNLFNBQVM7WUFDVEMsZ0JBQWdCRjtZQUNoQkcsWUFBWUwsSUFBSUYsTUFBTSxHQUFHSTtZQUN6QkksUUFBUU4sSUFBSUYsTUFBTSxHQUFHSSxlQUFlO2dCQUFDO2FBQWdDLEdBQUcsRUFBRTtRQUM1RTtJQUNGO0lBRUEsK0JBQStCO0lBQy9CSyxnQkFBZ0IxQyxPQUFzQixFQUFrQjtRQUN0RCxNQUFNTixZQUFZLElBQUksQ0FBQ0osWUFBWTtRQUVuQyxPQUFPSSxVQUFVTyxNQUFNLENBQUNDLENBQUFBO1lBQ3RCLGNBQWM7WUFDZCxJQUFJRixRQUFRMkMsVUFBVSxFQUFFO2dCQUN0QixNQUFNQyxjQUFjNUMsUUFBUTJDLFVBQVUsQ0FBQ0UsV0FBVztnQkFDbEQsSUFBSSxDQUFDM0MsU0FBU0EsUUFBUSxDQUFDMkMsV0FBVyxHQUFHbEMsUUFBUSxDQUFDaUMsY0FBYztvQkFDMUQsT0FBTztnQkFDVDtZQUNGO1lBRUEsa0JBQWtCO1lBQ2xCLElBQUk1QyxRQUFRRyxRQUFRLEtBQUssU0FBU0QsU0FBU0MsUUFBUSxLQUFLSCxRQUFRRyxRQUFRLEVBQUU7Z0JBQ3hFLE9BQU87WUFDVDtZQUVBLG9CQUFvQjtZQUNwQixJQUFJSCxRQUFRSSxVQUFVLEtBQUssU0FBU0YsU0FBU0UsVUFBVSxLQUFLSixRQUFRSSxVQUFVLEVBQUU7Z0JBQzlFLE9BQU87WUFDVDtZQUVBLGNBQWM7WUFDZCxJQUFJSixRQUFRSyxJQUFJLEtBQUssU0FBU0gsU0FBU0csSUFBSSxLQUFLTCxRQUFRSyxJQUFJLEVBQUU7Z0JBQzVELE9BQU87WUFDVDtZQUVBLE9BQU87UUFDVDtJQUNGO0lBRUEsd0JBQXdCO0lBQ3hCeUMsZ0JBQWdDO1FBQzlCLE1BQU1wRCxZQUFZLElBQUksQ0FBQ0osWUFBWTtRQUNuQyxNQUFNeUQsaUJBQWlCckQsVUFBVXNELE1BQU0sQ0FBQyxDQUFDQyxLQUFLL0M7WUFDNUMrQyxHQUFHLENBQUMvQyxTQUFTQyxRQUFRLENBQUMsR0FBRyxDQUFDOEMsR0FBRyxDQUFDL0MsU0FBU0MsUUFBUSxDQUFDLElBQUksS0FBSztZQUN6RCxPQUFPOEM7UUFDVCxHQUFHLENBQUM7UUFFSixPQUFPeEYsNERBQWtCQSxDQUFDeUYsR0FBRyxDQUFDL0MsQ0FBQUEsV0FBYTtnQkFDekMsR0FBR0EsUUFBUTtnQkFDWGdELGVBQWVKLGNBQWMsQ0FBQzVDLFNBQVNnQixFQUFFLENBQUMsSUFBSTtZQUNoRDtJQUNGO0lBRUEsbUJBQW1CO0lBQ25CaUMsVUFBVUMsS0FBb0IsRUFBUTtRQUNwQyxNQUFNQyxTQUFTLElBQUksQ0FBQ0MsU0FBUztRQUM3QixNQUFNQyxnQkFBZ0JGLE9BQU8xQixTQUFTLENBQUM2QixDQUFBQSxJQUFLQSxFQUFFdEMsRUFBRSxLQUFLa0MsTUFBTWxDLEVBQUU7UUFFN0QsSUFBSXFDLGlCQUFpQixHQUFHO1lBQ3RCRixNQUFNLENBQUNFLGNBQWMsR0FBRztnQkFBRSxHQUFHSCxLQUFLO2dCQUFFSyxXQUFXekMsS0FBS0QsR0FBRztZQUFHO1FBQzVELE9BQU87WUFDTHNDLE9BQU8vQixJQUFJLENBQUM7Z0JBQUUsR0FBRzhCLEtBQUs7Z0JBQUVLLFdBQVd6QyxLQUFLRCxHQUFHO1lBQUc7UUFDaEQ7UUFFQSxJQUFJLENBQUM5QixXQUFXLENBQUMxQiwyREFBaUJBLENBQUNtRyxNQUFNLEVBQUVoRSxLQUFLaUUsU0FBUyxDQUFDTjtJQUM1RDtJQUVBQyxZQUE2QjtRQUMzQixNQUFNaEUsT0FBTyxJQUFJLENBQUNYLFdBQVcsQ0FBQ3BCLDJEQUFpQkEsQ0FBQ21HLE1BQU07UUFDdEQsSUFBSSxDQUFDcEUsTUFBTSxPQUFPLEVBQUU7UUFFcEIsSUFBSTtZQUNGLE9BQU9JLEtBQUtDLEtBQUssQ0FBQ0w7UUFDcEIsRUFBRSxPQUFPUCxPQUFPO1lBQ2RDLFFBQVFELEtBQUssQ0FBQyw4QkFBOEJBO1lBQzVDLE9BQU8sRUFBRTtRQUNYO0lBQ0Y7SUFFQTZFLFlBQVkxQyxFQUFVLEVBQVE7UUFDNUIsTUFBTW1DLFNBQVMsSUFBSSxDQUFDQyxTQUFTLEdBQUd0RCxNQUFNLENBQUN3RCxDQUFBQSxJQUFLQSxFQUFFdEMsRUFBRSxLQUFLQTtRQUNyRCxJQUFJLENBQUNqQyxXQUFXLENBQUMxQiwyREFBaUJBLENBQUNtRyxNQUFNLEVBQUVoRSxLQUFLaUUsU0FBUyxDQUFDTjtJQUM1RDtJQUVBLHNCQUFzQjtJQUN0QlEsY0FBc0M7UUFDcEMsTUFBTXZFLE9BQU8sSUFBSSxDQUFDWCxXQUFXLENBQUNwQiwyREFBaUJBLENBQUN1RyxRQUFRO1FBQ3hELElBQUksQ0FBQ3hFLE1BQU0sT0FBTyxJQUFJLENBQUN5RSxrQkFBa0I7UUFFekMsSUFBSTtZQUNGLE9BQU87Z0JBQUUsR0FBRyxJQUFJLENBQUNBLGtCQUFrQixFQUFFO2dCQUFFLEdBQUdyRSxLQUFLQyxLQUFLLENBQUNMLEtBQUs7WUFBQztRQUM3RCxFQUFFLE9BQU9QLE9BQU87WUFDZEMsUUFBUUQsS0FBSyxDQUFDLGdDQUFnQ0E7WUFDOUMsT0FBTyxJQUFJLENBQUNnRixrQkFBa0I7UUFDaEM7SUFDRjtJQUVBQyxhQUFhQyxRQUF5QyxFQUFRO1FBQzVELE1BQU1DLGtCQUFrQixJQUFJLENBQUNMLFdBQVc7UUFDeEMsTUFBTU0sa0JBQWtCO1lBQUUsR0FBR0QsZUFBZTtZQUFFLEdBQUdELFFBQVE7UUFBQztRQUMxRCxJQUFJLENBQUNoRixXQUFXLENBQUMxQiwyREFBaUJBLENBQUN1RyxRQUFRLEVBQUVwRSxLQUFLaUUsU0FBUyxDQUFDUTtJQUM5RDtJQUVRSixxQkFBNkM7UUFDbkQsT0FBTztZQUNMSyxVQUFVO1lBQ1ZDLFFBQVE7WUFDUkMsV0FBVztZQUNYdkUsU0FBUztnQkFDUDJDLFlBQVk7Z0JBQ1p4QyxVQUFVO2dCQUNWQyxZQUFZO2dCQUNaQyxNQUFNO1lBQ1I7WUFDQW1FLG1CQUFtQixFQUFFO1FBQ3ZCO0lBQ0Y7SUFFQSxhQUFhO0lBQ0x6RCxpQkFBaUJiLFFBQStCLEVBQVE7UUFDOUQsSUFBSSxDQUFDQSxTQUFTQSxRQUFRLElBQUlBLFNBQVNBLFFBQVEsQ0FBQytCLE1BQU0sR0FBR3ZFLGlCQUFpQkMsbUJBQW1CLEVBQUU7WUFDekYsTUFBTSxJQUFJUyxjQUNSLDZCQUFrRSxPQUFyQ1YsaUJBQWlCQyxtQkFBbUIsRUFBQyxxQkFDbEU7UUFFSjtRQUVBLElBQUl1QyxTQUFTQSxRQUFRLENBQUMrQixNQUFNLEdBQUd2RSxpQkFBaUJFLG1CQUFtQixFQUFFO1lBQ25FLE1BQU0sSUFBSVEsY0FDUixpQ0FBc0UsT0FBckNWLGlCQUFpQkUsbUJBQW1CLEVBQUMscUJBQ3RFO1FBRUo7UUFFQSxJQUFJLENBQUNzQyxTQUFTdUUsT0FBTyxJQUFJdkUsU0FBU3VFLE9BQU8sQ0FBQ3hDLE1BQU0sS0FBS3ZFLGlCQUFpQkssV0FBVyxFQUFFO1lBQ2pGLE1BQU0sSUFBSUssY0FDUiw4QkFBMkQsT0FBN0JWLGlCQUFpQkssV0FBVyxFQUFDLGFBQzNEO1FBRUo7UUFFQSx1QkFBdUI7UUFDdkJtQyxTQUFTdUUsT0FBTyxDQUFDQyxPQUFPLENBQUMsQ0FBQ0MsUUFBUWhEO1lBQ2hDLElBQUksQ0FBQ2dELFVBQVVBLE9BQU8xQyxNQUFNLEdBQUd2RSxpQkFBaUJHLGlCQUFpQixFQUFFO2dCQUNqRSxNQUFNLElBQUlPLGNBQ1IsVUFBd0NWLE9BQTlCaUUsUUFBUSxHQUFFLHNCQUF1RCxPQUFuQ2pFLGlCQUFpQkcsaUJBQWlCLEVBQUMsb0JBQzNFO1lBRUo7WUFFQSxJQUFJOEcsT0FBTzFDLE1BQU0sR0FBR3ZFLGlCQUFpQkksaUJBQWlCLEVBQUU7Z0JBQ3RELE1BQU0sSUFBSU0sY0FDUixVQUE0Q1YsT0FBbENpRSxRQUFRLEdBQUUsMEJBQTJELE9BQW5DakUsaUJBQWlCSSxpQkFBaUIsRUFBQyxxQkFDL0U7WUFFSjtRQUNGO1FBRUEsOEJBQThCO1FBQzlCLE1BQU04RyxnQkFBZ0IsSUFBSUMsSUFBSTNFLFNBQVN1RSxPQUFPLENBQUN2QixHQUFHLENBQUM0QixDQUFBQSxNQUFPQSxJQUFJakMsV0FBVyxHQUFHa0MsSUFBSTtRQUNoRixJQUFJSCxjQUFjSSxJQUFJLEtBQUs5RSxTQUFTdUUsT0FBTyxDQUFDeEMsTUFBTSxFQUFFO1lBQ2xELE1BQU0sSUFBSTdELGNBQWMsOEJBQThCO1FBQ3hEO1FBRUEsMEJBQTBCO1FBQzFCLElBQUksT0FBTzhCLFNBQVMrRSxhQUFhLEtBQUssWUFDbEMvRSxTQUFTK0UsYUFBYSxHQUFHLEtBQ3pCL0UsU0FBUytFLGFBQWEsSUFBSS9FLFNBQVN1RSxPQUFPLENBQUN4QyxNQUFNLEVBQUU7WUFDckQsTUFBTSxJQUFJN0QsY0FBYyxvQ0FBb0M7UUFDOUQ7UUFFQSxvQkFBb0I7UUFDcEIsTUFBTThHLGtCQUFrQnpILDREQUFrQkEsQ0FBQ3lGLEdBQUcsQ0FBQ2lDLENBQUFBLElBQUtBLEVBQUVoRSxFQUFFO1FBQ3hELElBQUksQ0FBQ2pCLFNBQVNDLFFBQVEsSUFBSSxDQUFDK0UsZ0JBQWdCdkUsUUFBUSxDQUFDVCxTQUFTQyxRQUFRLEdBQUc7WUFDdEUsTUFBTSxJQUFJL0IsY0FBYyw4QkFBOEI7UUFDeEQ7SUFDRjtJQUVBLGtCQUFrQjtJQUNWb0QsY0FBYzlCLFNBQXlCLEVBQVE7UUFDckQsSUFBSSxDQUFDUixXQUFXLENBQUMxQiwyREFBaUJBLENBQUNnQyxTQUFTLEVBQUVHLEtBQUtpRSxTQUFTLENBQUNsRTtJQUMvRDtJQUVRMEIsYUFBcUI7UUFDM0IsT0FBTyxLQUFtQmdFLE9BQWRuRSxLQUFLRCxHQUFHLElBQUcsS0FBMkMsT0FBeENvRSxLQUFLQyxNQUFNLEdBQUdDLFFBQVEsQ0FBQyxJQUFJQyxNQUFNLENBQUMsR0FBRztJQUNqRTtJQUVBLGtDQUFrQztJQUNsQ0MsWUFBWTlGLFNBQTBCLEVBQVU7UUFDOUMsTUFBTStGLG9CQUFvQi9GLGFBQWEsSUFBSSxDQUFDSixZQUFZO1FBRXhELE1BQU1vRyxVQUFVO1lBQ2Q7WUFBTTtZQUFZO1lBQVk7WUFBWTtZQUFZO1lBQ3REO1lBQWtCO1lBQVk7WUFBYztZQUFRO1lBQVk7WUFDaEU7WUFBYztTQUNmO1FBRUQsTUFBTUMsVUFBVTtZQUNkRCxRQUFRRSxJQUFJLENBQUM7ZUFDVkgsa0JBQWtCdkMsR0FBRyxDQUFDckIsQ0FBQUEsSUFBSztvQkFDNUJBLEVBQUVWLEVBQUU7b0JBQ0gsSUFBa0MsT0FBL0JVLEVBQUUzQixRQUFRLENBQUMyRixPQUFPLENBQUMsTUFBTSxPQUFNO29CQUNsQyxJQUFvQyxPQUFqQ2hFLEVBQUU0QyxPQUFPLENBQUMsRUFBRSxDQUFDb0IsT0FBTyxDQUFDLE1BQU0sT0FBTTtvQkFDcEMsSUFBb0MsT0FBakNoRSxFQUFFNEMsT0FBTyxDQUFDLEVBQUUsQ0FBQ29CLE9BQU8sQ0FBQyxNQUFNLE9BQU07b0JBQ3BDLElBQW9DLE9BQWpDaEUsRUFBRTRDLE9BQU8sQ0FBQyxFQUFFLENBQUNvQixPQUFPLENBQUMsTUFBTSxPQUFNO29CQUNwQyxJQUFvQyxPQUFqQ2hFLEVBQUU0QyxPQUFPLENBQUMsRUFBRSxDQUFDb0IsT0FBTyxDQUFDLE1BQU0sT0FBTTtvQkFDckNoRSxFQUFFb0QsYUFBYSxHQUFHO29CQUNsQnBELEVBQUUxQixRQUFRO29CQUNWMEIsRUFBRXpCLFVBQVU7b0JBQ1p5QixFQUFFeEIsSUFBSTtvQkFDTCxJQUF5QyxPQUF0QyxDQUFDd0IsRUFBRWlFLE9BQU8sSUFBSSxFQUFDLEVBQUdELE9BQU8sQ0FBQyxNQUFNLE9BQU07b0JBQ3pDLElBQTRCLE9BQXpCLENBQUNoRSxFQUFFckIsSUFBSSxJQUFJLEVBQUUsRUFBRW9GLElBQUksQ0FBQyxNQUFLO29CQUM3QixJQUFJM0UsS0FBS1ksRUFBRVIsU0FBUyxFQUFFMEUsV0FBVztvQkFDakMsSUFBSTlFLEtBQUtZLEVBQUVQLFNBQVMsRUFBRXlFLFdBQVc7aUJBQ2xDLENBQUNILElBQUksQ0FBQztTQUNSO1FBRUQsd0NBQXdDO1FBQ3hDLE9BQU8sV0FBV0QsUUFBUUMsSUFBSSxDQUFDO0lBQ2pDO0lBRUEsTUFBTUksY0FBY0MsVUFBa0IsRUFBZ0M7UUFDcEUsTUFBTUMsUUFBUUQsV0FBV0UsS0FBSyxDQUFDLE1BQU1sRyxNQUFNLENBQUNtRyxDQUFBQSxPQUFRQSxLQUFLckIsSUFBSTtRQUM3RCxJQUFJbUIsTUFBTWpFLE1BQU0sR0FBRyxHQUFHO1lBQ3BCLE1BQU0sSUFBSTdELGNBQWMsNERBQTREO1FBQ3RGO1FBRUEsTUFBTXNILFVBQVVRLEtBQUssQ0FBQyxFQUFFLENBQUNDLEtBQUssQ0FBQyxLQUFLakQsR0FBRyxDQUFDbUQsQ0FBQUEsSUFBS0EsRUFBRXRCLElBQUksR0FBR2MsT0FBTyxDQUFDLE1BQU07UUFDcEUsTUFBTVMsWUFBWUosTUFBTUssS0FBSyxDQUFDO1FBRTlCLE1BQU1DLFVBQStCO1lBQ25DbEUsU0FBUztZQUNUQyxnQkFBZ0I7WUFDaEJDLFlBQVk7WUFDWkMsUUFBUSxFQUFFO1FBQ1o7UUFFQSxNQUFNZ0UsaUJBQWlDLEVBQUU7UUFDekMsTUFBTUMsb0JBQW9CLElBQUksQ0FBQ3BILFlBQVk7UUFFM0MsSUFBSyxJQUFJcUgsSUFBSSxHQUFHQSxJQUFJTCxVQUFVckUsTUFBTSxFQUFFMEUsSUFBSztZQUN6QyxJQUFJO2dCQUNGLE1BQU1DLFNBQVMsSUFBSSxDQUFDQyxZQUFZLENBQUNQLFNBQVMsQ0FBQ0ssRUFBRTtnQkFDN0MsSUFBSUMsT0FBTzNFLE1BQU0sR0FBRyxHQUFHO29CQUNyQnVFLFFBQVEvRCxNQUFNLENBQUNsQixJQUFJLENBQUMsUUFBYyxPQUFOb0YsSUFBSSxHQUFFO29CQUNsQ0gsUUFBUWhFLFVBQVU7b0JBQ2xCO2dCQUNGO2dCQUVBLE1BQU10QyxXQUF5QjtvQkFDN0JpQixJQUFJeUYsTUFBTSxDQUFDLEVBQUUsSUFBSSxJQUFJLENBQUN4RixVQUFVO29CQUNoQ2xCLFVBQVUwRyxNQUFNLENBQUMsRUFBRTtvQkFDbkJuQyxTQUFTO3dCQUFDbUMsTUFBTSxDQUFDLEVBQUU7d0JBQUVBLE1BQU0sQ0FBQyxFQUFFO3dCQUFFQSxNQUFNLENBQUMsRUFBRTt3QkFBRUEsTUFBTSxDQUFDLEVBQUU7cUJBQUM7b0JBQ3JEM0IsZUFBZTZCLFNBQVNGLE1BQU0sQ0FBQyxFQUFFLElBQUk7b0JBQ3JDekcsVUFBVXlHLE1BQU0sQ0FBQyxFQUFFO29CQUNuQnhHLFlBQVl3RyxNQUFNLENBQUMsRUFBRTtvQkFDckJ2RyxNQUFPdUcsTUFBTSxDQUFDLEVBQUUsSUFBSTtvQkFDcEJkLFNBQVNjLE1BQU0sQ0FBQyxHQUFHLElBQUlHO29CQUN2QnZHLE1BQU1vRyxNQUFNLENBQUMsR0FBRyxHQUFHQSxNQUFNLENBQUMsR0FBRyxDQUFDVCxLQUFLLENBQUMsS0FBS2xHLE1BQU0sQ0FBQytHLENBQUFBLElBQUtBLEVBQUVqQyxJQUFJLE1BQU1nQztvQkFDakUxRixXQUFXdUYsTUFBTSxDQUFDLEdBQUcsR0FBRyxJQUFJM0YsS0FBSzJGLE1BQU0sQ0FBQyxHQUFHLEVBQUVLLE9BQU8sS0FBS2hHLEtBQUtELEdBQUc7b0JBQ2pFTSxXQUFXc0YsTUFBTSxDQUFDLEdBQUcsR0FBRyxJQUFJM0YsS0FBSzJGLE1BQU0sQ0FBQyxHQUFHLEVBQUVLLE9BQU8sS0FBS2hHLEtBQUtELEdBQUc7Z0JBQ25FO2dCQUVBLHdCQUF3QjtnQkFDeEIsSUFBSSxDQUFDRCxnQkFBZ0IsQ0FBQ2I7Z0JBRXRCLHVCQUF1QjtnQkFDdkIsTUFBTXNELGdCQUFnQmtELGtCQUFrQjlFLFNBQVMsQ0FBQ0MsQ0FBQUEsSUFBS0EsRUFBRVYsRUFBRSxLQUFLakIsU0FBU2lCLEVBQUU7Z0JBQzNFLElBQUlxQyxpQkFBaUIsR0FBRztvQkFDdEIsMkJBQTJCO29CQUMzQmtELGlCQUFpQixDQUFDbEQsY0FBYyxHQUFHdEQ7Z0JBQ3JDLE9BQU87b0JBQ0x1RyxlQUFlbEYsSUFBSSxDQUFDckI7Z0JBQ3RCO2dCQUVBc0csUUFBUWpFLGNBQWM7WUFDeEIsRUFBRSxPQUFPdkQsT0FBTztnQkFDZHdILFFBQVEvRCxNQUFNLENBQUNsQixJQUFJLENBQUMsUUFBa0J2QyxPQUFWMkgsSUFBSSxHQUFFLE1BQTZELE9BQXpEM0gsaUJBQWlCWCxRQUFRVyxNQUFNVixPQUFPLEdBQUc7Z0JBQy9Fa0ksUUFBUWhFLFVBQVU7WUFDcEI7UUFDRjtRQUVBLDJCQUEyQjtRQUMzQixJQUFJaUUsZUFBZXhFLE1BQU0sR0FBRyxHQUFHO1lBQzdCLE1BQU1pRixlQUFlO21CQUFJUjttQkFBc0JEO2FBQWU7WUFDOUQsSUFBSSxDQUFDakYsYUFBYSxDQUFDMEY7UUFDckI7UUFFQVYsUUFBUWxFLE9BQU8sR0FBR2tFLFFBQVFoRSxVQUFVLEtBQUs7UUFDekMsT0FBT2dFO0lBQ1Q7SUFFUUssYUFBYVQsSUFBWSxFQUFZO1FBQzNDLE1BQU1lLFNBQW1CLEVBQUU7UUFDM0IsSUFBSUMsVUFBVTtRQUNkLElBQUlDLFdBQVc7UUFFZixJQUFLLElBQUlWLElBQUksR0FBR0EsSUFBSVAsS0FBS25FLE1BQU0sRUFBRTBFLElBQUs7WUFDcEMsTUFBTVcsT0FBT2xCLElBQUksQ0FBQ08sRUFBRTtZQUVwQixJQUFJVyxTQUFTLEtBQUs7Z0JBQ2hCLElBQUlELFlBQVlqQixJQUFJLENBQUNPLElBQUksRUFBRSxLQUFLLEtBQUs7b0JBQ25DUyxXQUFXO29CQUNYVCxLQUFJLGtCQUFrQjtnQkFDeEIsT0FBTztvQkFDTFUsV0FBVyxDQUFDQTtnQkFDZDtZQUNGLE9BQU8sSUFBSUMsU0FBUyxPQUFPLENBQUNELFVBQVU7Z0JBQ3BDRixPQUFPNUYsSUFBSSxDQUFDNkYsUUFBUXJDLElBQUk7Z0JBQ3hCcUMsVUFBVTtZQUNaLE9BQU87Z0JBQ0xBLFdBQVdFO1lBQ2I7UUFDRjtRQUVBSCxPQUFPNUYsSUFBSSxDQUFDNkYsUUFBUXJDLElBQUk7UUFDeEIsT0FBT29DO0lBQ1Q7SUFFUTFILDJCQUEyQztRQUNqRCwyREFBMkQ7UUFDM0QsTUFBTThILGtCQUFrQztZQUN0QztnQkFDRXBHLElBQUk7Z0JBQ0pqQixVQUFVO2dCQUNWdUUsU0FBUztvQkFBQztvQkFBYTtvQkFBVTtvQkFBVztpQkFBVztnQkFDdkRRLGVBQWU7Z0JBQ2Y5RSxVQUFVO2dCQUNWQyxZQUFZO2dCQUNaQyxNQUFNO2dCQUNOeUYsU0FBUztnQkFDVHRGLE1BQU07b0JBQUM7b0JBQWdCO29CQUFTO2lCQUFRO2dCQUN4Q2EsV0FBV0osS0FBS0QsR0FBRyxLQUFLO2dCQUN4Qk0sV0FBV0wsS0FBS0QsR0FBRyxLQUFLO1lBQzFCO1NBRUQ7UUFFRCxJQUFJLENBQUNRLGFBQWEsQ0FBQytGO1FBQ25CLE9BQU9BO0lBQ1Q7SUFFQSxtQ0FBbUM7SUFDbkNDLGVBQXVCO1FBQ3JCLE1BQU1DLFNBQVM7WUFDYi9ILFdBQVcsSUFBSSxDQUFDSixZQUFZO1lBQzVCNEUsVUFBVSxJQUFJLENBQUNKLFdBQVc7WUFDMUJSLFFBQVEsSUFBSSxDQUFDQyxTQUFTO1lBQ3RCbUUsV0FBV3pHLEtBQUtELEdBQUc7WUFDbkIyRyxTQUFTO1FBQ1g7UUFFQSxPQUFPaEksS0FBS2lFLFNBQVMsQ0FBQzZELFFBQVEsTUFBTTtJQUN0QztJQUVBRyxrQkFBa0JDLFVBQWtCLEVBQXVCO1FBQ3pELElBQUk7WUFDRixNQUFNSixTQUFTOUgsS0FBS0MsS0FBSyxDQUFDaUk7WUFFMUIsSUFBSSxDQUFDSixPQUFPL0gsU0FBUyxJQUFJLENBQUNHLE1BQU1DLE9BQU8sQ0FBQzJILE9BQU8vSCxTQUFTLEdBQUc7Z0JBQ3pELE1BQU0sSUFBSXRCLGNBQWMsa0RBQWtEO1lBQzVFO1lBRUEsbUNBQW1DO1lBQ25DcUosT0FBTy9ILFNBQVMsQ0FBQ2dGLE9BQU8sQ0FBQyxDQUFDN0MsR0FBUUY7Z0JBQ2hDLElBQUk7b0JBQ0YsSUFBSSxDQUFDWixnQkFBZ0IsQ0FBQ2M7Z0JBQ3hCLEVBQUUsT0FBTzdDLE9BQU87b0JBQ2QsTUFBTSxJQUFJWixjQUNSLDZCQUF1Q1ksT0FBVjJDLE9BQU0sTUFBNkQsT0FBekQzQyxpQkFBaUJYLFFBQVFXLE1BQU1WLE9BQU8sR0FBRyxrQkFDaEY7Z0JBRUo7WUFDRjtZQUVBLHVDQUF1QztZQUN2QyxNQUFNd0osZ0JBQWdCLElBQUksQ0FBQ04sWUFBWTtZQUN2QyxJQUFJLENBQUN0SSxXQUFXLENBQUMxQiwyREFBaUJBLENBQUN1SyxNQUFNLEVBQUVEO1lBRTNDLGVBQWU7WUFDZixJQUFJLENBQUN0RyxhQUFhLENBQUNpRyxPQUFPL0gsU0FBUztZQUNuQyxJQUFJK0gsT0FBT3ZELFFBQVEsRUFBRTtnQkFDbkIsSUFBSSxDQUFDaEYsV0FBVyxDQUFDMUIsMkRBQWlCQSxDQUFDdUcsUUFBUSxFQUFFcEUsS0FBS2lFLFNBQVMsQ0FBQzZELE9BQU92RCxRQUFRO1lBQzdFO1lBQ0EsSUFBSXVELE9BQU9uRSxNQUFNLEVBQUU7Z0JBQ2pCLElBQUksQ0FBQ3BFLFdBQVcsQ0FBQzFCLDJEQUFpQkEsQ0FBQ21HLE1BQU0sRUFBRWhFLEtBQUtpRSxTQUFTLENBQUM2RCxPQUFPbkUsTUFBTTtZQUN6RTtZQUVBLE9BQU87Z0JBQ0xoQixTQUFTO2dCQUNUQyxnQkFBZ0JrRixPQUFPL0gsU0FBUyxDQUFDdUMsTUFBTTtnQkFDdkNPLFlBQVk7Z0JBQ1pDLFFBQVEsRUFBRTtZQUNaO1FBQ0YsRUFBRSxPQUFPekQsT0FBTztZQUNkLE1BQU0sSUFBSVosY0FDUiw2QkFBc0YsT0FBekRZLGlCQUFpQlgsUUFBUVcsTUFBTVYsT0FBTyxHQUFHLGtCQUN0RTtRQUVKO0lBQ0Y7SUFFQSxxQ0FBcUM7SUFDckMwSixjQUFjQyxPQUFlLEVBQUVDLFlBQTBDLEVBQVE7UUFDL0UsSUFBSSxDQUFDQyxZQUFZO1FBRWpCLElBQUksQ0FBQ0MsYUFBYSxHQUFHQyxZQUFZO1lBQy9CLElBQUk7Z0JBQ0YsTUFBTUMsWUFBWUo7Z0JBQ2xCLElBQUlJLFVBQVVwSSxRQUFRLElBQUlvSSxVQUFVcEksUUFBUSxDQUFDK0IsTUFBTSxHQUFHLEdBQUc7b0JBQ3ZELE1BQU1vQixRQUF1Qjt3QkFDM0JsQyxJQUFJOEc7d0JBQ0ovSCxVQUFVb0ksVUFBVXBJLFFBQVEsSUFBSTt3QkFDaEN1RSxTQUFTNkQsVUFBVTdELE9BQU8sSUFBSTs0QkFBQzs0QkFBSTs0QkFBSTs0QkFBSTt5QkFBRzt3QkFDOUNRLGVBQWVxRCxVQUFVckQsYUFBYSxJQUFJO3dCQUMxQzlFLFVBQVVtSSxVQUFVbkksUUFBUSxJQUFJO3dCQUNoQ0MsWUFBWWtJLFVBQVVsSSxVQUFVLElBQUk7d0JBQ3BDQyxNQUFNaUksVUFBVWpJLElBQUksSUFBSTt3QkFDeEJ5RixTQUFTd0MsVUFBVXhDLE9BQU87d0JBQzFCdEYsTUFBTThILFVBQVU5SCxJQUFJO3dCQUNwQmtELFdBQVd6QyxLQUFLRCxHQUFHO29CQUNyQjtvQkFFQSxJQUFJLENBQUNvQyxTQUFTLENBQUNDO2dCQUNqQjtZQUNGLEVBQUUsT0FBT3JFLE9BQU87Z0JBQ2RDLFFBQVFELEtBQUssQ0FBQyxxQkFBcUJBO1lBQ3JDO1FBQ0YsR0FBR3RCLGlCQUFpQlMsa0JBQWtCO0lBQ3hDO0lBRUFnSyxlQUFxQjtRQUNuQixJQUFJLElBQUksQ0FBQ0MsYUFBYSxFQUFFO1lBQ3RCRyxjQUFjLElBQUksQ0FBQ0gsYUFBYTtZQUNoQyxJQUFJLENBQUNBLGFBQWEsR0FBRztRQUN2QjtJQUNGO0lBRUEsMkJBQTJCO0lBQzNCNUMsWUFBWUMsaUJBQWtDLEVBQVU7UUFDdEQsTUFBTS9GLFlBQVkrRixxQkFBcUIsSUFBSSxDQUFDbkcsWUFBWTtRQUN4RCxNQUFNb0csVUFBVTtZQUNkO1lBQ0E7WUFDQTtZQUNBO1lBQ0E7WUFDQTtZQUNBO1lBQ0E7WUFDQTtZQUNBO1lBQ0E7WUFDQTtZQUNBO1lBQ0E7U0FDRDtRQUVELE1BQU1DLFVBQVU7WUFBQ0QsUUFBUUUsSUFBSSxDQUFDO1NBQUs7UUFFbkNsRyxVQUFVZ0YsT0FBTyxDQUFDeEUsQ0FBQUE7Z0JBSVZBLG9CQUNBQSxxQkFDQUEscUJBQ0FBO1lBTk4sTUFBTXNJLE1BQU07Z0JBQ1Z0SSxTQUFTaUIsRUFBRTtnQkFDVixJQUF5QyxPQUF0Q2pCLFNBQVNBLFFBQVEsQ0FBQzJGLE9BQU8sQ0FBQyxNQUFNLE9BQU07Z0JBQ3pDLElBQWtELE9BQS9DM0YsRUFBQUEscUJBQUFBLFNBQVN1RSxPQUFPLENBQUMsRUFBRSxjQUFuQnZFLHlDQUFBQSxtQkFBcUIyRixPQUFPLENBQUMsTUFBTSxVQUFTLElBQUc7Z0JBQ2xELElBQWtELE9BQS9DM0YsRUFBQUEsc0JBQUFBLFNBQVN1RSxPQUFPLENBQUMsRUFBRSxjQUFuQnZFLDBDQUFBQSxvQkFBcUIyRixPQUFPLENBQUMsTUFBTSxVQUFTLElBQUc7Z0JBQ2xELElBQWtELE9BQS9DM0YsRUFBQUEsc0JBQUFBLFNBQVN1RSxPQUFPLENBQUMsRUFBRSxjQUFuQnZFLDBDQUFBQSxvQkFBcUIyRixPQUFPLENBQUMsTUFBTSxVQUFTLElBQUc7Z0JBQ2xELElBQWtELE9BQS9DM0YsRUFBQUEsc0JBQUFBLFNBQVN1RSxPQUFPLENBQUMsRUFBRSxjQUFuQnZFLDBDQUFBQSxvQkFBcUIyRixPQUFPLENBQUMsTUFBTSxVQUFTLElBQUc7Z0JBQ25EM0YsU0FBUytFLGFBQWEsR0FBRztnQkFDekIvRSxTQUFTQyxRQUFRO2dCQUNqQkQsU0FBU0UsVUFBVTtnQkFDbkJGLFNBQVNHLElBQUk7Z0JBQ1osSUFBZ0QsT0FBN0MsQ0FBQ0gsU0FBUzRGLE9BQU8sSUFBSSxFQUFDLEVBQUdELE9BQU8sQ0FBQyxNQUFNLE9BQU07Z0JBQ2hELElBQW1DLE9BQWhDLENBQUMzRixTQUFTTSxJQUFJLElBQUksRUFBRSxFQUFFb0YsSUFBSSxDQUFDLE1BQUs7Z0JBQ3BDLElBQUkzRSxLQUFLZixTQUFTbUIsU0FBUyxFQUFFMEUsV0FBVztnQkFDeEMsSUFBSTlFLEtBQUtmLFNBQVNvQixTQUFTLEVBQUV5RSxXQUFXO2FBQ3pDO1lBQ0RKLFFBQVFwRSxJQUFJLENBQUNpSCxJQUFJNUMsSUFBSSxDQUFDO1FBQ3hCO1FBRUEsT0FBT0QsUUFBUUMsSUFBSSxDQUFDO0lBQ3RCO0lBRUEsb0JBQW9CO0lBQ3BCNkMsY0FBb0I7UUFDbEIsSUFBSTtZQUNGLE1BQU14QyxhQUFhLElBQUksQ0FBQ1QsV0FBVztZQUNuQyxNQUFNa0QsT0FBTyxJQUFJQyxLQUFLO2dCQUFDMUM7YUFBVyxFQUFFO2dCQUFFNUYsTUFBTTtZQUEwQjtZQUN0RSxNQUFNdUksT0FBT0MsU0FBU0MsYUFBYSxDQUFDO1lBRXBDLElBQUlGLEtBQUtHLFFBQVEsS0FBS2hDLFdBQVc7Z0JBQy9CLE1BQU1pQyxNQUFNQyxJQUFJQyxlQUFlLENBQUNSO2dCQUNoQ0UsS0FBS08sWUFBWSxDQUFDLFFBQVFIO2dCQUMxQkosS0FBS08sWUFBWSxDQUFDLFlBQVksc0JBQTZELE9BQXZDLElBQUlsSSxPQUFPOEUsV0FBVyxHQUFHSSxLQUFLLENBQUMsSUFBSSxDQUFDLEVBQUUsRUFBQztnQkFDM0Z5QyxLQUFLUSxLQUFLLENBQUNDLFVBQVUsR0FBRztnQkFDeEJSLFNBQVNTLElBQUksQ0FBQ0MsV0FBVyxDQUFDWDtnQkFDMUJBLEtBQUtZLEtBQUs7Z0JBQ1ZYLFNBQVNTLElBQUksQ0FBQ0csV0FBVyxDQUFDYjtnQkFDMUJLLElBQUlTLGVBQWUsQ0FBQ1Y7WUFDdEI7UUFDRixFQUFFLE9BQU9oSyxPQUFPO1lBQ2QsTUFBTSxJQUFJWixjQUFjLCtCQUErQjtRQUN6RDtJQUNGO0lBRUEsb0JBQW9CO0lBQ3BCdUwsU0FBUzFELFVBQWtCLEVBQTREO1FBQ3JGLE1BQU1DLFFBQVFELFdBQVdFLEtBQUssQ0FBQyxNQUFNbEcsTUFBTSxDQUFDbUcsQ0FBQUEsT0FBUUEsS0FBS3JCLElBQUk7UUFDN0QsTUFBTXRDLFNBQW1CLEVBQUU7UUFDM0IsTUFBTS9DLFlBQXFDLEVBQUU7UUFFN0MsSUFBSXdHLE1BQU1qRSxNQUFNLEdBQUcsR0FBRztZQUNwQlEsT0FBT2xCLElBQUksQ0FBQztZQUNaLE9BQU87Z0JBQUU3QjtnQkFBVytDO1lBQU87UUFDN0I7UUFFQSxrQkFBa0I7UUFDbEIsTUFBTTZELFlBQVlKLE1BQU1LLEtBQUssQ0FBQztRQUU5QkQsVUFBVTVCLE9BQU8sQ0FBQyxDQUFDMEIsTUFBTXpFO1lBQ3ZCLElBQUk7Z0JBQ0YsTUFBTWlGLFNBQVMsSUFBSSxDQUFDQyxZQUFZLENBQUNUO2dCQUVqQyxJQUFJUSxPQUFPM0UsTUFBTSxHQUFHLEdBQUc7b0JBQ3JCUSxPQUFPbEIsSUFBSSxDQUFDLE9BQWlCLE9BQVZJLFFBQVEsR0FBRTtvQkFDN0I7Z0JBQ0Y7Z0JBRUEsTUFBTSxDQUFDUixJQUFJakIsVUFBVTBKLE1BQU1DLE1BQU1DLE1BQU1DLE1BQU05RSxlQUFlOUUsVUFBVUMsWUFBWUMsTUFBTXlGLFNBQVN0RixNQUFNYSxXQUFXQyxVQUFVLEdBQUdzRjtnQkFFL0gsMkJBQTJCO2dCQUMzQixJQUFJLEVBQUMxRyxxQkFBQUEsK0JBQUFBLFNBQVU2RSxJQUFJLEtBQUk7b0JBQ3JCdEMsT0FBT2xCLElBQUksQ0FBQyxPQUFpQixPQUFWSSxRQUFRLEdBQUU7b0JBQzdCO2dCQUNGO2dCQUVBLElBQUksRUFBQ2lJLGlCQUFBQSwyQkFBQUEsS0FBTTdFLElBQUksT0FBTSxFQUFDOEUsaUJBQUFBLDJCQUFBQSxLQUFNOUUsSUFBSSxPQUFNLEVBQUMrRSxpQkFBQUEsMkJBQUFBLEtBQU0vRSxJQUFJLE9BQU0sRUFBQ2dGLGlCQUFBQSwyQkFBQUEsS0FBTWhGLElBQUksS0FBSTtvQkFDcEV0QyxPQUFPbEIsSUFBSSxDQUFDLE9BQWlCLE9BQVZJLFFBQVEsR0FBRTtvQkFDN0I7Z0JBQ0Y7Z0JBRUEsTUFBTXFJLG1CQUFtQmxELFNBQVM3QixpQkFBaUIsRUFBRSw2QkFBNkI7O2dCQUNsRixJQUFJZ0YsTUFBTUQscUJBQXFCQSxtQkFBbUIsS0FBS0EsbUJBQW1CLEdBQUc7b0JBQzNFdkgsT0FBT2xCLElBQUksQ0FBQyxPQUFpQixPQUFWSSxRQUFRLEdBQUU7b0JBQzdCO2dCQUNGO2dCQUVBLElBQUksRUFBQ3hCLHFCQUFBQSwrQkFBQUEsU0FBVTRFLElBQUksS0FBSTtvQkFDckJ0QyxPQUFPbEIsSUFBSSxDQUFDLE9BQWlCLE9BQVZJLFFBQVEsR0FBRTtvQkFDN0I7Z0JBQ0Y7Z0JBRUEsSUFBSSxDQUFDO29CQUFDO29CQUFZO29CQUFnQjtpQkFBVyxDQUFDaEIsUUFBUSxDQUFDUCxhQUFhO29CQUNsRXFDLE9BQU9sQixJQUFJLENBQUMsT0FBaUIsT0FBVkksUUFBUSxHQUFFO29CQUM3QjtnQkFDRjtnQkFFQSxJQUFJLENBQUM7b0JBQUM7b0JBQVc7aUJBQVEsQ0FBQ2hCLFFBQVEsQ0FBQ04sT0FBTztvQkFDeENvQyxPQUFPbEIsSUFBSSxDQUFDLE9BQWlCLE9BQVZJLFFBQVEsR0FBRTtvQkFDN0I7Z0JBQ0Y7Z0JBRUEsTUFBTXVJLGVBQXNDO29CQUMxQy9JLElBQUlBLE1BQU0sWUFBMEJRLE9BQWRWLEtBQUtELEdBQUcsSUFBRyxLQUFTLE9BQU5XO29CQUNwQ3pCLFVBQVVBLFNBQVM2RSxJQUFJO29CQUN2Qk4sU0FBUzt3QkFBQ21GLEtBQUs3RSxJQUFJO3dCQUFJOEUsS0FBSzlFLElBQUk7d0JBQUkrRSxLQUFLL0UsSUFBSTt3QkFBSWdGLEtBQUtoRixJQUFJO3FCQUFHO29CQUM3REUsZUFBZStFO29CQUNmN0osVUFBVUEsU0FBUzRFLElBQUk7b0JBQ3ZCM0UsWUFBWUE7b0JBQ1pDLE1BQU1BO29CQUNOeUYsU0FBU0EsQ0FBQUEsb0JBQUFBLDhCQUFBQSxRQUFTZixJQUFJLE9BQU1nQztvQkFDNUJ2RyxNQUFNQSxPQUFPQSxLQUFLMkYsS0FBSyxDQUFDLEtBQUtqRCxHQUFHLENBQUN4QyxDQUFBQSxNQUFPQSxJQUFJcUUsSUFBSSxJQUFJOUUsTUFBTSxDQUFDa0ssV0FBVyxFQUFFO29CQUN4RTlJLFdBQVdBLFlBQVksSUFBSUosS0FBS0ksV0FBVzRGLE9BQU8sS0FBS2hHLEtBQUtELEdBQUc7b0JBQy9ETSxXQUFXQSxZQUFZLElBQUlMLEtBQUtLLFdBQVcyRixPQUFPLEtBQUtoRyxLQUFLRCxHQUFHO2dCQUNqRTtnQkFFQXRCLFVBQVU2QixJQUFJLENBQUMySTtZQUNqQixFQUFFLE9BQU9sTCxPQUFPO2dCQUNkeUQsT0FBT2xCLElBQUksQ0FBQyxPQUFxQnZDLE9BQWQyQyxRQUFRLEdBQUUsTUFBMkQsT0FBdkQzQyxpQkFBaUJYLFFBQVFXLE1BQU1WLE9BQU8sR0FBRztZQUM1RTtRQUNGO1FBRUEsT0FBTztZQUFFb0I7WUFBVytDO1FBQU87SUFDN0I7SUFFQSxzREFBc0Q7SUFDOUNvRSxhQUFhVCxJQUFZLEVBQVk7UUFDM0MsTUFBTWUsU0FBbUIsRUFBRTtRQUMzQixJQUFJQyxVQUFVO1FBQ2QsSUFBSUMsV0FBVztRQUNmLElBQUlWLElBQUk7UUFFUixNQUFPQSxJQUFJUCxLQUFLbkUsTUFBTSxDQUFFO1lBQ3RCLE1BQU1xRixPQUFPbEIsSUFBSSxDQUFDTyxFQUFFO1lBRXBCLElBQUlXLFNBQVMsS0FBSztnQkFDaEIsSUFBSUQsWUFBWWpCLElBQUksQ0FBQ08sSUFBSSxFQUFFLEtBQUssS0FBSztvQkFDbkMsZ0JBQWdCO29CQUNoQlMsV0FBVztvQkFDWFQsS0FBSztnQkFDUCxPQUFPO29CQUNMLHFCQUFxQjtvQkFDckJVLFdBQVcsQ0FBQ0E7b0JBQ1pWO2dCQUNGO1lBQ0YsT0FBTyxJQUFJVyxTQUFTLE9BQU8sQ0FBQ0QsVUFBVTtnQkFDcEMsZUFBZTtnQkFDZkYsT0FBTzVGLElBQUksQ0FBQzZGO2dCQUNaQSxVQUFVO2dCQUNWVDtZQUNGLE9BQU87Z0JBQ0xTLFdBQVdFO2dCQUNYWDtZQUNGO1FBQ0Y7UUFFQVEsT0FBTzVGLElBQUksQ0FBQzZGLFVBQVMsaUJBQWlCO1FBQ3RDLE9BQU9EO0lBQ1Q7SUFFQSxrQkFBa0I7SUFDbEJuQixjQUFjQyxVQUFrQixFQUF1QjtRQUNyRCxJQUFJO1lBQ0YsTUFBTSxFQUFFdkcsU0FBUyxFQUFFK0MsTUFBTSxFQUFFLEdBQUcsSUFBSSxDQUFDa0gsUUFBUSxDQUFDMUQ7WUFFNUMsSUFBSXhELE9BQU9SLE1BQU0sR0FBRyxHQUFHO2dCQUNyQixPQUFPO29CQUNMSyxTQUFTO29CQUNUQyxnQkFBZ0I7b0JBQ2hCQyxZQUFZQyxPQUFPUixNQUFNO29CQUN6QlE7Z0JBQ0Y7WUFDRjtZQUVBLElBQUkySCxlQUFlO1lBQ25CLE1BQU1DLGVBQXlCLEVBQUU7WUFFakMzSyxVQUFVZ0YsT0FBTyxDQUFDLENBQUN3RixjQUFjdkk7Z0JBQy9CLElBQUk7b0JBQ0YsTUFBTTJJLGVBQTZCO3dCQUNqQ25KLElBQUkrSSxhQUFhL0ksRUFBRTt3QkFDbkJqQixVQUFVZ0ssYUFBYWhLLFFBQVE7d0JBQy9CdUUsU0FBU3lGLGFBQWF6RixPQUFPO3dCQUM3QlEsZUFBZWlGLGFBQWFqRixhQUFhO3dCQUN6QzlFLFVBQVUrSixhQUFhL0osUUFBUTt3QkFDL0JDLFlBQVk4SixhQUFhOUosVUFBVTt3QkFDbkNDLE1BQU02SixhQUFhN0osSUFBSTt3QkFDdkJ5RixTQUFTb0UsYUFBYXBFLE9BQU87d0JBQzdCdEYsTUFBTTBKLGFBQWExSixJQUFJLElBQUksRUFBRTt3QkFDN0JhLFdBQVc2SSxhQUFhN0ksU0FBUzt3QkFDakNDLFdBQVc0SSxhQUFhNUksU0FBUztvQkFDbkM7b0JBRUEsaUNBQWlDO29CQUNqQyxNQUFNaUosYUFBYSxJQUFJLENBQUN4SixnQkFBZ0IsQ0FBQ3VKO29CQUN6QyxJQUFJLENBQUNDLFdBQVdDLE9BQU8sRUFBRTt3QkFDdkJILGFBQWE5SSxJQUFJLENBQUMsWUFBMEJnSixPQUFkNUksUUFBUSxHQUFFLE1BQWlDLE9BQTdCNEksV0FBVzlILE1BQU0sQ0FBQ21ELElBQUksQ0FBQzt3QkFDbkU7b0JBQ0Y7b0JBRUEsSUFBSSxDQUFDOUUsWUFBWSxDQUFDd0o7b0JBQ2xCRjtnQkFDRixFQUFFLE9BQU9wTCxPQUFPO29CQUNkcUwsYUFBYTlJLElBQUksQ0FBQyxZQUEwQnZDLE9BQWQyQyxRQUFRLEdBQUUsTUFBMEQsT0FBdEQzQyxpQkFBaUJYLFFBQVFXLE1BQU1WLE9BQU8sR0FBRztnQkFDdkY7WUFDRjtZQUVBLE9BQU87Z0JBQ0xnRSxTQUFTK0gsYUFBYXBJLE1BQU0sS0FBSztnQkFDakNNLGdCQUFnQjZIO2dCQUNoQjVILFlBQVk2SCxhQUFhcEksTUFBTTtnQkFDL0JRLFFBQVE0SDtZQUNWO1FBQ0YsRUFBRSxPQUFPckwsT0FBTztZQUNkLE9BQU87Z0JBQ0xzRCxTQUFTO2dCQUNUQyxnQkFBZ0I7Z0JBQ2hCQyxZQUFZO2dCQUNaQyxRQUFRO29CQUFDekQsaUJBQWlCWCxRQUFRVyxNQUFNVixPQUFPLEdBQUc7aUJBQWdCO1lBQ3BFO1FBQ0Y7SUFDRjs7YUFwMEJROEosZ0JBQXVDOztBQXEwQmpEO0FBRUEsNEJBQTRCO0FBQ3JCLE1BQU1xQyxrQkFBa0JoTSxnQkFBZ0JDLFdBQVcsR0FBRSIsInNvdXJjZXMiOlsiL1VzZXJzL2phc2VlbS9Eb2N1bWVudHMvR2l0SHViL1RlY2hrd2l6LXY3L2Zyb250ZW5kL3NyYy91dGlscy9xdWl6RGF0YU1hbmFnZXIudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgXG4gIFF1aXpRdWVzdGlvbiwgXG4gIFF1aXpDYXRlZ29yeSwgXG4gIFNlYXJjaEZpbHRlcnMsIFxuICBCdWxrT3BlcmF0aW9uUmVzdWx0LCBcbiAgUXVlc3Rpb25EcmFmdCxcbiAgUXVpek1hbmFnZW1lbnRTZXR0aW5ncyxcbiAgUVVJWl9TVE9SQUdFX0tFWVMsXG4gIERFRkFVTFRfQ0FURUdPUklFUyBcbn0gZnJvbSAnQC90eXBlcy9hZG1pbidcblxuLy8gRGF0YSB2YWxpZGF0aW9uIHNjaGVtYXNcbmV4cG9ydCBjb25zdCBWQUxJREFUSU9OX1JVTEVTID0ge1xuICBRVUVTVElPTl9NSU5fTEVOR1RIOiAxMCxcbiAgUVVFU1RJT05fTUFYX0xFTkdUSDogNTAwLFxuICBPUFRJT05fTUlOX0xFTkdUSDogMSxcbiAgT1BUSU9OX01BWF9MRU5HVEg6IDEwMCxcbiAgTUlOX09QVElPTlM6IDQsXG4gIE1BWF9PUFRJT05TOiA0LFxuICBNQVhfQlVMS19PUEVSQVRJT05TOiA1MCxcbiAgTUFYX0ZJTEVfU0laRTogNSAqIDEwMjQgKiAxMDI0LCAvLyA1TUJcbiAgQVVUT19TQVZFX0lOVEVSVkFMOiAzMDAwMCAvLyAzMCBzZWNvbmRzXG59IGFzIGNvbnN0XG5cbi8vIEVycm9yIHR5cGVzXG5leHBvcnQgY2xhc3MgUXVpekRhdGFFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgY29uc3RydWN0b3IobWVzc2FnZTogc3RyaW5nLCBwdWJsaWMgY29kZTogc3RyaW5nKSB7XG4gICAgc3VwZXIobWVzc2FnZSlcbiAgICB0aGlzLm5hbWUgPSAnUXVpekRhdGFFcnJvcidcbiAgfVxufVxuXG4vLyBVdGlsaXR5IGZ1bmN0aW9ucyBmb3IgbG9jYWxTdG9yYWdlIG9wZXJhdGlvbnNcbmNsYXNzIFF1aXpEYXRhTWFuYWdlciB7XG4gIHByaXZhdGUgc3RhdGljIGluc3RhbmNlOiBRdWl6RGF0YU1hbmFnZXJcbiAgcHJpdmF0ZSBhdXRvU2F2ZVRpbWVyOiBOb2RlSlMuVGltZW91dCB8IG51bGwgPSBudWxsXG5cbiAgc3RhdGljIGdldEluc3RhbmNlKCk6IFF1aXpEYXRhTWFuYWdlciB7XG4gICAgaWYgKCFRdWl6RGF0YU1hbmFnZXIuaW5zdGFuY2UpIHtcbiAgICAgIFF1aXpEYXRhTWFuYWdlci5pbnN0YW5jZSA9IG5ldyBRdWl6RGF0YU1hbmFnZXIoKVxuICAgIH1cbiAgICByZXR1cm4gUXVpekRhdGFNYW5hZ2VyLmluc3RhbmNlXG4gIH1cblxuICAvLyBTYWZlIGxvY2FsU3RvcmFnZSBvcGVyYXRpb25zIHdpdGggZXJyb3IgaGFuZGxpbmdcbiAgcHJpdmF0ZSBzYWZlR2V0SXRlbShrZXk6IHN0cmluZyk6IHN0cmluZyB8IG51bGwge1xuICAgIC8vIFJldHVybiBudWxsIGlmIG5vdCBvbiBjbGllbnQgc2lkZVxuICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgcmV0dXJuIG51bGxcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGxvY2FsU3RvcmFnZS5nZXRJdGVtKGtleSlcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcihgRXJyb3IgcmVhZGluZyBmcm9tIGxvY2FsU3RvcmFnZSBrZXkgJHtrZXl9OmAsIGVycm9yKVxuICAgICAgcmV0dXJuIG51bGxcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIHNhZmVTZXRJdGVtKGtleTogc3RyaW5nLCB2YWx1ZTogc3RyaW5nKTogYm9vbGVhbiB7XG4gICAgLy8gUmV0dXJuIGZhbHNlIGlmIG5vdCBvbiBjbGllbnQgc2lkZVxuICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKGtleSwgdmFsdWUpXG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKGBFcnJvciB3cml0aW5nIHRvIGxvY2FsU3RvcmFnZSBrZXkgJHtrZXl9OmAsIGVycm9yKVxuICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRE9NRXhjZXB0aW9uICYmIGVycm9yLmNvZGUgPT09IDIyKSB7XG4gICAgICAgIHRocm93IG5ldyBRdWl6RGF0YUVycm9yKCdTdG9yYWdlIHF1b3RhIGV4Y2VlZGVkLiBQbGVhc2UgY2xlYXIgc29tZSBkYXRhLicsICdRVU9UQV9FWENFRURFRCcpXG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG4gIH1cblxuICAvLyBRdWVzdGlvbiBDUlVEIG9wZXJhdGlvbnNcbiAgZ2V0UXVlc3Rpb25zKCk6IFF1aXpRdWVzdGlvbltdIHtcbiAgICBjb25zdCBkYXRhID0gdGhpcy5zYWZlR2V0SXRlbShRVUlaX1NUT1JBR0VfS0VZUy5RVUVTVElPTlMpXG4gICAgaWYgKCFkYXRhKSByZXR1cm4gdGhpcy5pbml0aWFsaXplV2l0aFNhbXBsZURhdGEoKVxuXG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHF1ZXN0aW9ucyA9IEpTT04ucGFyc2UoZGF0YSlcbiAgICAgIHJldHVybiBBcnJheS5pc0FycmF5KHF1ZXN0aW9ucykgPyBxdWVzdGlvbnMgOiBbXVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBwYXJzaW5nIHF1ZXN0aW9ucyBkYXRhOicsIGVycm9yKVxuICAgICAgcmV0dXJuIHRoaXMuaW5pdGlhbGl6ZVdpdGhTYW1wbGVEYXRhKClcbiAgICB9XG4gIH1cblxuICAvLyBHZXQgcXVlc3Rpb25zIHdpdGggZmlsdGVyaW5nIHN1cHBvcnRcbiAgZ2V0RmlsdGVyZWRRdWVzdGlvbnMoZmlsdGVycz86IHtcbiAgICBjYXRlZ29yeT86IHN0cmluZ1xuICAgIGRpZmZpY3VsdHk/OiAnYmVnaW5uZXInIHwgJ2ludGVybWVkaWF0ZScgfCAnYWR2YW5jZWQnXG4gICAgdHlwZT86ICdyZWd1bGFyJyB8ICdib251cydcbiAgICBzZWN0aW9uPzogJ29uYm9hcmRpbmcnIHwgJ2hvbWVwYWdlJyB8ICdjYXRlZ29yeScgfCAnZ2VuZXJhbCdcbiAgICBzdWJjYXRlZ29yeT86IHN0cmluZ1xuICAgIHRhZ3M/OiBzdHJpbmdbXVxuICB9KTogUXVpelF1ZXN0aW9uW10ge1xuICAgIGNvbnN0IHF1ZXN0aW9ucyA9IHRoaXMuZ2V0UXVlc3Rpb25zKClcblxuICAgIGlmICghZmlsdGVycykgcmV0dXJuIHF1ZXN0aW9uc1xuXG4gICAgcmV0dXJuIHF1ZXN0aW9ucy5maWx0ZXIocXVlc3Rpb24gPT4ge1xuICAgICAgaWYgKGZpbHRlcnMuY2F0ZWdvcnkgJiYgcXVlc3Rpb24uY2F0ZWdvcnkgIT09IGZpbHRlcnMuY2F0ZWdvcnkpIHJldHVybiBmYWxzZVxuICAgICAgaWYgKGZpbHRlcnMuZGlmZmljdWx0eSAmJiBxdWVzdGlvbi5kaWZmaWN1bHR5ICE9PSBmaWx0ZXJzLmRpZmZpY3VsdHkpIHJldHVybiBmYWxzZVxuICAgICAgaWYgKGZpbHRlcnMudHlwZSAmJiBxdWVzdGlvbi50eXBlICE9PSBmaWx0ZXJzLnR5cGUpIHJldHVybiBmYWxzZVxuICAgICAgaWYgKGZpbHRlcnMuc2VjdGlvbiAmJiBxdWVzdGlvbi5zZWN0aW9uICE9PSBmaWx0ZXJzLnNlY3Rpb24pIHJldHVybiBmYWxzZVxuICAgICAgaWYgKGZpbHRlcnMuc3ViY2F0ZWdvcnkgJiYgcXVlc3Rpb24uc3ViY2F0ZWdvcnkgIT09IGZpbHRlcnMuc3ViY2F0ZWdvcnkpIHJldHVybiBmYWxzZVxuICAgICAgaWYgKGZpbHRlcnMudGFncyAmJiAhZmlsdGVycy50YWdzLnNvbWUodGFnID0+IHF1ZXN0aW9uLnRhZ3M/LmluY2x1ZGVzKHRhZykpKSByZXR1cm4gZmFsc2VcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfSlcbiAgfVxuXG4gIC8vIEdldCBxdWVzdGlvbnMgYnkgc2VjdGlvblxuICBnZXRRdWVzdGlvbnNCeVNlY3Rpb24oc2VjdGlvbjogJ29uYm9hcmRpbmcnIHwgJ2hvbWVwYWdlJyB8ICdjYXRlZ29yeScgfCAnZ2VuZXJhbCcpOiBRdWl6UXVlc3Rpb25bXSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0RmlsdGVyZWRRdWVzdGlvbnMoeyBzZWN0aW9uIH0pXG4gIH1cblxuICAvLyBHZXQgcXVlc3Rpb25zIGJ5IGNhdGVnb3J5IGFuZCBzZWN0aW9uXG4gIGdldFF1ZXN0aW9uc0J5Q2F0ZWdvcnlBbmRTZWN0aW9uKGNhdGVnb3J5OiBzdHJpbmcsIHNlY3Rpb24/OiAnb25ib2FyZGluZycgfCAnaG9tZXBhZ2UnIHwgJ2NhdGVnb3J5JyB8ICdnZW5lcmFsJyk6IFF1aXpRdWVzdGlvbltdIHtcbiAgICByZXR1cm4gdGhpcy5nZXRGaWx0ZXJlZFF1ZXN0aW9ucyh7IGNhdGVnb3J5LCBzZWN0aW9uIH0pXG4gIH1cblxuICBzYXZlUXVlc3Rpb24ocXVlc3Rpb246IE9taXQ8UXVpelF1ZXN0aW9uLCAnaWQnIHwgJ2NyZWF0ZWRBdCcgfCAndXBkYXRlZEF0Jz4pOiBRdWl6UXVlc3Rpb24ge1xuICAgIHRoaXMudmFsaWRhdGVRdWVzdGlvbihxdWVzdGlvbilcbiAgICBcbiAgICBjb25zdCBxdWVzdGlvbnMgPSB0aGlzLmdldFF1ZXN0aW9ucygpXG4gICAgY29uc3Qgbm93ID0gRGF0ZS5ub3coKVxuICAgIGNvbnN0IG5ld1F1ZXN0aW9uOiBRdWl6UXVlc3Rpb24gPSB7XG4gICAgICAuLi5xdWVzdGlvbixcbiAgICAgIGlkOiB0aGlzLmdlbmVyYXRlSWQoKSxcbiAgICAgIGNyZWF0ZWRBdDogbm93LFxuICAgICAgdXBkYXRlZEF0OiBub3dcbiAgICB9XG4gICAgXG4gICAgcXVlc3Rpb25zLnB1c2gobmV3UXVlc3Rpb24pXG4gICAgdGhpcy5zYXZlUXVlc3Rpb25zKHF1ZXN0aW9ucylcbiAgICByZXR1cm4gbmV3UXVlc3Rpb25cbiAgfVxuXG4gIHVwZGF0ZVF1ZXN0aW9uKGlkOiBzdHJpbmcsIHVwZGF0ZXM6IFBhcnRpYWw8T21pdDxRdWl6UXVlc3Rpb24sICdpZCcgfCAnY3JlYXRlZEF0Jz4+KTogUXVpelF1ZXN0aW9uIHtcbiAgICBjb25zdCBxdWVzdGlvbnMgPSB0aGlzLmdldFF1ZXN0aW9ucygpXG4gICAgY29uc3QgaW5kZXggPSBxdWVzdGlvbnMuZmluZEluZGV4KHEgPT4gcS5pZCA9PT0gaWQpXG4gICAgXG4gICAgaWYgKGluZGV4ID09PSAtMSkge1xuICAgICAgdGhyb3cgbmV3IFF1aXpEYXRhRXJyb3IoYFF1ZXN0aW9uIHdpdGggaWQgJHtpZH0gbm90IGZvdW5kYCwgJ05PVF9GT1VORCcpXG4gICAgfVxuICAgIFxuICAgIGNvbnN0IHVwZGF0ZWRRdWVzdGlvbiA9IHtcbiAgICAgIC4uLnF1ZXN0aW9uc1tpbmRleF0sXG4gICAgICAuLi51cGRhdGVzLFxuICAgICAgdXBkYXRlZEF0OiBEYXRlLm5vdygpXG4gICAgfVxuICAgIFxuICAgIHRoaXMudmFsaWRhdGVRdWVzdGlvbih1cGRhdGVkUXVlc3Rpb24pXG4gICAgcXVlc3Rpb25zW2luZGV4XSA9IHVwZGF0ZWRRdWVzdGlvblxuICAgIHRoaXMuc2F2ZVF1ZXN0aW9ucyhxdWVzdGlvbnMpXG4gICAgcmV0dXJuIHVwZGF0ZWRRdWVzdGlvblxuICB9XG5cbiAgZGVsZXRlUXVlc3Rpb24oaWQ6IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgIGNvbnN0IHF1ZXN0aW9ucyA9IHRoaXMuZ2V0UXVlc3Rpb25zKClcbiAgICBjb25zdCBmaWx0ZXJlZFF1ZXN0aW9ucyA9IHF1ZXN0aW9ucy5maWx0ZXIocSA9PiBxLmlkICE9PSBpZClcbiAgICBcbiAgICBpZiAoZmlsdGVyZWRRdWVzdGlvbnMubGVuZ3RoID09PSBxdWVzdGlvbnMubGVuZ3RoKSB7XG4gICAgICB0aHJvdyBuZXcgUXVpekRhdGFFcnJvcihgUXVlc3Rpb24gd2l0aCBpZCAke2lkfSBub3QgZm91bmRgLCAnTk9UX0ZPVU5EJylcbiAgICB9XG4gICAgXG4gICAgdGhpcy5zYXZlUXVlc3Rpb25zKGZpbHRlcmVkUXVlc3Rpb25zKVxuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICBidWxrRGVsZXRlKGlkczogc3RyaW5nW10pOiBCdWxrT3BlcmF0aW9uUmVzdWx0IHtcbiAgICBpZiAoaWRzLmxlbmd0aCA+IFZBTElEQVRJT05fUlVMRVMuTUFYX0JVTEtfT1BFUkFUSU9OUykge1xuICAgICAgdGhyb3cgbmV3IFF1aXpEYXRhRXJyb3IoXG4gICAgICAgIGBDYW5ub3QgZGVsZXRlIG1vcmUgdGhhbiAke1ZBTElEQVRJT05fUlVMRVMuTUFYX0JVTEtfT1BFUkFUSU9OU30gcXVlc3Rpb25zIGF0IG9uY2VgLFxuICAgICAgICAnQlVMS19MSU1JVF9FWENFRURFRCdcbiAgICAgIClcbiAgICB9XG5cbiAgICBjb25zdCBxdWVzdGlvbnMgPSB0aGlzLmdldFF1ZXN0aW9ucygpXG4gICAgY29uc3QgaW5pdGlhbENvdW50ID0gcXVlc3Rpb25zLmxlbmd0aFxuICAgIGNvbnN0IGZpbHRlcmVkUXVlc3Rpb25zID0gcXVlc3Rpb25zLmZpbHRlcihxID0+ICFpZHMuaW5jbHVkZXMocS5pZCkpXG4gICAgY29uc3QgZGVsZXRlZENvdW50ID0gaW5pdGlhbENvdW50IC0gZmlsdGVyZWRRdWVzdGlvbnMubGVuZ3RoXG4gICAgXG4gICAgdGhpcy5zYXZlUXVlc3Rpb25zKGZpbHRlcmVkUXVlc3Rpb25zKVxuICAgIFxuICAgIHJldHVybiB7XG4gICAgICBzdWNjZXNzOiB0cnVlLFxuICAgICAgcHJvY2Vzc2VkQ291bnQ6IGRlbGV0ZWRDb3VudCxcbiAgICAgIGVycm9yQ291bnQ6IGlkcy5sZW5ndGggLSBkZWxldGVkQ291bnQsXG4gICAgICBlcnJvcnM6IGlkcy5sZW5ndGggPiBkZWxldGVkQ291bnQgPyBbJ1NvbWUgcXVlc3Rpb25zIHdlcmUgbm90IGZvdW5kJ10gOiBbXVxuICAgIH1cbiAgfVxuXG4gIC8vIFNlYXJjaCBhbmQgZmlsdGVyIG9wZXJhdGlvbnNcbiAgc2VhcmNoUXVlc3Rpb25zKGZpbHRlcnM6IFNlYXJjaEZpbHRlcnMpOiBRdWl6UXVlc3Rpb25bXSB7XG4gICAgY29uc3QgcXVlc3Rpb25zID0gdGhpcy5nZXRRdWVzdGlvbnMoKVxuICAgIFxuICAgIHJldHVybiBxdWVzdGlvbnMuZmlsdGVyKHF1ZXN0aW9uID0+IHtcbiAgICAgIC8vIFRleHQgc2VhcmNoXG4gICAgICBpZiAoZmlsdGVycy5zZWFyY2hUZXh0KSB7XG4gICAgICAgIGNvbnN0IHNlYXJjaExvd2VyID0gZmlsdGVycy5zZWFyY2hUZXh0LnRvTG93ZXJDYXNlKClcbiAgICAgICAgaWYgKCFxdWVzdGlvbi5xdWVzdGlvbi50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKHNlYXJjaExvd2VyKSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIENhdGVnb3J5IGZpbHRlclxuICAgICAgaWYgKGZpbHRlcnMuY2F0ZWdvcnkgIT09ICdhbGwnICYmIHF1ZXN0aW9uLmNhdGVnb3J5ICE9PSBmaWx0ZXJzLmNhdGVnb3J5KSB7XG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBEaWZmaWN1bHR5IGZpbHRlclxuICAgICAgaWYgKGZpbHRlcnMuZGlmZmljdWx0eSAhPT0gJ2FsbCcgJiYgcXVlc3Rpb24uZGlmZmljdWx0eSAhPT0gZmlsdGVycy5kaWZmaWN1bHR5KSB7XG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBUeXBlIGZpbHRlclxuICAgICAgaWYgKGZpbHRlcnMudHlwZSAhPT0gJ2FsbCcgJiYgcXVlc3Rpb24udHlwZSAhPT0gZmlsdGVycy50eXBlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuICAgICAgXG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH0pXG4gIH1cblxuICAvLyBDYXRlZ29yaWVzIG1hbmFnZW1lbnRcbiAgZ2V0Q2F0ZWdvcmllcygpOiBRdWl6Q2F0ZWdvcnlbXSB7XG4gICAgY29uc3QgcXVlc3Rpb25zID0gdGhpcy5nZXRRdWVzdGlvbnMoKVxuICAgIGNvbnN0IGNhdGVnb3J5Q291bnRzID0gcXVlc3Rpb25zLnJlZHVjZSgoYWNjLCBxdWVzdGlvbikgPT4ge1xuICAgICAgYWNjW3F1ZXN0aW9uLmNhdGVnb3J5XSA9IChhY2NbcXVlc3Rpb24uY2F0ZWdvcnldIHx8IDApICsgMVxuICAgICAgcmV0dXJuIGFjY1xuICAgIH0sIHt9IGFzIFJlY29yZDxzdHJpbmcsIG51bWJlcj4pXG4gICAgXG4gICAgcmV0dXJuIERFRkFVTFRfQ0FURUdPUklFUy5tYXAoY2F0ZWdvcnkgPT4gKHtcbiAgICAgIC4uLmNhdGVnb3J5LFxuICAgICAgcXVlc3Rpb25Db3VudDogY2F0ZWdvcnlDb3VudHNbY2F0ZWdvcnkuaWRdIHx8IDBcbiAgICB9KSlcbiAgfVxuXG4gIC8vIERyYWZ0IG1hbmFnZW1lbnRcbiAgc2F2ZURyYWZ0KGRyYWZ0OiBRdWVzdGlvbkRyYWZ0KTogdm9pZCB7XG4gICAgY29uc3QgZHJhZnRzID0gdGhpcy5nZXREcmFmdHMoKVxuICAgIGNvbnN0IGV4aXN0aW5nSW5kZXggPSBkcmFmdHMuZmluZEluZGV4KGQgPT4gZC5pZCA9PT0gZHJhZnQuaWQpXG4gICAgXG4gICAgaWYgKGV4aXN0aW5nSW5kZXggPj0gMCkge1xuICAgICAgZHJhZnRzW2V4aXN0aW5nSW5kZXhdID0geyAuLi5kcmFmdCwgbGFzdFNhdmVkOiBEYXRlLm5vdygpIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZHJhZnRzLnB1c2goeyAuLi5kcmFmdCwgbGFzdFNhdmVkOiBEYXRlLm5vdygpIH0pXG4gICAgfVxuICAgIFxuICAgIHRoaXMuc2FmZVNldEl0ZW0oUVVJWl9TVE9SQUdFX0tFWVMuRFJBRlRTLCBKU09OLnN0cmluZ2lmeShkcmFmdHMpKVxuICB9XG5cbiAgZ2V0RHJhZnRzKCk6IFF1ZXN0aW9uRHJhZnRbXSB7XG4gICAgY29uc3QgZGF0YSA9IHRoaXMuc2FmZUdldEl0ZW0oUVVJWl9TVE9SQUdFX0tFWVMuRFJBRlRTKVxuICAgIGlmICghZGF0YSkgcmV0dXJuIFtdXG4gICAgXG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBKU09OLnBhcnNlKGRhdGEpXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIHBhcnNpbmcgZHJhZnRzIGRhdGE6JywgZXJyb3IpXG4gICAgICByZXR1cm4gW11cbiAgICB9XG4gIH1cblxuICBkZWxldGVEcmFmdChpZDogc3RyaW5nKTogdm9pZCB7XG4gICAgY29uc3QgZHJhZnRzID0gdGhpcy5nZXREcmFmdHMoKS5maWx0ZXIoZCA9PiBkLmlkICE9PSBpZClcbiAgICB0aGlzLnNhZmVTZXRJdGVtKFFVSVpfU1RPUkFHRV9LRVlTLkRSQUZUUywgSlNPTi5zdHJpbmdpZnkoZHJhZnRzKSlcbiAgfVxuXG4gIC8vIFNldHRpbmdzIG1hbmFnZW1lbnRcbiAgZ2V0U2V0dGluZ3MoKTogUXVpek1hbmFnZW1lbnRTZXR0aW5ncyB7XG4gICAgY29uc3QgZGF0YSA9IHRoaXMuc2FmZUdldEl0ZW0oUVVJWl9TVE9SQUdFX0tFWVMuU0VUVElOR1MpXG4gICAgaWYgKCFkYXRhKSByZXR1cm4gdGhpcy5nZXREZWZhdWx0U2V0dGluZ3MoKVxuICAgIFxuICAgIHRyeSB7XG4gICAgICByZXR1cm4geyAuLi50aGlzLmdldERlZmF1bHRTZXR0aW5ncygpLCAuLi5KU09OLnBhcnNlKGRhdGEpIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgcGFyc2luZyBzZXR0aW5ncyBkYXRhOicsIGVycm9yKVxuICAgICAgcmV0dXJuIHRoaXMuZ2V0RGVmYXVsdFNldHRpbmdzKClcbiAgICB9XG4gIH1cblxuICBzYXZlU2V0dGluZ3Moc2V0dGluZ3M6IFBhcnRpYWw8UXVpek1hbmFnZW1lbnRTZXR0aW5ncz4pOiB2b2lkIHtcbiAgICBjb25zdCBjdXJyZW50U2V0dGluZ3MgPSB0aGlzLmdldFNldHRpbmdzKClcbiAgICBjb25zdCB1cGRhdGVkU2V0dGluZ3MgPSB7IC4uLmN1cnJlbnRTZXR0aW5ncywgLi4uc2V0dGluZ3MgfVxuICAgIHRoaXMuc2FmZVNldEl0ZW0oUVVJWl9TVE9SQUdFX0tFWVMuU0VUVElOR1MsIEpTT04uc3RyaW5naWZ5KHVwZGF0ZWRTZXR0aW5ncykpXG4gIH1cblxuICBwcml2YXRlIGdldERlZmF1bHRTZXR0aW5ncygpOiBRdWl6TWFuYWdlbWVudFNldHRpbmdzIHtcbiAgICByZXR1cm4ge1xuICAgICAgcGFnZVNpemU6IDEwLFxuICAgICAgc29ydEJ5OiAndXBkYXRlZEF0JyxcbiAgICAgIHNvcnRPcmRlcjogJ2Rlc2MnLFxuICAgICAgZmlsdGVyczoge1xuICAgICAgICBzZWFyY2hUZXh0OiAnJyxcbiAgICAgICAgY2F0ZWdvcnk6ICdhbGwnLFxuICAgICAgICBkaWZmaWN1bHR5OiAnYWxsJyxcbiAgICAgICAgdHlwZTogJ2FsbCdcbiAgICAgIH0sXG4gICAgICBzZWxlY3RlZFF1ZXN0aW9uczogW11cbiAgICB9XG4gIH1cblxuICAvLyBWYWxpZGF0aW9uXG4gIHByaXZhdGUgdmFsaWRhdGVRdWVzdGlvbihxdWVzdGlvbjogUGFydGlhbDxRdWl6UXVlc3Rpb24+KTogdm9pZCB7XG4gICAgaWYgKCFxdWVzdGlvbi5xdWVzdGlvbiB8fCBxdWVzdGlvbi5xdWVzdGlvbi5sZW5ndGggPCBWQUxJREFUSU9OX1JVTEVTLlFVRVNUSU9OX01JTl9MRU5HVEgpIHtcbiAgICAgIHRocm93IG5ldyBRdWl6RGF0YUVycm9yKFxuICAgICAgICBgUXVlc3Rpb24gbXVzdCBiZSBhdCBsZWFzdCAke1ZBTElEQVRJT05fUlVMRVMuUVVFU1RJT05fTUlOX0xFTkdUSH0gY2hhcmFjdGVycyBsb25nYCxcbiAgICAgICAgJ0lOVkFMSURfUVVFU1RJT05fTEVOR1RIJ1xuICAgICAgKVxuICAgIH1cbiAgICBcbiAgICBpZiAocXVlc3Rpb24ucXVlc3Rpb24ubGVuZ3RoID4gVkFMSURBVElPTl9SVUxFUy5RVUVTVElPTl9NQVhfTEVOR1RIKSB7XG4gICAgICB0aHJvdyBuZXcgUXVpekRhdGFFcnJvcihcbiAgICAgICAgYFF1ZXN0aW9uIG11c3QgYmUgbm8gbW9yZSB0aGFuICR7VkFMSURBVElPTl9SVUxFUy5RVUVTVElPTl9NQVhfTEVOR1RIfSBjaGFyYWN0ZXJzIGxvbmdgLFxuICAgICAgICAnSU5WQUxJRF9RVUVTVElPTl9MRU5HVEgnXG4gICAgICApXG4gICAgfVxuICAgIFxuICAgIGlmICghcXVlc3Rpb24ub3B0aW9ucyB8fCBxdWVzdGlvbi5vcHRpb25zLmxlbmd0aCAhPT0gVkFMSURBVElPTl9SVUxFUy5NSU5fT1BUSU9OUykge1xuICAgICAgdGhyb3cgbmV3IFF1aXpEYXRhRXJyb3IoXG4gICAgICAgIGBRdWVzdGlvbiBtdXN0IGhhdmUgZXhhY3RseSAke1ZBTElEQVRJT05fUlVMRVMuTUlOX09QVElPTlN9IG9wdGlvbnNgLFxuICAgICAgICAnSU5WQUxJRF9PUFRJT05TX0NPVU5UJ1xuICAgICAgKVxuICAgIH1cbiAgICBcbiAgICAvLyBWYWxpZGF0ZSBlYWNoIG9wdGlvblxuICAgIHF1ZXN0aW9uLm9wdGlvbnMuZm9yRWFjaCgob3B0aW9uLCBpbmRleCkgPT4ge1xuICAgICAgaWYgKCFvcHRpb24gfHwgb3B0aW9uLmxlbmd0aCA8IFZBTElEQVRJT05fUlVMRVMuT1BUSU9OX01JTl9MRU5HVEgpIHtcbiAgICAgICAgdGhyb3cgbmV3IFF1aXpEYXRhRXJyb3IoXG4gICAgICAgICAgYE9wdGlvbiAke2luZGV4ICsgMX0gbXVzdCBiZSBhdCBsZWFzdCAke1ZBTElEQVRJT05fUlVMRVMuT1BUSU9OX01JTl9MRU5HVEh9IGNoYXJhY3RlciBsb25nYCxcbiAgICAgICAgICAnSU5WQUxJRF9PUFRJT05fTEVOR1RIJ1xuICAgICAgICApXG4gICAgICB9XG4gICAgICBcbiAgICAgIGlmIChvcHRpb24ubGVuZ3RoID4gVkFMSURBVElPTl9SVUxFUy5PUFRJT05fTUFYX0xFTkdUSCkge1xuICAgICAgICB0aHJvdyBuZXcgUXVpekRhdGFFcnJvcihcbiAgICAgICAgICBgT3B0aW9uICR7aW5kZXggKyAxfSBtdXN0IGJlIG5vIG1vcmUgdGhhbiAke1ZBTElEQVRJT05fUlVMRVMuT1BUSU9OX01BWF9MRU5HVEh9IGNoYXJhY3RlcnMgbG9uZ2AsXG4gICAgICAgICAgJ0lOVkFMSURfT1BUSU9OX0xFTkdUSCdcbiAgICAgICAgKVxuICAgICAgfVxuICAgIH0pXG4gICAgXG4gICAgLy8gQ2hlY2sgZm9yIGR1cGxpY2F0ZSBvcHRpb25zXG4gICAgY29uc3QgdW5pcXVlT3B0aW9ucyA9IG5ldyBTZXQocXVlc3Rpb24ub3B0aW9ucy5tYXAob3B0ID0+IG9wdC50b0xvd2VyQ2FzZSgpLnRyaW0oKSkpXG4gICAgaWYgKHVuaXF1ZU9wdGlvbnMuc2l6ZSAhPT0gcXVlc3Rpb24ub3B0aW9ucy5sZW5ndGgpIHtcbiAgICAgIHRocm93IG5ldyBRdWl6RGF0YUVycm9yKCdBbGwgb3B0aW9ucyBtdXN0IGJlIHVuaXF1ZScsICdEVVBMSUNBVEVfT1BUSU9OUycpXG4gICAgfVxuICAgIFxuICAgIC8vIFZhbGlkYXRlIGNvcnJlY3QgYW5zd2VyXG4gICAgaWYgKHR5cGVvZiBxdWVzdGlvbi5jb3JyZWN0QW5zd2VyICE9PSAnbnVtYmVyJyB8fCBcbiAgICAgICAgcXVlc3Rpb24uY29ycmVjdEFuc3dlciA8IDAgfHwgXG4gICAgICAgIHF1ZXN0aW9uLmNvcnJlY3RBbnN3ZXIgPj0gcXVlc3Rpb24ub3B0aW9ucy5sZW5ndGgpIHtcbiAgICAgIHRocm93IG5ldyBRdWl6RGF0YUVycm9yKCdJbnZhbGlkIGNvcnJlY3QgYW5zd2VyIHNlbGVjdGlvbicsICdJTlZBTElEX0NPUlJFQ1RfQU5TV0VSJylcbiAgICB9XG4gICAgXG4gICAgLy8gVmFsaWRhdGUgY2F0ZWdvcnlcbiAgICBjb25zdCB2YWxpZENhdGVnb3JpZXMgPSBERUZBVUxUX0NBVEVHT1JJRVMubWFwKGMgPT4gYy5pZClcbiAgICBpZiAoIXF1ZXN0aW9uLmNhdGVnb3J5IHx8ICF2YWxpZENhdGVnb3JpZXMuaW5jbHVkZXMocXVlc3Rpb24uY2F0ZWdvcnkpKSB7XG4gICAgICB0aHJvdyBuZXcgUXVpekRhdGFFcnJvcignSW52YWxpZCBjYXRlZ29yeSBzZWxlY3Rpb24nLCAnSU5WQUxJRF9DQVRFR09SWScpXG4gICAgfVxuICB9XG5cbiAgLy8gVXRpbGl0eSBtZXRob2RzXG4gIHByaXZhdGUgc2F2ZVF1ZXN0aW9ucyhxdWVzdGlvbnM6IFF1aXpRdWVzdGlvbltdKTogdm9pZCB7XG4gICAgdGhpcy5zYWZlU2V0SXRlbShRVUlaX1NUT1JBR0VfS0VZUy5RVUVTVElPTlMsIEpTT04uc3RyaW5naWZ5KHF1ZXN0aW9ucykpXG4gIH1cblxuICBwcml2YXRlIGdlbmVyYXRlSWQoKTogc3RyaW5nIHtcbiAgICByZXR1cm4gYHFfJHtEYXRlLm5vdygpfV8ke01hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnN1YnN0cigyLCA5KX1gXG4gIH1cblxuICAvLyBDU1YgRXhwb3J0L0ltcG9ydCBmdW5jdGlvbmFsaXR5XG4gIGV4cG9ydFRvQ1NWKHF1ZXN0aW9ucz86IFF1aXpRdWVzdGlvbltdKTogc3RyaW5nIHtcbiAgICBjb25zdCBxdWVzdGlvbnNUb0V4cG9ydCA9IHF1ZXN0aW9ucyB8fCB0aGlzLmdldFF1ZXN0aW9ucygpXG5cbiAgICBjb25zdCBoZWFkZXJzID0gW1xuICAgICAgJ0lEJywgJ1F1ZXN0aW9uJywgJ09wdGlvbiAxJywgJ09wdGlvbiAyJywgJ09wdGlvbiAzJywgJ09wdGlvbiA0JyxcbiAgICAgICdDb3JyZWN0IEFuc3dlcicsICdDYXRlZ29yeScsICdEaWZmaWN1bHR5JywgJ1R5cGUnLCAnRnVuIEZhY3QnLCAnVGFncycsXG4gICAgICAnQ3JlYXRlZCBBdCcsICdVcGRhdGVkIEF0J1xuICAgIF1cblxuICAgIGNvbnN0IGNzdlJvd3MgPSBbXG4gICAgICBoZWFkZXJzLmpvaW4oJywnKSxcbiAgICAgIC4uLnF1ZXN0aW9uc1RvRXhwb3J0Lm1hcChxID0+IFtcbiAgICAgICAgcS5pZCxcbiAgICAgICAgYFwiJHtxLnF1ZXN0aW9uLnJlcGxhY2UoL1wiL2csICdcIlwiJyl9XCJgLFxuICAgICAgICBgXCIke3Eub3B0aW9uc1swXS5yZXBsYWNlKC9cIi9nLCAnXCJcIicpfVwiYCxcbiAgICAgICAgYFwiJHtxLm9wdGlvbnNbMV0ucmVwbGFjZSgvXCIvZywgJ1wiXCInKX1cImAsXG4gICAgICAgIGBcIiR7cS5vcHRpb25zWzJdLnJlcGxhY2UoL1wiL2csICdcIlwiJyl9XCJgLFxuICAgICAgICBgXCIke3Eub3B0aW9uc1szXS5yZXBsYWNlKC9cIi9nLCAnXCJcIicpfVwiYCxcbiAgICAgICAgcS5jb3JyZWN0QW5zd2VyICsgMSwgLy8gMS1iYXNlZCBmb3IgaHVtYW4gcmVhZGFiaWxpdHlcbiAgICAgICAgcS5jYXRlZ29yeSxcbiAgICAgICAgcS5kaWZmaWN1bHR5LFxuICAgICAgICBxLnR5cGUsXG4gICAgICAgIGBcIiR7KHEuZnVuRmFjdCB8fCAnJykucmVwbGFjZSgvXCIvZywgJ1wiXCInKX1cImAsXG4gICAgICAgIGBcIiR7KHEudGFncyB8fCBbXSkuam9pbignOycpfVwiYCxcbiAgICAgICAgbmV3IERhdGUocS5jcmVhdGVkQXQpLnRvSVNPU3RyaW5nKCksXG4gICAgICAgIG5ldyBEYXRlKHEudXBkYXRlZEF0KS50b0lTT1N0cmluZygpXG4gICAgICBdLmpvaW4oJywnKSlcbiAgICBdXG5cbiAgICAvLyBBZGQgVVRGLTggQk9NIGZvciBFeGNlbCBjb21wYXRpYmlsaXR5XG4gICAgcmV0dXJuICdcXHVGRUZGJyArIGNzdlJvd3Muam9pbignXFxuJylcbiAgfVxuXG4gIGFzeW5jIGltcG9ydEZyb21DU1YoY3N2Q29udGVudDogc3RyaW5nKTogUHJvbWlzZTxCdWxrT3BlcmF0aW9uUmVzdWx0PiB7XG4gICAgY29uc3QgbGluZXMgPSBjc3ZDb250ZW50LnNwbGl0KCdcXG4nKS5maWx0ZXIobGluZSA9PiBsaW5lLnRyaW0oKSlcbiAgICBpZiAobGluZXMubGVuZ3RoIDwgMikge1xuICAgICAgdGhyb3cgbmV3IFF1aXpEYXRhRXJyb3IoJ0NTViBmaWxlIG11c3QgY29udGFpbiBhdCBsZWFzdCBhIGhlYWRlciBhbmQgb25lIGRhdGEgcm93JywgJ0lOVkFMSURfQ1NWX0ZPUk1BVCcpXG4gICAgfVxuXG4gICAgY29uc3QgaGVhZGVycyA9IGxpbmVzWzBdLnNwbGl0KCcsJykubWFwKGggPT4gaC50cmltKCkucmVwbGFjZSgvXCIvZywgJycpKVxuICAgIGNvbnN0IGRhdGFMaW5lcyA9IGxpbmVzLnNsaWNlKDEpXG5cbiAgICBjb25zdCByZXN1bHRzOiBCdWxrT3BlcmF0aW9uUmVzdWx0ID0ge1xuICAgICAgc3VjY2VzczogdHJ1ZSxcbiAgICAgIHByb2Nlc3NlZENvdW50OiAwLFxuICAgICAgZXJyb3JDb3VudDogMCxcbiAgICAgIGVycm9yczogW11cbiAgICB9XG5cbiAgICBjb25zdCB2YWxpZFF1ZXN0aW9uczogUXVpelF1ZXN0aW9uW10gPSBbXVxuICAgIGNvbnN0IGV4aXN0aW5nUXVlc3Rpb25zID0gdGhpcy5nZXRRdWVzdGlvbnMoKVxuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkYXRhTGluZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHZhbHVlcyA9IHRoaXMucGFyc2VDU1ZMaW5lKGRhdGFMaW5lc1tpXSlcbiAgICAgICAgaWYgKHZhbHVlcy5sZW5ndGggPCA4KSB7XG4gICAgICAgICAgcmVzdWx0cy5lcnJvcnMucHVzaChgTGluZSAke2kgKyAyfTogSW5zdWZmaWNpZW50IGRhdGEgY29sdW1uc2ApXG4gICAgICAgICAgcmVzdWx0cy5lcnJvckNvdW50KytcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgcXVlc3Rpb246IFF1aXpRdWVzdGlvbiA9IHtcbiAgICAgICAgICBpZDogdmFsdWVzWzBdIHx8IHRoaXMuZ2VuZXJhdGVJZCgpLFxuICAgICAgICAgIHF1ZXN0aW9uOiB2YWx1ZXNbMV0sXG4gICAgICAgICAgb3B0aW9uczogW3ZhbHVlc1syXSwgdmFsdWVzWzNdLCB2YWx1ZXNbNF0sIHZhbHVlc1s1XV0sXG4gICAgICAgICAgY29ycmVjdEFuc3dlcjogcGFyc2VJbnQodmFsdWVzWzZdKSAtIDEsIC8vIENvbnZlcnQgYmFjayB0byAwLWJhc2VkXG4gICAgICAgICAgY2F0ZWdvcnk6IHZhbHVlc1s3XSxcbiAgICAgICAgICBkaWZmaWN1bHR5OiB2YWx1ZXNbOF0gYXMgJ2JlZ2lubmVyJyB8ICdpbnRlcm1lZGlhdGUnIHwgJ2FkdmFuY2VkJyxcbiAgICAgICAgICB0eXBlOiAodmFsdWVzWzldIHx8ICdyZWd1bGFyJykgYXMgJ3JlZ3VsYXInIHwgJ2JvbnVzJyxcbiAgICAgICAgICBmdW5GYWN0OiB2YWx1ZXNbMTBdIHx8IHVuZGVmaW5lZCxcbiAgICAgICAgICB0YWdzOiB2YWx1ZXNbMTFdID8gdmFsdWVzWzExXS5zcGxpdCgnOycpLmZpbHRlcih0ID0+IHQudHJpbSgpKSA6IHVuZGVmaW5lZCxcbiAgICAgICAgICBjcmVhdGVkQXQ6IHZhbHVlc1sxMl0gPyBuZXcgRGF0ZSh2YWx1ZXNbMTJdKS5nZXRUaW1lKCkgOiBEYXRlLm5vdygpLFxuICAgICAgICAgIHVwZGF0ZWRBdDogdmFsdWVzWzEzXSA/IG5ldyBEYXRlKHZhbHVlc1sxM10pLmdldFRpbWUoKSA6IERhdGUubm93KClcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFZhbGlkYXRlIHRoZSBxdWVzdGlvblxuICAgICAgICB0aGlzLnZhbGlkYXRlUXVlc3Rpb24ocXVlc3Rpb24pXG5cbiAgICAgICAgLy8gQ2hlY2sgZm9yIGR1cGxpY2F0ZXNcbiAgICAgICAgY29uc3QgZXhpc3RpbmdJbmRleCA9IGV4aXN0aW5nUXVlc3Rpb25zLmZpbmRJbmRleChxID0+IHEuaWQgPT09IHF1ZXN0aW9uLmlkKVxuICAgICAgICBpZiAoZXhpc3RpbmdJbmRleCA+PSAwKSB7XG4gICAgICAgICAgLy8gVXBkYXRlIGV4aXN0aW5nIHF1ZXN0aW9uXG4gICAgICAgICAgZXhpc3RpbmdRdWVzdGlvbnNbZXhpc3RpbmdJbmRleF0gPSBxdWVzdGlvblxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhbGlkUXVlc3Rpb25zLnB1c2gocXVlc3Rpb24pXG4gICAgICAgIH1cblxuICAgICAgICByZXN1bHRzLnByb2Nlc3NlZENvdW50KytcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIHJlc3VsdHMuZXJyb3JzLnB1c2goYExpbmUgJHtpICsgMn06ICR7ZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiAnVW5rbm93biBlcnJvcid9YClcbiAgICAgICAgcmVzdWx0cy5lcnJvckNvdW50KytcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBTYXZlIGFsbCB2YWxpZCBxdWVzdGlvbnNcbiAgICBpZiAodmFsaWRRdWVzdGlvbnMubGVuZ3RoID4gMCkge1xuICAgICAgY29uc3QgYWxsUXVlc3Rpb25zID0gWy4uLmV4aXN0aW5nUXVlc3Rpb25zLCAuLi52YWxpZFF1ZXN0aW9uc11cbiAgICAgIHRoaXMuc2F2ZVF1ZXN0aW9ucyhhbGxRdWVzdGlvbnMpXG4gICAgfVxuXG4gICAgcmVzdWx0cy5zdWNjZXNzID0gcmVzdWx0cy5lcnJvckNvdW50ID09PSAwXG4gICAgcmV0dXJuIHJlc3VsdHNcbiAgfVxuXG4gIHByaXZhdGUgcGFyc2VDU1ZMaW5lKGxpbmU6IHN0cmluZyk6IHN0cmluZ1tdIHtcbiAgICBjb25zdCByZXN1bHQ6IHN0cmluZ1tdID0gW11cbiAgICBsZXQgY3VycmVudCA9ICcnXG4gICAgbGV0IGluUXVvdGVzID0gZmFsc2VcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGluZS5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgY2hhciA9IGxpbmVbaV1cblxuICAgICAgaWYgKGNoYXIgPT09ICdcIicpIHtcbiAgICAgICAgaWYgKGluUXVvdGVzICYmIGxpbmVbaSArIDFdID09PSAnXCInKSB7XG4gICAgICAgICAgY3VycmVudCArPSAnXCInXG4gICAgICAgICAgaSsrIC8vIFNraXAgbmV4dCBxdW90ZVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGluUXVvdGVzID0gIWluUXVvdGVzXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoY2hhciA9PT0gJywnICYmICFpblF1b3Rlcykge1xuICAgICAgICByZXN1bHQucHVzaChjdXJyZW50LnRyaW0oKSlcbiAgICAgICAgY3VycmVudCA9ICcnXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjdXJyZW50ICs9IGNoYXJcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXN1bHQucHVzaChjdXJyZW50LnRyaW0oKSlcbiAgICByZXR1cm4gcmVzdWx0XG4gIH1cblxuICBwcml2YXRlIGluaXRpYWxpemVXaXRoU2FtcGxlRGF0YSgpOiBRdWl6UXVlc3Rpb25bXSB7XG4gICAgLy8gSW5pdGlhbGl6ZSB3aXRoIGEgZmV3IHNhbXBsZSBxdWVzdGlvbnMgZm9yIGRlbW9uc3RyYXRpb25cbiAgICBjb25zdCBzYW1wbGVRdWVzdGlvbnM6IFF1aXpRdWVzdGlvbltdID0gW1xuICAgICAge1xuICAgICAgICBpZDogJ3NhbXBsZV8xJyxcbiAgICAgICAgcXVlc3Rpb246ICdXaGljaCBzb2NpYWwgbWVkaWEgcGxhdGZvcm0gaXMga25vd24gZm9yIGl0cyBzaG9ydC1mb3JtIHZpZGVvIGNvbnRlbnQgYW5kIHZpcmFsIGRhbmNlcz8nLFxuICAgICAgICBvcHRpb25zOiBbJ0luc3RhZ3JhbScsICdUaWtUb2snLCAnVHdpdHRlcicsICdTbmFwY2hhdCddLFxuICAgICAgICBjb3JyZWN0QW5zd2VyOiAxLFxuICAgICAgICBjYXRlZ29yeTogJ3NvY2lhbC1tZWRpYScsXG4gICAgICAgIGRpZmZpY3VsdHk6ICdiZWdpbm5lcicsXG4gICAgICAgIHR5cGU6ICdyZWd1bGFyJyxcbiAgICAgICAgZnVuRmFjdDogJ1Rpa1RvayB3YXMgb3JpZ2luYWxseSBjYWxsZWQgTXVzaWNhbC5seSBiZWZvcmUgYmVpbmcgYWNxdWlyZWQgYnkgQnl0ZURhbmNlLicsXG4gICAgICAgIHRhZ3M6IFsnc29jaWFsLW1lZGlhJywgJ3ZpZGVvJywgJ3ZpcmFsJ10sXG4gICAgICAgIGNyZWF0ZWRBdDogRGF0ZS5ub3coKSAtIDg2NDAwMDAwLCAvLyAxIGRheSBhZ29cbiAgICAgICAgdXBkYXRlZEF0OiBEYXRlLm5vdygpIC0gODY0MDAwMDBcbiAgICAgIH1cbiAgICAgIC8vIEFkZCBtb3JlIHNhbXBsZSBxdWVzdGlvbnMgYXMgbmVlZGVkXG4gICAgXVxuXG4gICAgdGhpcy5zYXZlUXVlc3Rpb25zKHNhbXBsZVF1ZXN0aW9ucylcbiAgICByZXR1cm4gc2FtcGxlUXVlc3Rpb25zXG4gIH1cblxuICAvLyBCYWNrdXAgYW5kIHJlc3RvcmUgZnVuY3Rpb25hbGl0eVxuICBjcmVhdGVCYWNrdXAoKTogc3RyaW5nIHtcbiAgICBjb25zdCBiYWNrdXAgPSB7XG4gICAgICBxdWVzdGlvbnM6IHRoaXMuZ2V0UXVlc3Rpb25zKCksXG4gICAgICBzZXR0aW5nczogdGhpcy5nZXRTZXR0aW5ncygpLFxuICAgICAgZHJhZnRzOiB0aGlzLmdldERyYWZ0cygpLFxuICAgICAgdGltZXN0YW1wOiBEYXRlLm5vdygpLFxuICAgICAgdmVyc2lvbjogJzEuMCdcbiAgICB9XG5cbiAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoYmFja3VwLCBudWxsLCAyKVxuICB9XG5cbiAgcmVzdG9yZUZyb21CYWNrdXAoYmFja3VwRGF0YTogc3RyaW5nKTogQnVsa09wZXJhdGlvblJlc3VsdCB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGJhY2t1cCA9IEpTT04ucGFyc2UoYmFja3VwRGF0YSlcblxuICAgICAgaWYgKCFiYWNrdXAucXVlc3Rpb25zIHx8ICFBcnJheS5pc0FycmF5KGJhY2t1cC5xdWVzdGlvbnMpKSB7XG4gICAgICAgIHRocm93IG5ldyBRdWl6RGF0YUVycm9yKCdJbnZhbGlkIGJhY2t1cCBmb3JtYXQ6IG1pc3NpbmcgcXVlc3Rpb25zIGFycmF5JywgJ0lOVkFMSURfQkFDS1VQJylcbiAgICAgIH1cblxuICAgICAgLy8gVmFsaWRhdGUgYWxsIHF1ZXN0aW9ucyBpbiBiYWNrdXBcbiAgICAgIGJhY2t1cC5xdWVzdGlvbnMuZm9yRWFjaCgocTogYW55LCBpbmRleDogbnVtYmVyKSA9PiB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgdGhpcy52YWxpZGF0ZVF1ZXN0aW9uKHEpXG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFF1aXpEYXRhRXJyb3IoXG4gICAgICAgICAgICBgSW52YWxpZCBxdWVzdGlvbiBhdCBpbmRleCAke2luZGV4fTogJHtlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6ICdVbmtub3duIGVycm9yJ31gLFxuICAgICAgICAgICAgJ0lOVkFMSURfQkFDS1VQX1FVRVNUSU9OJ1xuICAgICAgICAgIClcbiAgICAgICAgfVxuICAgICAgfSlcblxuICAgICAgLy8gQ3JlYXRlIGN1cnJlbnQgYmFja3VwIGJlZm9yZSByZXN0b3JlXG4gICAgICBjb25zdCBjdXJyZW50QmFja3VwID0gdGhpcy5jcmVhdGVCYWNrdXAoKVxuICAgICAgdGhpcy5zYWZlU2V0SXRlbShRVUlaX1NUT1JBR0VfS0VZUy5CQUNLVVAsIGN1cnJlbnRCYWNrdXApXG5cbiAgICAgIC8vIFJlc3RvcmUgZGF0YVxuICAgICAgdGhpcy5zYXZlUXVlc3Rpb25zKGJhY2t1cC5xdWVzdGlvbnMpXG4gICAgICBpZiAoYmFja3VwLnNldHRpbmdzKSB7XG4gICAgICAgIHRoaXMuc2FmZVNldEl0ZW0oUVVJWl9TVE9SQUdFX0tFWVMuU0VUVElOR1MsIEpTT04uc3RyaW5naWZ5KGJhY2t1cC5zZXR0aW5ncykpXG4gICAgICB9XG4gICAgICBpZiAoYmFja3VwLmRyYWZ0cykge1xuICAgICAgICB0aGlzLnNhZmVTZXRJdGVtKFFVSVpfU1RPUkFHRV9LRVlTLkRSQUZUUywgSlNPTi5zdHJpbmdpZnkoYmFja3VwLmRyYWZ0cykpXG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHN1Y2Nlc3M6IHRydWUsXG4gICAgICAgIHByb2Nlc3NlZENvdW50OiBiYWNrdXAucXVlc3Rpb25zLmxlbmd0aCxcbiAgICAgICAgZXJyb3JDb3VudDogMCxcbiAgICAgICAgZXJyb3JzOiBbXVxuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICB0aHJvdyBuZXcgUXVpekRhdGFFcnJvcihcbiAgICAgICAgYEZhaWxlZCB0byByZXN0b3JlIGJhY2t1cDogJHtlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6ICdVbmtub3duIGVycm9yJ31gLFxuICAgICAgICAnUkVTVE9SRV9GQUlMRUQnXG4gICAgICApXG4gICAgfVxuICB9XG5cbiAgLy8gQXV0by1zYXZlIGZ1bmN0aW9uYWxpdHkgZm9yIGRyYWZ0c1xuICBzdGFydEF1dG9TYXZlKGRyYWZ0SWQ6IHN0cmluZywgZ2V0RHJhZnREYXRhOiAoKSA9PiBQYXJ0aWFsPFF1ZXN0aW9uRHJhZnQ+KTogdm9pZCB7XG4gICAgdGhpcy5zdG9wQXV0b1NhdmUoKVxuXG4gICAgdGhpcy5hdXRvU2F2ZVRpbWVyID0gc2V0SW50ZXJ2YWwoKCkgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgZHJhZnREYXRhID0gZ2V0RHJhZnREYXRhKClcbiAgICAgICAgaWYgKGRyYWZ0RGF0YS5xdWVzdGlvbiAmJiBkcmFmdERhdGEucXVlc3Rpb24ubGVuZ3RoID4gMCkge1xuICAgICAgICAgIGNvbnN0IGRyYWZ0OiBRdWVzdGlvbkRyYWZ0ID0ge1xuICAgICAgICAgICAgaWQ6IGRyYWZ0SWQsXG4gICAgICAgICAgICBxdWVzdGlvbjogZHJhZnREYXRhLnF1ZXN0aW9uIHx8ICcnLFxuICAgICAgICAgICAgb3B0aW9uczogZHJhZnREYXRhLm9wdGlvbnMgfHwgWycnLCAnJywgJycsICcnXSxcbiAgICAgICAgICAgIGNvcnJlY3RBbnN3ZXI6IGRyYWZ0RGF0YS5jb3JyZWN0QW5zd2VyIHx8IDAsXG4gICAgICAgICAgICBjYXRlZ29yeTogZHJhZnREYXRhLmNhdGVnb3J5IHx8ICdmYWN0cycsXG4gICAgICAgICAgICBkaWZmaWN1bHR5OiBkcmFmdERhdGEuZGlmZmljdWx0eSB8fCAnYmVnaW5uZXInLFxuICAgICAgICAgICAgdHlwZTogZHJhZnREYXRhLnR5cGUgfHwgJ3JlZ3VsYXInLFxuICAgICAgICAgICAgZnVuRmFjdDogZHJhZnREYXRhLmZ1bkZhY3QsXG4gICAgICAgICAgICB0YWdzOiBkcmFmdERhdGEudGFncyxcbiAgICAgICAgICAgIGxhc3RTYXZlZDogRGF0ZS5ub3coKVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHRoaXMuc2F2ZURyYWZ0KGRyYWZ0KVxuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdBdXRvLXNhdmUgZmFpbGVkOicsIGVycm9yKVxuICAgICAgfVxuICAgIH0sIFZBTElEQVRJT05fUlVMRVMuQVVUT19TQVZFX0lOVEVSVkFMKVxuICB9XG5cbiAgc3RvcEF1dG9TYXZlKCk6IHZvaWQge1xuICAgIGlmICh0aGlzLmF1dG9TYXZlVGltZXIpIHtcbiAgICAgIGNsZWFySW50ZXJ2YWwodGhpcy5hdXRvU2F2ZVRpbWVyKVxuICAgICAgdGhpcy5hdXRvU2F2ZVRpbWVyID0gbnVsbFxuICAgIH1cbiAgfVxuXG4gIC8vIENTViBFeHBvcnQgZnVuY3Rpb25hbGl0eVxuICBleHBvcnRUb0NTVihxdWVzdGlvbnNUb0V4cG9ydD86IFF1aXpRdWVzdGlvbltdKTogc3RyaW5nIHtcbiAgICBjb25zdCBxdWVzdGlvbnMgPSBxdWVzdGlvbnNUb0V4cG9ydCB8fCB0aGlzLmdldFF1ZXN0aW9ucygpXG4gICAgY29uc3QgaGVhZGVycyA9IFtcbiAgICAgICdJRCcsXG4gICAgICAnUXVlc3Rpb24nLFxuICAgICAgJ09wdGlvbiAxJyxcbiAgICAgICdPcHRpb24gMicsXG4gICAgICAnT3B0aW9uIDMnLFxuICAgICAgJ09wdGlvbiA0JyxcbiAgICAgICdDb3JyZWN0IEFuc3dlciAoMS00KScsXG4gICAgICAnQ2F0ZWdvcnknLFxuICAgICAgJ0RpZmZpY3VsdHknLFxuICAgICAgJ1R5cGUnLFxuICAgICAgJ0Z1biBGYWN0JyxcbiAgICAgICdUYWdzJyxcbiAgICAgICdDcmVhdGVkIEF0JyxcbiAgICAgICdVcGRhdGVkIEF0J1xuICAgIF1cblxuICAgIGNvbnN0IGNzdlJvd3MgPSBbaGVhZGVycy5qb2luKCcsJyldXG5cbiAgICBxdWVzdGlvbnMuZm9yRWFjaChxdWVzdGlvbiA9PiB7XG4gICAgICBjb25zdCByb3cgPSBbXG4gICAgICAgIHF1ZXN0aW9uLmlkLFxuICAgICAgICBgXCIke3F1ZXN0aW9uLnF1ZXN0aW9uLnJlcGxhY2UoL1wiL2csICdcIlwiJyl9XCJgLCAvLyBFc2NhcGUgcXVvdGVzXG4gICAgICAgIGBcIiR7cXVlc3Rpb24ub3B0aW9uc1swXT8ucmVwbGFjZSgvXCIvZywgJ1wiXCInKSB8fCAnJ31cImAsXG4gICAgICAgIGBcIiR7cXVlc3Rpb24ub3B0aW9uc1sxXT8ucmVwbGFjZSgvXCIvZywgJ1wiXCInKSB8fCAnJ31cImAsXG4gICAgICAgIGBcIiR7cXVlc3Rpb24ub3B0aW9uc1syXT8ucmVwbGFjZSgvXCIvZywgJ1wiXCInKSB8fCAnJ31cImAsXG4gICAgICAgIGBcIiR7cXVlc3Rpb24ub3B0aW9uc1szXT8ucmVwbGFjZSgvXCIvZywgJ1wiXCInKSB8fCAnJ31cImAsXG4gICAgICAgIHF1ZXN0aW9uLmNvcnJlY3RBbnN3ZXIgKyAxLCAvLyBDb252ZXJ0IDAtYmFzZWQgdG8gMS1iYXNlZFxuICAgICAgICBxdWVzdGlvbi5jYXRlZ29yeSxcbiAgICAgICAgcXVlc3Rpb24uZGlmZmljdWx0eSxcbiAgICAgICAgcXVlc3Rpb24udHlwZSxcbiAgICAgICAgYFwiJHsocXVlc3Rpb24uZnVuRmFjdCB8fCAnJykucmVwbGFjZSgvXCIvZywgJ1wiXCInKX1cImAsXG4gICAgICAgIGBcIiR7KHF1ZXN0aW9uLnRhZ3MgfHwgW10pLmpvaW4oJzsnKX1cImAsXG4gICAgICAgIG5ldyBEYXRlKHF1ZXN0aW9uLmNyZWF0ZWRBdCkudG9JU09TdHJpbmcoKSxcbiAgICAgICAgbmV3IERhdGUocXVlc3Rpb24udXBkYXRlZEF0KS50b0lTT1N0cmluZygpXG4gICAgICBdXG4gICAgICBjc3ZSb3dzLnB1c2gocm93LmpvaW4oJywnKSlcbiAgICB9KVxuXG4gICAgcmV0dXJuIGNzdlJvd3Muam9pbignXFxuJylcbiAgfVxuXG4gIC8vIERvd25sb2FkIENTViBmaWxlXG4gIGRvd25sb2FkQ1NWKCk6IHZvaWQge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBjc3ZDb250ZW50ID0gdGhpcy5leHBvcnRUb0NTVigpXG4gICAgICBjb25zdCBibG9iID0gbmV3IEJsb2IoW2NzdkNvbnRlbnRdLCB7IHR5cGU6ICd0ZXh0L2NzdjtjaGFyc2V0PXV0Zi04OycgfSlcbiAgICAgIGNvbnN0IGxpbmsgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdhJylcblxuICAgICAgaWYgKGxpbmsuZG93bmxvYWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjb25zdCB1cmwgPSBVUkwuY3JlYXRlT2JqZWN0VVJMKGJsb2IpXG4gICAgICAgIGxpbmsuc2V0QXR0cmlidXRlKCdocmVmJywgdXJsKVxuICAgICAgICBsaW5rLnNldEF0dHJpYnV0ZSgnZG93bmxvYWQnLCBgdGVjaGt3aXotcXVlc3Rpb25zLSR7bmV3IERhdGUoKS50b0lTT1N0cmluZygpLnNwbGl0KCdUJylbMF19LmNzdmApXG4gICAgICAgIGxpbmsuc3R5bGUudmlzaWJpbGl0eSA9ICdoaWRkZW4nXG4gICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQobGluaylcbiAgICAgICAgbGluay5jbGljaygpXG4gICAgICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQobGluaylcbiAgICAgICAgVVJMLnJldm9rZU9iamVjdFVSTCh1cmwpXG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHRocm93IG5ldyBRdWl6RGF0YUVycm9yKCdGYWlsZWQgdG8gZG93bmxvYWQgQ1NWIGZpbGUnLCAnRVhQT1JUX0VSUk9SJylcbiAgICB9XG4gIH1cblxuICAvLyBQYXJzZSBDU1YgY29udGVudFxuICBwYXJzZUNTVihjc3ZDb250ZW50OiBzdHJpbmcpOiB7IHF1ZXN0aW9uczogUGFydGlhbDxRdWl6UXVlc3Rpb24+W107IGVycm9yczogc3RyaW5nW10gfSB7XG4gICAgY29uc3QgbGluZXMgPSBjc3ZDb250ZW50LnNwbGl0KCdcXG4nKS5maWx0ZXIobGluZSA9PiBsaW5lLnRyaW0oKSlcbiAgICBjb25zdCBlcnJvcnM6IHN0cmluZ1tdID0gW11cbiAgICBjb25zdCBxdWVzdGlvbnM6IFBhcnRpYWw8UXVpelF1ZXN0aW9uPltdID0gW11cblxuICAgIGlmIChsaW5lcy5sZW5ndGggPCAyKSB7XG4gICAgICBlcnJvcnMucHVzaCgnQ1NWIGZpbGUgbXVzdCBjb250YWluIGF0IGxlYXN0IGEgaGVhZGVyIHJvdyBhbmQgb25lIGRhdGEgcm93JylcbiAgICAgIHJldHVybiB7IHF1ZXN0aW9ucywgZXJyb3JzIH1cbiAgICB9XG5cbiAgICAvLyBTa2lwIGhlYWRlciByb3dcbiAgICBjb25zdCBkYXRhTGluZXMgPSBsaW5lcy5zbGljZSgxKVxuXG4gICAgZGF0YUxpbmVzLmZvckVhY2goKGxpbmUsIGluZGV4KSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCB2YWx1ZXMgPSB0aGlzLnBhcnNlQ1NWTGluZShsaW5lKVxuXG4gICAgICAgIGlmICh2YWx1ZXMubGVuZ3RoIDwgOCkge1xuICAgICAgICAgIGVycm9ycy5wdXNoKGBSb3cgJHtpbmRleCArIDJ9OiBJbnN1ZmZpY2llbnQgY29sdW1ucyAobWluaW11bSA4IHJlcXVpcmVkKWApXG4gICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBbaWQsIHF1ZXN0aW9uLCBvcHQxLCBvcHQyLCBvcHQzLCBvcHQ0LCBjb3JyZWN0QW5zd2VyLCBjYXRlZ29yeSwgZGlmZmljdWx0eSwgdHlwZSwgZnVuRmFjdCwgdGFncywgY3JlYXRlZEF0LCB1cGRhdGVkQXRdID0gdmFsdWVzXG5cbiAgICAgICAgLy8gVmFsaWRhdGUgcmVxdWlyZWQgZmllbGRzXG4gICAgICAgIGlmICghcXVlc3Rpb24/LnRyaW0oKSkge1xuICAgICAgICAgIGVycm9ycy5wdXNoKGBSb3cgJHtpbmRleCArIDJ9OiBRdWVzdGlvbiBpcyByZXF1aXJlZGApXG4gICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIW9wdDE/LnRyaW0oKSB8fCAhb3B0Mj8udHJpbSgpIHx8ICFvcHQzPy50cmltKCkgfHwgIW9wdDQ/LnRyaW0oKSkge1xuICAgICAgICAgIGVycm9ycy5wdXNoKGBSb3cgJHtpbmRleCArIDJ9OiBBbGwgNCBvcHRpb25zIGFyZSByZXF1aXJlZGApXG4gICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBjb3JyZWN0QW5zd2VyTnVtID0gcGFyc2VJbnQoY29ycmVjdEFuc3dlcikgLSAxIC8vIENvbnZlcnQgMS1iYXNlZCB0byAwLWJhc2VkXG4gICAgICAgIGlmIChpc05hTihjb3JyZWN0QW5zd2VyTnVtKSB8fCBjb3JyZWN0QW5zd2VyTnVtIDwgMCB8fCBjb3JyZWN0QW5zd2VyTnVtID4gMykge1xuICAgICAgICAgIGVycm9ycy5wdXNoKGBSb3cgJHtpbmRleCArIDJ9OiBDb3JyZWN0IGFuc3dlciBtdXN0IGJlIDEsIDIsIDMsIG9yIDRgKVxuICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFjYXRlZ29yeT8udHJpbSgpKSB7XG4gICAgICAgICAgZXJyb3JzLnB1c2goYFJvdyAke2luZGV4ICsgMn06IENhdGVnb3J5IGlzIHJlcXVpcmVkYClcbiAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghWydiZWdpbm5lcicsICdpbnRlcm1lZGlhdGUnLCAnYWR2YW5jZWQnXS5pbmNsdWRlcyhkaWZmaWN1bHR5KSkge1xuICAgICAgICAgIGVycm9ycy5wdXNoKGBSb3cgJHtpbmRleCArIDJ9OiBEaWZmaWN1bHR5IG11c3QgYmUgJ2JlZ2lubmVyJywgJ2ludGVybWVkaWF0ZScsIG9yICdhZHZhbmNlZCdgKVxuICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFbJ3JlZ3VsYXInLCAnYm9udXMnXS5pbmNsdWRlcyh0eXBlKSkge1xuICAgICAgICAgIGVycm9ycy5wdXNoKGBSb3cgJHtpbmRleCArIDJ9OiBUeXBlIG11c3QgYmUgJ3JlZ3VsYXInIG9yICdib251cydgKVxuICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgcXVlc3Rpb25EYXRhOiBQYXJ0aWFsPFF1aXpRdWVzdGlvbj4gPSB7XG4gICAgICAgICAgaWQ6IGlkIHx8IGBpbXBvcnRlZF8ke0RhdGUubm93KCl9XyR7aW5kZXh9YCxcbiAgICAgICAgICBxdWVzdGlvbjogcXVlc3Rpb24udHJpbSgpLFxuICAgICAgICAgIG9wdGlvbnM6IFtvcHQxLnRyaW0oKSwgb3B0Mi50cmltKCksIG9wdDMudHJpbSgpLCBvcHQ0LnRyaW0oKV0sXG4gICAgICAgICAgY29ycmVjdEFuc3dlcjogY29ycmVjdEFuc3dlck51bSxcbiAgICAgICAgICBjYXRlZ29yeTogY2F0ZWdvcnkudHJpbSgpLFxuICAgICAgICAgIGRpZmZpY3VsdHk6IGRpZmZpY3VsdHkgYXMgJ2JlZ2lubmVyJyB8ICdpbnRlcm1lZGlhdGUnIHwgJ2FkdmFuY2VkJyxcbiAgICAgICAgICB0eXBlOiB0eXBlIGFzICdyZWd1bGFyJyB8ICdib251cycsXG4gICAgICAgICAgZnVuRmFjdDogZnVuRmFjdD8udHJpbSgpIHx8IHVuZGVmaW5lZCxcbiAgICAgICAgICB0YWdzOiB0YWdzID8gdGFncy5zcGxpdCgnOycpLm1hcCh0YWcgPT4gdGFnLnRyaW0oKSkuZmlsdGVyKEJvb2xlYW4pIDogW10sXG4gICAgICAgICAgY3JlYXRlZEF0OiBjcmVhdGVkQXQgPyBuZXcgRGF0ZShjcmVhdGVkQXQpLmdldFRpbWUoKSA6IERhdGUubm93KCksXG4gICAgICAgICAgdXBkYXRlZEF0OiB1cGRhdGVkQXQgPyBuZXcgRGF0ZSh1cGRhdGVkQXQpLmdldFRpbWUoKSA6IERhdGUubm93KClcbiAgICAgICAgfVxuXG4gICAgICAgIHF1ZXN0aW9ucy5wdXNoKHF1ZXN0aW9uRGF0YSlcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGVycm9ycy5wdXNoKGBSb3cgJHtpbmRleCArIDJ9OiAke2Vycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogJ1BhcnNlIGVycm9yJ31gKVxuICAgICAgfVxuICAgIH0pXG5cbiAgICByZXR1cm4geyBxdWVzdGlvbnMsIGVycm9ycyB9XG4gIH1cblxuICAvLyBIZWxwZXIgdG8gcGFyc2UgQ1NWIGxpbmUgd2l0aCBwcm9wZXIgcXVvdGUgaGFuZGxpbmdcbiAgcHJpdmF0ZSBwYXJzZUNTVkxpbmUobGluZTogc3RyaW5nKTogc3RyaW5nW10ge1xuICAgIGNvbnN0IHJlc3VsdDogc3RyaW5nW10gPSBbXVxuICAgIGxldCBjdXJyZW50ID0gJydcbiAgICBsZXQgaW5RdW90ZXMgPSBmYWxzZVxuICAgIGxldCBpID0gMFxuXG4gICAgd2hpbGUgKGkgPCBsaW5lLmxlbmd0aCkge1xuICAgICAgY29uc3QgY2hhciA9IGxpbmVbaV1cblxuICAgICAgaWYgKGNoYXIgPT09ICdcIicpIHtcbiAgICAgICAgaWYgKGluUXVvdGVzICYmIGxpbmVbaSArIDFdID09PSAnXCInKSB7XG4gICAgICAgICAgLy8gRXNjYXBlZCBxdW90ZVxuICAgICAgICAgIGN1cnJlbnQgKz0gJ1wiJ1xuICAgICAgICAgIGkgKz0gMlxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIFRvZ2dsZSBxdW90ZSBzdGF0ZVxuICAgICAgICAgIGluUXVvdGVzID0gIWluUXVvdGVzXG4gICAgICAgICAgaSsrXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoY2hhciA9PT0gJywnICYmICFpblF1b3Rlcykge1xuICAgICAgICAvLyBFbmQgb2YgZmllbGRcbiAgICAgICAgcmVzdWx0LnB1c2goY3VycmVudClcbiAgICAgICAgY3VycmVudCA9ICcnXG4gICAgICAgIGkrK1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY3VycmVudCArPSBjaGFyXG4gICAgICAgIGkrK1xuICAgICAgfVxuICAgIH1cblxuICAgIHJlc3VsdC5wdXNoKGN1cnJlbnQpIC8vIEFkZCBsYXN0IGZpZWxkXG4gICAgcmV0dXJuIHJlc3VsdFxuICB9XG5cbiAgLy8gSW1wb3J0IGZyb20gQ1NWXG4gIGltcG9ydEZyb21DU1YoY3N2Q29udGVudDogc3RyaW5nKTogQnVsa09wZXJhdGlvblJlc3VsdCB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHsgcXVlc3Rpb25zLCBlcnJvcnMgfSA9IHRoaXMucGFyc2VDU1YoY3N2Q29udGVudClcblxuICAgICAgaWYgKGVycm9ycy5sZW5ndGggPiAwKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICAgICAgcHJvY2Vzc2VkQ291bnQ6IDAsXG4gICAgICAgICAgZXJyb3JDb3VudDogZXJyb3JzLmxlbmd0aCxcbiAgICAgICAgICBlcnJvcnNcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBsZXQgc3VjY2Vzc0NvdW50ID0gMFxuICAgICAgY29uc3QgaW1wb3J0RXJyb3JzOiBzdHJpbmdbXSA9IFtdXG5cbiAgICAgIHF1ZXN0aW9ucy5mb3JFYWNoKChxdWVzdGlvbkRhdGEsIGluZGV4KSA9PiB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY29uc3QgZnVsbFF1ZXN0aW9uOiBRdWl6UXVlc3Rpb24gPSB7XG4gICAgICAgICAgICBpZDogcXVlc3Rpb25EYXRhLmlkISxcbiAgICAgICAgICAgIHF1ZXN0aW9uOiBxdWVzdGlvbkRhdGEucXVlc3Rpb24hLFxuICAgICAgICAgICAgb3B0aW9uczogcXVlc3Rpb25EYXRhLm9wdGlvbnMhLFxuICAgICAgICAgICAgY29ycmVjdEFuc3dlcjogcXVlc3Rpb25EYXRhLmNvcnJlY3RBbnN3ZXIhLFxuICAgICAgICAgICAgY2F0ZWdvcnk6IHF1ZXN0aW9uRGF0YS5jYXRlZ29yeSEsXG4gICAgICAgICAgICBkaWZmaWN1bHR5OiBxdWVzdGlvbkRhdGEuZGlmZmljdWx0eSEsXG4gICAgICAgICAgICB0eXBlOiBxdWVzdGlvbkRhdGEudHlwZSEsXG4gICAgICAgICAgICBmdW5GYWN0OiBxdWVzdGlvbkRhdGEuZnVuRmFjdCxcbiAgICAgICAgICAgIHRhZ3M6IHF1ZXN0aW9uRGF0YS50YWdzIHx8IFtdLFxuICAgICAgICAgICAgY3JlYXRlZEF0OiBxdWVzdGlvbkRhdGEuY3JlYXRlZEF0ISxcbiAgICAgICAgICAgIHVwZGF0ZWRBdDogcXVlc3Rpb25EYXRhLnVwZGF0ZWRBdCFcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBWYWxpZGF0ZSB0aGUgY29tcGxldGUgcXVlc3Rpb25cbiAgICAgICAgICBjb25zdCB2YWxpZGF0aW9uID0gdGhpcy52YWxpZGF0ZVF1ZXN0aW9uKGZ1bGxRdWVzdGlvbilcbiAgICAgICAgICBpZiAoIXZhbGlkYXRpb24uaXNWYWxpZCkge1xuICAgICAgICAgICAgaW1wb3J0RXJyb3JzLnB1c2goYFF1ZXN0aW9uICR7aW5kZXggKyAxfTogJHt2YWxpZGF0aW9uLmVycm9ycy5qb2luKCcsICcpfWApXG4gICAgICAgICAgICByZXR1cm5cbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aGlzLnNhdmVRdWVzdGlvbihmdWxsUXVlc3Rpb24pXG4gICAgICAgICAgc3VjY2Vzc0NvdW50KytcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICBpbXBvcnRFcnJvcnMucHVzaChgUXVlc3Rpb24gJHtpbmRleCArIDF9OiAke2Vycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogJ1NhdmUgZXJyb3InfWApXG4gICAgICAgIH1cbiAgICAgIH0pXG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHN1Y2Nlc3M6IGltcG9ydEVycm9ycy5sZW5ndGggPT09IDAsXG4gICAgICAgIHByb2Nlc3NlZENvdW50OiBzdWNjZXNzQ291bnQsXG4gICAgICAgIGVycm9yQ291bnQ6IGltcG9ydEVycm9ycy5sZW5ndGgsXG4gICAgICAgIGVycm9yczogaW1wb3J0RXJyb3JzXG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICBwcm9jZXNzZWRDb3VudDogMCxcbiAgICAgICAgZXJyb3JDb3VudDogMSxcbiAgICAgICAgZXJyb3JzOiBbZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiAnSW1wb3J0IGZhaWxlZCddXG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8vIEV4cG9ydCBzaW5nbGV0b24gaW5zdGFuY2VcbmV4cG9ydCBjb25zdCBxdWl6RGF0YU1hbmFnZXIgPSBRdWl6RGF0YU1hbmFnZXIuZ2V0SW5zdGFuY2UoKVxuIl0sIm5hbWVzIjpbIlFVSVpfU1RPUkFHRV9LRVlTIiwiREVGQVVMVF9DQVRFR09SSUVTIiwiVkFMSURBVElPTl9SVUxFUyIsIlFVRVNUSU9OX01JTl9MRU5HVEgiLCJRVUVTVElPTl9NQVhfTEVOR1RIIiwiT1BUSU9OX01JTl9MRU5HVEgiLCJPUFRJT05fTUFYX0xFTkdUSCIsIk1JTl9PUFRJT05TIiwiTUFYX09QVElPTlMiLCJNQVhfQlVMS19PUEVSQVRJT05TIiwiTUFYX0ZJTEVfU0laRSIsIkFVVE9fU0FWRV9JTlRFUlZBTCIsIlF1aXpEYXRhRXJyb3IiLCJFcnJvciIsIm1lc3NhZ2UiLCJjb2RlIiwibmFtZSIsIlF1aXpEYXRhTWFuYWdlciIsImdldEluc3RhbmNlIiwiaW5zdGFuY2UiLCJzYWZlR2V0SXRlbSIsImtleSIsImxvY2FsU3RvcmFnZSIsImdldEl0ZW0iLCJlcnJvciIsImNvbnNvbGUiLCJzYWZlU2V0SXRlbSIsInZhbHVlIiwic2V0SXRlbSIsIkRPTUV4Y2VwdGlvbiIsImdldFF1ZXN0aW9ucyIsImRhdGEiLCJRVUVTVElPTlMiLCJpbml0aWFsaXplV2l0aFNhbXBsZURhdGEiLCJxdWVzdGlvbnMiLCJKU09OIiwicGFyc2UiLCJBcnJheSIsImlzQXJyYXkiLCJnZXRGaWx0ZXJlZFF1ZXN0aW9ucyIsImZpbHRlcnMiLCJmaWx0ZXIiLCJxdWVzdGlvbiIsImNhdGVnb3J5IiwiZGlmZmljdWx0eSIsInR5cGUiLCJzZWN0aW9uIiwic3ViY2F0ZWdvcnkiLCJ0YWdzIiwic29tZSIsInRhZyIsImluY2x1ZGVzIiwiZ2V0UXVlc3Rpb25zQnlTZWN0aW9uIiwiZ2V0UXVlc3Rpb25zQnlDYXRlZ29yeUFuZFNlY3Rpb24iLCJzYXZlUXVlc3Rpb24iLCJ2YWxpZGF0ZVF1ZXN0aW9uIiwibm93IiwiRGF0ZSIsIm5ld1F1ZXN0aW9uIiwiaWQiLCJnZW5lcmF0ZUlkIiwiY3JlYXRlZEF0IiwidXBkYXRlZEF0IiwicHVzaCIsInNhdmVRdWVzdGlvbnMiLCJ1cGRhdGVRdWVzdGlvbiIsInVwZGF0ZXMiLCJpbmRleCIsImZpbmRJbmRleCIsInEiLCJ1cGRhdGVkUXVlc3Rpb24iLCJkZWxldGVRdWVzdGlvbiIsImZpbHRlcmVkUXVlc3Rpb25zIiwibGVuZ3RoIiwiYnVsa0RlbGV0ZSIsImlkcyIsImluaXRpYWxDb3VudCIsImRlbGV0ZWRDb3VudCIsInN1Y2Nlc3MiLCJwcm9jZXNzZWRDb3VudCIsImVycm9yQ291bnQiLCJlcnJvcnMiLCJzZWFyY2hRdWVzdGlvbnMiLCJzZWFyY2hUZXh0Iiwic2VhcmNoTG93ZXIiLCJ0b0xvd2VyQ2FzZSIsImdldENhdGVnb3JpZXMiLCJjYXRlZ29yeUNvdW50cyIsInJlZHVjZSIsImFjYyIsIm1hcCIsInF1ZXN0aW9uQ291bnQiLCJzYXZlRHJhZnQiLCJkcmFmdCIsImRyYWZ0cyIsImdldERyYWZ0cyIsImV4aXN0aW5nSW5kZXgiLCJkIiwibGFzdFNhdmVkIiwiRFJBRlRTIiwic3RyaW5naWZ5IiwiZGVsZXRlRHJhZnQiLCJnZXRTZXR0aW5ncyIsIlNFVFRJTkdTIiwiZ2V0RGVmYXVsdFNldHRpbmdzIiwic2F2ZVNldHRpbmdzIiwic2V0dGluZ3MiLCJjdXJyZW50U2V0dGluZ3MiLCJ1cGRhdGVkU2V0dGluZ3MiLCJwYWdlU2l6ZSIsInNvcnRCeSIsInNvcnRPcmRlciIsInNlbGVjdGVkUXVlc3Rpb25zIiwib3B0aW9ucyIsImZvckVhY2giLCJvcHRpb24iLCJ1bmlxdWVPcHRpb25zIiwiU2V0Iiwib3B0IiwidHJpbSIsInNpemUiLCJjb3JyZWN0QW5zd2VyIiwidmFsaWRDYXRlZ29yaWVzIiwiYyIsIk1hdGgiLCJyYW5kb20iLCJ0b1N0cmluZyIsInN1YnN0ciIsImV4cG9ydFRvQ1NWIiwicXVlc3Rpb25zVG9FeHBvcnQiLCJoZWFkZXJzIiwiY3N2Um93cyIsImpvaW4iLCJyZXBsYWNlIiwiZnVuRmFjdCIsInRvSVNPU3RyaW5nIiwiaW1wb3J0RnJvbUNTViIsImNzdkNvbnRlbnQiLCJsaW5lcyIsInNwbGl0IiwibGluZSIsImgiLCJkYXRhTGluZXMiLCJzbGljZSIsInJlc3VsdHMiLCJ2YWxpZFF1ZXN0aW9ucyIsImV4aXN0aW5nUXVlc3Rpb25zIiwiaSIsInZhbHVlcyIsInBhcnNlQ1NWTGluZSIsInBhcnNlSW50IiwidW5kZWZpbmVkIiwidCIsImdldFRpbWUiLCJhbGxRdWVzdGlvbnMiLCJyZXN1bHQiLCJjdXJyZW50IiwiaW5RdW90ZXMiLCJjaGFyIiwic2FtcGxlUXVlc3Rpb25zIiwiY3JlYXRlQmFja3VwIiwiYmFja3VwIiwidGltZXN0YW1wIiwidmVyc2lvbiIsInJlc3RvcmVGcm9tQmFja3VwIiwiYmFja3VwRGF0YSIsImN1cnJlbnRCYWNrdXAiLCJCQUNLVVAiLCJzdGFydEF1dG9TYXZlIiwiZHJhZnRJZCIsImdldERyYWZ0RGF0YSIsInN0b3BBdXRvU2F2ZSIsImF1dG9TYXZlVGltZXIiLCJzZXRJbnRlcnZhbCIsImRyYWZ0RGF0YSIsImNsZWFySW50ZXJ2YWwiLCJyb3ciLCJkb3dubG9hZENTViIsImJsb2IiLCJCbG9iIiwibGluayIsImRvY3VtZW50IiwiY3JlYXRlRWxlbWVudCIsImRvd25sb2FkIiwidXJsIiwiVVJMIiwiY3JlYXRlT2JqZWN0VVJMIiwic2V0QXR0cmlidXRlIiwic3R5bGUiLCJ2aXNpYmlsaXR5IiwiYm9keSIsImFwcGVuZENoaWxkIiwiY2xpY2siLCJyZW1vdmVDaGlsZCIsInJldm9rZU9iamVjdFVSTCIsInBhcnNlQ1NWIiwib3B0MSIsIm9wdDIiLCJvcHQzIiwib3B0NCIsImNvcnJlY3RBbnN3ZXJOdW0iLCJpc05hTiIsInF1ZXN0aW9uRGF0YSIsIkJvb2xlYW4iLCJzdWNjZXNzQ291bnQiLCJpbXBvcnRFcnJvcnMiLCJmdWxsUXVlc3Rpb24iLCJ2YWxpZGF0aW9uIiwiaXNWYWxpZCIsInF1aXpEYXRhTWFuYWdlciJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/utils/quizDataManager.ts\n"));

/***/ })

});