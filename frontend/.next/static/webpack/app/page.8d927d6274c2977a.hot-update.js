"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./src/utils/quizDataManager.ts":
/*!**************************************!*\
  !*** ./src/utils/quizDataManager.ts ***!
  \**************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   QuizDataError: () => (/* binding */ QuizDataError),\n/* harmony export */   VALIDATION_RULES: () => (/* binding */ VALIDATION_RULES),\n/* harmony export */   quizDataManager: () => (/* binding */ quizDataManager)\n/* harmony export */ });\n/* harmony import */ var _types_admin__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/types/admin */ \"(app-pages-browser)/./src/types/admin.ts\");\n\n// Data validation schemas\nconst VALIDATION_RULES = {\n    QUESTION_MIN_LENGTH: 10,\n    QUESTION_MAX_LENGTH: 500,\n    OPTION_MIN_LENGTH: 1,\n    OPTION_MAX_LENGTH: 100,\n    MIN_OPTIONS: 4,\n    MAX_OPTIONS: 4,\n    MAX_BULK_OPERATIONS: 50,\n    MAX_FILE_SIZE: 5 * 1024 * 1024,\n    AUTO_SAVE_INTERVAL: 30000 // 30 seconds\n};\n// Error types\nclass QuizDataError extends Error {\n    constructor(message, code){\n        super(message), this.code = code;\n        this.name = 'QuizDataError';\n    }\n}\n// Utility functions for localStorage operations\nclass QuizDataManager {\n    static getInstance() {\n        if (!QuizDataManager.instance) {\n            QuizDataManager.instance = new QuizDataManager();\n        }\n        return QuizDataManager.instance;\n    }\n    // Safe localStorage operations with error handling\n    safeGetItem(key) {\n        // Return null if not on client side\n        if (false) {}\n        try {\n            return localStorage.getItem(key);\n        } catch (error) {\n            console.error(\"Error reading from localStorage key \".concat(key, \":\"), error);\n            return null;\n        }\n    }\n    safeSetItem(key, value) {\n        // Return false if not on client side\n        if (false) {}\n        try {\n            localStorage.setItem(key, value);\n            return true;\n        } catch (error) {\n            console.error(\"Error writing to localStorage key \".concat(key, \":\"), error);\n            if (error instanceof DOMException && error.code === 22) {\n                throw new QuizDataError('Storage quota exceeded. Please clear some data.', 'QUOTA_EXCEEDED');\n            }\n            return false;\n        }\n    }\n    // Question CRUD operations\n    getQuestions() {\n        const data = this.safeGetItem(_types_admin__WEBPACK_IMPORTED_MODULE_0__.QUIZ_STORAGE_KEYS.QUESTIONS);\n        if (!data) return this.initializeWithSampleData();\n        try {\n            const questions = JSON.parse(data);\n            return Array.isArray(questions) ? questions : [];\n        } catch (error) {\n            console.error('Error parsing questions data:', error);\n            return this.initializeWithSampleData();\n        }\n    }\n    // Get questions with filtering support\n    getFilteredQuestions(filters) {\n        const questions = this.getQuestions();\n        if (!filters) return questions;\n        return questions.filter((question)=>{\n            if (filters.category && question.category !== filters.category) return false;\n            if (filters.difficulty && question.difficulty !== filters.difficulty) return false;\n            if (filters.type && question.type !== filters.type) return false;\n            if (filters.section && question.section !== filters.section) return false;\n            if (filters.subcategory && question.subcategory !== filters.subcategory) return false;\n            if (filters.tags && !filters.tags.some((tag)=>{\n                var _question_tags;\n                return (_question_tags = question.tags) === null || _question_tags === void 0 ? void 0 : _question_tags.includes(tag);\n            })) return false;\n            return true;\n        });\n    }\n    // Get questions by section\n    getQuestionsBySection(section) {\n        return this.getFilteredQuestions({\n            section\n        });\n    }\n    // Get questions by category and section\n    getQuestionsByCategoryAndSection(category, section) {\n        return this.getFilteredQuestions({\n            category,\n            section\n        });\n    }\n    saveQuestion(question) {\n        this.validateQuestion(question);\n        const questions = this.getQuestions();\n        const now = Date.now();\n        const newQuestion = {\n            ...question,\n            id: this.generateId(),\n            createdAt: now,\n            updatedAt: now\n        };\n        questions.push(newQuestion);\n        this.saveQuestions(questions);\n        return newQuestion;\n    }\n    updateQuestion(id, updates) {\n        const questions = this.getQuestions();\n        const index = questions.findIndex((q)=>q.id === id);\n        if (index === -1) {\n            throw new QuizDataError(\"Question with id \".concat(id, \" not found\"), 'NOT_FOUND');\n        }\n        const updatedQuestion = {\n            ...questions[index],\n            ...updates,\n            updatedAt: Date.now()\n        };\n        this.validateQuestion(updatedQuestion);\n        questions[index] = updatedQuestion;\n        this.saveQuestions(questions);\n        return updatedQuestion;\n    }\n    deleteQuestion(id) {\n        const questions = this.getQuestions();\n        const filteredQuestions = questions.filter((q)=>q.id !== id);\n        if (filteredQuestions.length === questions.length) {\n            throw new QuizDataError(\"Question with id \".concat(id, \" not found\"), 'NOT_FOUND');\n        }\n        this.saveQuestions(filteredQuestions);\n        return true;\n    }\n    bulkDelete(ids) {\n        if (ids.length > VALIDATION_RULES.MAX_BULK_OPERATIONS) {\n            throw new QuizDataError(\"Cannot delete more than \".concat(VALIDATION_RULES.MAX_BULK_OPERATIONS, \" questions at once\"), 'BULK_LIMIT_EXCEEDED');\n        }\n        const questions = this.getQuestions();\n        const initialCount = questions.length;\n        const filteredQuestions = questions.filter((q)=>!ids.includes(q.id));\n        const deletedCount = initialCount - filteredQuestions.length;\n        this.saveQuestions(filteredQuestions);\n        return {\n            success: true,\n            processedCount: deletedCount,\n            errorCount: ids.length - deletedCount,\n            errors: ids.length > deletedCount ? [\n                'Some questions were not found'\n            ] : []\n        };\n    }\n    // Search and filter operations\n    searchQuestions(filters) {\n        const questions = this.getQuestions();\n        return questions.filter((question)=>{\n            // Text search\n            if (filters.searchText) {\n                const searchLower = filters.searchText.toLowerCase();\n                if (!question.question.toLowerCase().includes(searchLower)) {\n                    return false;\n                }\n            }\n            // Category filter\n            if (filters.category !== 'all' && question.category !== filters.category) {\n                return false;\n            }\n            // Difficulty filter\n            if (filters.difficulty !== 'all' && question.difficulty !== filters.difficulty) {\n                return false;\n            }\n            // Type filter\n            if (filters.type !== 'all' && question.type !== filters.type) {\n                return false;\n            }\n            return true;\n        });\n    }\n    // Categories management\n    getCategories() {\n        const questions = this.getQuestions();\n        const categoryCounts = questions.reduce((acc, question)=>{\n            acc[question.category] = (acc[question.category] || 0) + 1;\n            return acc;\n        }, {});\n        return _types_admin__WEBPACK_IMPORTED_MODULE_0__.DEFAULT_CATEGORIES.map((category)=>({\n                ...category,\n                questionCount: categoryCounts[category.id] || 0\n            }));\n    }\n    // Draft management\n    saveDraft(draft) {\n        const drafts = this.getDrafts();\n        const existingIndex = drafts.findIndex((d)=>d.id === draft.id);\n        if (existingIndex >= 0) {\n            drafts[existingIndex] = {\n                ...draft,\n                lastSaved: Date.now()\n            };\n        } else {\n            drafts.push({\n                ...draft,\n                lastSaved: Date.now()\n            });\n        }\n        this.safeSetItem(_types_admin__WEBPACK_IMPORTED_MODULE_0__.QUIZ_STORAGE_KEYS.DRAFTS, JSON.stringify(drafts));\n    }\n    getDrafts() {\n        const data = this.safeGetItem(_types_admin__WEBPACK_IMPORTED_MODULE_0__.QUIZ_STORAGE_KEYS.DRAFTS);\n        if (!data) return [];\n        try {\n            return JSON.parse(data);\n        } catch (error) {\n            console.error('Error parsing drafts data:', error);\n            return [];\n        }\n    }\n    deleteDraft(id) {\n        const drafts = this.getDrafts().filter((d)=>d.id !== id);\n        this.safeSetItem(_types_admin__WEBPACK_IMPORTED_MODULE_0__.QUIZ_STORAGE_KEYS.DRAFTS, JSON.stringify(drafts));\n    }\n    // Settings management\n    getSettings() {\n        const data = this.safeGetItem(_types_admin__WEBPACK_IMPORTED_MODULE_0__.QUIZ_STORAGE_KEYS.SETTINGS);\n        if (!data) return this.getDefaultSettings();\n        try {\n            return {\n                ...this.getDefaultSettings(),\n                ...JSON.parse(data)\n            };\n        } catch (error) {\n            console.error('Error parsing settings data:', error);\n            return this.getDefaultSettings();\n        }\n    }\n    saveSettings(settings) {\n        const currentSettings = this.getSettings();\n        const updatedSettings = {\n            ...currentSettings,\n            ...settings\n        };\n        this.safeSetItem(_types_admin__WEBPACK_IMPORTED_MODULE_0__.QUIZ_STORAGE_KEYS.SETTINGS, JSON.stringify(updatedSettings));\n    }\n    getDefaultSettings() {\n        return {\n            pageSize: 10,\n            sortBy: 'updatedAt',\n            sortOrder: 'desc',\n            filters: {\n                searchText: '',\n                category: 'all',\n                difficulty: 'all',\n                type: 'all'\n            },\n            selectedQuestions: []\n        };\n    }\n    // Validation\n    validateQuestion(question) {\n        if (!question.question || question.question.length < VALIDATION_RULES.QUESTION_MIN_LENGTH) {\n            throw new QuizDataError(\"Question must be at least \".concat(VALIDATION_RULES.QUESTION_MIN_LENGTH, \" characters long\"), 'INVALID_QUESTION_LENGTH');\n        }\n        if (question.question.length > VALIDATION_RULES.QUESTION_MAX_LENGTH) {\n            throw new QuizDataError(\"Question must be no more than \".concat(VALIDATION_RULES.QUESTION_MAX_LENGTH, \" characters long\"), 'INVALID_QUESTION_LENGTH');\n        }\n        if (!question.options || question.options.length !== VALIDATION_RULES.MIN_OPTIONS) {\n            throw new QuizDataError(\"Question must have exactly \".concat(VALIDATION_RULES.MIN_OPTIONS, \" options\"), 'INVALID_OPTIONS_COUNT');\n        }\n        // Validate each option\n        question.options.forEach((option, index)=>{\n            if (!option || option.length < VALIDATION_RULES.OPTION_MIN_LENGTH) {\n                throw new QuizDataError(\"Option \".concat(index + 1, \" must be at least \").concat(VALIDATION_RULES.OPTION_MIN_LENGTH, \" character long\"), 'INVALID_OPTION_LENGTH');\n            }\n            if (option.length > VALIDATION_RULES.OPTION_MAX_LENGTH) {\n                throw new QuizDataError(\"Option \".concat(index + 1, \" must be no more than \").concat(VALIDATION_RULES.OPTION_MAX_LENGTH, \" characters long\"), 'INVALID_OPTION_LENGTH');\n            }\n        });\n        // Check for duplicate options\n        const uniqueOptions = new Set(question.options.map((opt)=>opt.toLowerCase().trim()));\n        if (uniqueOptions.size !== question.options.length) {\n            throw new QuizDataError('All options must be unique', 'DUPLICATE_OPTIONS');\n        }\n        // Validate correct answer\n        if (typeof question.correctAnswer !== 'number' || question.correctAnswer < 0 || question.correctAnswer >= question.options.length) {\n            throw new QuizDataError('Invalid correct answer selection', 'INVALID_CORRECT_ANSWER');\n        }\n        // Validate category\n        const validCategories = _types_admin__WEBPACK_IMPORTED_MODULE_0__.DEFAULT_CATEGORIES.map((c)=>c.id);\n        if (!question.category || !validCategories.includes(question.category)) {\n            throw new QuizDataError('Invalid category selection', 'INVALID_CATEGORY');\n        }\n    }\n    // Utility methods\n    saveQuestions(questions) {\n        this.safeSetItem(_types_admin__WEBPACK_IMPORTED_MODULE_0__.QUIZ_STORAGE_KEYS.QUESTIONS, JSON.stringify(questions));\n    }\n    generateId() {\n        return \"q_\".concat(Date.now(), \"_\").concat(Math.random().toString(36).substr(2, 9));\n    }\n    // CSV Export/Import functionality\n    exportToCSV(questions) {\n        const questionsToExport = questions || this.getQuestions();\n        const headers = [\n            'ID',\n            'Question',\n            'Option 1',\n            'Option 2',\n            'Option 3',\n            'Option 4',\n            'Correct Answer',\n            'Category',\n            'Difficulty',\n            'Type',\n            'Fun Fact',\n            'Tags',\n            'Created At',\n            'Updated At'\n        ];\n        const csvRows = [\n            headers.join(','),\n            ...questionsToExport.map((q)=>[\n                    q.id,\n                    '\"'.concat(q.question.replace(/\"/g, '\"\"'), '\"'),\n                    '\"'.concat(q.options[0].replace(/\"/g, '\"\"'), '\"'),\n                    '\"'.concat(q.options[1].replace(/\"/g, '\"\"'), '\"'),\n                    '\"'.concat(q.options[2].replace(/\"/g, '\"\"'), '\"'),\n                    '\"'.concat(q.options[3].replace(/\"/g, '\"\"'), '\"'),\n                    q.correctAnswer + 1,\n                    q.category,\n                    q.difficulty,\n                    q.type,\n                    '\"'.concat((q.funFact || '').replace(/\"/g, '\"\"'), '\"'),\n                    '\"'.concat((q.tags || []).join(';'), '\"'),\n                    new Date(q.createdAt).toISOString(),\n                    new Date(q.updatedAt).toISOString()\n                ].join(','))\n        ];\n        // Add UTF-8 BOM for Excel compatibility\n        return '\\uFEFF' + csvRows.join('\\n');\n    }\n    async importFromCSV(csvContent) {\n        const lines = csvContent.split('\\n').filter((line)=>line.trim());\n        if (lines.length < 2) {\n            throw new QuizDataError('CSV file must contain at least a header and one data row', 'INVALID_CSV_FORMAT');\n        }\n        const headers = lines[0].split(',').map((h)=>h.trim().replace(/\"/g, ''));\n        const dataLines = lines.slice(1);\n        const results = {\n            success: true,\n            processedCount: 0,\n            errorCount: 0,\n            errors: []\n        };\n        const validQuestions = [];\n        const existingQuestions = this.getQuestions();\n        for(let i = 0; i < dataLines.length; i++){\n            try {\n                const values = this.parseCSVLine(dataLines[i]);\n                if (values.length < 8) {\n                    results.errors.push(\"Line \".concat(i + 2, \": Insufficient data columns\"));\n                    results.errorCount++;\n                    continue;\n                }\n                const question = {\n                    id: values[0] || this.generateId(),\n                    question: values[1],\n                    options: [\n                        values[2],\n                        values[3],\n                        values[4],\n                        values[5]\n                    ],\n                    correctAnswer: parseInt(values[6]) - 1,\n                    category: values[7],\n                    difficulty: values[8],\n                    type: values[9] || 'regular',\n                    funFact: values[10] || undefined,\n                    tags: values[11] ? values[11].split(';').filter((t)=>t.trim()) : undefined,\n                    createdAt: values[12] ? new Date(values[12]).getTime() : Date.now(),\n                    updatedAt: values[13] ? new Date(values[13]).getTime() : Date.now()\n                };\n                // Validate the question\n                this.validateQuestion(question);\n                // Check for duplicates\n                const existingIndex = existingQuestions.findIndex((q)=>q.id === question.id);\n                if (existingIndex >= 0) {\n                    // Update existing question\n                    existingQuestions[existingIndex] = question;\n                } else {\n                    validQuestions.push(question);\n                }\n                results.processedCount++;\n            } catch (error) {\n                results.errors.push(\"Line \".concat(i + 2, \": \").concat(error instanceof Error ? error.message : 'Unknown error'));\n                results.errorCount++;\n            }\n        }\n        // Save all valid questions\n        if (validQuestions.length > 0) {\n            const allQuestions = [\n                ...existingQuestions,\n                ...validQuestions\n            ];\n            this.saveQuestions(allQuestions);\n        }\n        results.success = results.errorCount === 0;\n        return results;\n    }\n    parseCSVLine(line) {\n        const result = [];\n        let current = '';\n        let inQuotes = false;\n        for(let i = 0; i < line.length; i++){\n            const char = line[i];\n            if (char === '\"') {\n                if (inQuotes && line[i + 1] === '\"') {\n                    current += '\"';\n                    i++; // Skip next quote\n                } else {\n                    inQuotes = !inQuotes;\n                }\n            } else if (char === ',' && !inQuotes) {\n                result.push(current.trim());\n                current = '';\n            } else {\n                current += char;\n            }\n        }\n        result.push(current.trim());\n        return result;\n    }\n    initializeWithSampleData() {\n        // Check if we should import existing questions\n        if (this.shouldImportExistingQuestions()) {\n            return this.importAllExistingQuestions();\n        }\n        // Initialize with a few sample questions for demonstration\n        const sampleQuestions = [\n            {\n                id: 'sample_1',\n                question: 'Which social media platform is known for its short-form video content and viral dances?',\n                options: [\n                    'Instagram',\n                    'TikTok',\n                    'Twitter',\n                    'Snapchat'\n                ],\n                correctAnswer: 1,\n                category: 'social-media',\n                difficulty: 'beginner',\n                type: 'regular',\n                section: 'homepage',\n                funFact: 'TikTok was originally called Musical.ly before being acquired by ByteDance.',\n                tags: [\n                    'social-media',\n                    'video',\n                    'viral'\n                ],\n                createdAt: Date.now() - 86400000,\n                updatedAt: Date.now() - 86400000\n            }\n        ];\n        this.saveQuestions(sampleQuestions);\n        return sampleQuestions;\n    }\n    // Check if we should import existing questions\n    shouldImportExistingQuestions() {\n        // Only import if localStorage is empty and we're on client side\n        if (false) {}\n        const hasImported = this.safeGetItem('quiz_questions_imported');\n        return !hasImported;\n    }\n    // Import all existing questions from different sources\n    importAllExistingQuestions() {\n        const allQuestions = [];\n        try {\n            // Import onboarding questions\n            const onboardingQuestions = this.importOnboardingQuestions();\n            allQuestions.push(...onboardingQuestions);\n            // Import homepage fallback questions\n            const homepageQuestions = this.importHomepageQuestions();\n            allQuestions.push(...homepageQuestions);\n            // Import category questions from quiz database\n            const categoryQuestions = this.importCategoryQuestions();\n            allQuestions.push(...categoryQuestions);\n            console.log(\"\\uD83D\\uDCCA Imported \".concat(allQuestions.length, \" questions from existing sources\"));\n            // Save all imported questions\n            this.saveQuestions(allQuestions);\n            // Mark as imported\n            this.safeSetItem('quiz_questions_imported', 'true');\n            return allQuestions;\n        } catch (error) {\n            console.error('Error importing existing questions:', error);\n            return [];\n        }\n    }\n    // Backup and restore functionality\n    createBackup() {\n        const backup = {\n            questions: this.getQuestions(),\n            settings: this.getSettings(),\n            drafts: this.getDrafts(),\n            timestamp: Date.now(),\n            version: '1.0'\n        };\n        return JSON.stringify(backup, null, 2);\n    }\n    restoreFromBackup(backupData) {\n        try {\n            const backup = JSON.parse(backupData);\n            if (!backup.questions || !Array.isArray(backup.questions)) {\n                throw new QuizDataError('Invalid backup format: missing questions array', 'INVALID_BACKUP');\n            }\n            // Validate all questions in backup\n            backup.questions.forEach((q, index)=>{\n                try {\n                    this.validateQuestion(q);\n                } catch (error) {\n                    throw new QuizDataError(\"Invalid question at index \".concat(index, \": \").concat(error instanceof Error ? error.message : 'Unknown error'), 'INVALID_BACKUP_QUESTION');\n                }\n            });\n            // Create current backup before restore\n            const currentBackup = this.createBackup();\n            this.safeSetItem(_types_admin__WEBPACK_IMPORTED_MODULE_0__.QUIZ_STORAGE_KEYS.BACKUP, currentBackup);\n            // Restore data\n            this.saveQuestions(backup.questions);\n            if (backup.settings) {\n                this.safeSetItem(_types_admin__WEBPACK_IMPORTED_MODULE_0__.QUIZ_STORAGE_KEYS.SETTINGS, JSON.stringify(backup.settings));\n            }\n            if (backup.drafts) {\n                this.safeSetItem(_types_admin__WEBPACK_IMPORTED_MODULE_0__.QUIZ_STORAGE_KEYS.DRAFTS, JSON.stringify(backup.drafts));\n            }\n            return {\n                success: true,\n                processedCount: backup.questions.length,\n                errorCount: 0,\n                errors: []\n            };\n        } catch (error) {\n            throw new QuizDataError(\"Failed to restore backup: \".concat(error instanceof Error ? error.message : 'Unknown error'), 'RESTORE_FAILED');\n        }\n    }\n    // Auto-save functionality for drafts\n    startAutoSave(draftId, getDraftData) {\n        this.stopAutoSave();\n        this.autoSaveTimer = setInterval(()=>{\n            try {\n                const draftData = getDraftData();\n                if (draftData.question && draftData.question.length > 0) {\n                    const draft = {\n                        id: draftId,\n                        question: draftData.question || '',\n                        options: draftData.options || [\n                            '',\n                            '',\n                            '',\n                            ''\n                        ],\n                        correctAnswer: draftData.correctAnswer || 0,\n                        category: draftData.category || 'facts',\n                        difficulty: draftData.difficulty || 'beginner',\n                        type: draftData.type || 'regular',\n                        funFact: draftData.funFact,\n                        tags: draftData.tags,\n                        lastSaved: Date.now()\n                    };\n                    this.saveDraft(draft);\n                }\n            } catch (error) {\n                console.error('Auto-save failed:', error);\n            }\n        }, VALIDATION_RULES.AUTO_SAVE_INTERVAL);\n    }\n    stopAutoSave() {\n        if (this.autoSaveTimer) {\n            clearInterval(this.autoSaveTimer);\n            this.autoSaveTimer = null;\n        }\n    }\n    // CSV Export functionality\n    exportToCSV(questionsToExport) {\n        const questions = questionsToExport || this.getQuestions();\n        const headers = [\n            'ID',\n            'Question',\n            'Option 1',\n            'Option 2',\n            'Option 3',\n            'Option 4',\n            'Correct Answer (1-4)',\n            'Category',\n            'Difficulty',\n            'Type',\n            'Fun Fact',\n            'Tags',\n            'Created At',\n            'Updated At'\n        ];\n        const csvRows = [\n            headers.join(',')\n        ];\n        questions.forEach((question)=>{\n            var _question_options_, _question_options_1, _question_options_2, _question_options_3;\n            const row = [\n                question.id,\n                '\"'.concat(question.question.replace(/\"/g, '\"\"'), '\"'),\n                '\"'.concat(((_question_options_ = question.options[0]) === null || _question_options_ === void 0 ? void 0 : _question_options_.replace(/\"/g, '\"\"')) || '', '\"'),\n                '\"'.concat(((_question_options_1 = question.options[1]) === null || _question_options_1 === void 0 ? void 0 : _question_options_1.replace(/\"/g, '\"\"')) || '', '\"'),\n                '\"'.concat(((_question_options_2 = question.options[2]) === null || _question_options_2 === void 0 ? void 0 : _question_options_2.replace(/\"/g, '\"\"')) || '', '\"'),\n                '\"'.concat(((_question_options_3 = question.options[3]) === null || _question_options_3 === void 0 ? void 0 : _question_options_3.replace(/\"/g, '\"\"')) || '', '\"'),\n                question.correctAnswer + 1,\n                question.category,\n                question.difficulty,\n                question.type,\n                '\"'.concat((question.funFact || '').replace(/\"/g, '\"\"'), '\"'),\n                '\"'.concat((question.tags || []).join(';'), '\"'),\n                new Date(question.createdAt).toISOString(),\n                new Date(question.updatedAt).toISOString()\n            ];\n            csvRows.push(row.join(','));\n        });\n        return csvRows.join('\\n');\n    }\n    // Download CSV file\n    downloadCSV() {\n        try {\n            const csvContent = this.exportToCSV();\n            const blob = new Blob([\n                csvContent\n            ], {\n                type: 'text/csv;charset=utf-8;'\n            });\n            const link = document.createElement('a');\n            if (link.download !== undefined) {\n                const url = URL.createObjectURL(blob);\n                link.setAttribute('href', url);\n                link.setAttribute('download', \"techkwiz-questions-\".concat(new Date().toISOString().split('T')[0], \".csv\"));\n                link.style.visibility = 'hidden';\n                document.body.appendChild(link);\n                link.click();\n                document.body.removeChild(link);\n                URL.revokeObjectURL(url);\n            }\n        } catch (error) {\n            throw new QuizDataError('Failed to download CSV file', 'EXPORT_ERROR');\n        }\n    }\n    // Parse CSV content\n    parseCSV(csvContent) {\n        const lines = csvContent.split('\\n').filter((line)=>line.trim());\n        const errors = [];\n        const questions = [];\n        if (lines.length < 2) {\n            errors.push('CSV file must contain at least a header row and one data row');\n            return {\n                questions,\n                errors\n            };\n        }\n        // Skip header row\n        const dataLines = lines.slice(1);\n        dataLines.forEach((line, index)=>{\n            try {\n                const values = this.parseCSVLine(line);\n                if (values.length < 8) {\n                    errors.push(\"Row \".concat(index + 2, \": Insufficient columns (minimum 8 required)\"));\n                    return;\n                }\n                const [id, question, opt1, opt2, opt3, opt4, correctAnswer, category, difficulty, type, funFact, tags, createdAt, updatedAt] = values;\n                // Validate required fields\n                if (!(question === null || question === void 0 ? void 0 : question.trim())) {\n                    errors.push(\"Row \".concat(index + 2, \": Question is required\"));\n                    return;\n                }\n                if (!(opt1 === null || opt1 === void 0 ? void 0 : opt1.trim()) || !(opt2 === null || opt2 === void 0 ? void 0 : opt2.trim()) || !(opt3 === null || opt3 === void 0 ? void 0 : opt3.trim()) || !(opt4 === null || opt4 === void 0 ? void 0 : opt4.trim())) {\n                    errors.push(\"Row \".concat(index + 2, \": All 4 options are required\"));\n                    return;\n                }\n                const correctAnswerNum = parseInt(correctAnswer) - 1 // Convert 1-based to 0-based\n                ;\n                if (isNaN(correctAnswerNum) || correctAnswerNum < 0 || correctAnswerNum > 3) {\n                    errors.push(\"Row \".concat(index + 2, \": Correct answer must be 1, 2, 3, or 4\"));\n                    return;\n                }\n                if (!(category === null || category === void 0 ? void 0 : category.trim())) {\n                    errors.push(\"Row \".concat(index + 2, \": Category is required\"));\n                    return;\n                }\n                if (![\n                    'beginner',\n                    'intermediate',\n                    'advanced'\n                ].includes(difficulty)) {\n                    errors.push(\"Row \".concat(index + 2, \": Difficulty must be 'beginner', 'intermediate', or 'advanced'\"));\n                    return;\n                }\n                if (![\n                    'regular',\n                    'bonus'\n                ].includes(type)) {\n                    errors.push(\"Row \".concat(index + 2, \": Type must be 'regular' or 'bonus'\"));\n                    return;\n                }\n                const questionData = {\n                    id: id || \"imported_\".concat(Date.now(), \"_\").concat(index),\n                    question: question.trim(),\n                    options: [\n                        opt1.trim(),\n                        opt2.trim(),\n                        opt3.trim(),\n                        opt4.trim()\n                    ],\n                    correctAnswer: correctAnswerNum,\n                    category: category.trim(),\n                    difficulty: difficulty,\n                    type: type,\n                    funFact: (funFact === null || funFact === void 0 ? void 0 : funFact.trim()) || undefined,\n                    tags: tags ? tags.split(';').map((tag)=>tag.trim()).filter(Boolean) : [],\n                    createdAt: createdAt ? new Date(createdAt).getTime() : Date.now(),\n                    updatedAt: updatedAt ? new Date(updatedAt).getTime() : Date.now()\n                };\n                questions.push(questionData);\n            } catch (error) {\n                errors.push(\"Row \".concat(index + 2, \": \").concat(error instanceof Error ? error.message : 'Parse error'));\n            }\n        });\n        return {\n            questions,\n            errors\n        };\n    }\n    // Helper to parse CSV line with proper quote handling\n    parseCSVLine(line) {\n        const result = [];\n        let current = '';\n        let inQuotes = false;\n        let i = 0;\n        while(i < line.length){\n            const char = line[i];\n            if (char === '\"') {\n                if (inQuotes && line[i + 1] === '\"') {\n                    // Escaped quote\n                    current += '\"';\n                    i += 2;\n                } else {\n                    // Toggle quote state\n                    inQuotes = !inQuotes;\n                    i++;\n                }\n            } else if (char === ',' && !inQuotes) {\n                // End of field\n                result.push(current);\n                current = '';\n                i++;\n            } else {\n                current += char;\n                i++;\n            }\n        }\n        result.push(current); // Add last field\n        return result;\n    }\n    // Import from CSV\n    importFromCSV(csvContent) {\n        try {\n            const { questions, errors } = this.parseCSV(csvContent);\n            if (errors.length > 0) {\n                return {\n                    success: false,\n                    processedCount: 0,\n                    errorCount: errors.length,\n                    errors\n                };\n            }\n            let successCount = 0;\n            const importErrors = [];\n            questions.forEach((questionData, index)=>{\n                try {\n                    const fullQuestion = {\n                        id: questionData.id,\n                        question: questionData.question,\n                        options: questionData.options,\n                        correctAnswer: questionData.correctAnswer,\n                        category: questionData.category,\n                        difficulty: questionData.difficulty,\n                        type: questionData.type,\n                        funFact: questionData.funFact,\n                        tags: questionData.tags || [],\n                        createdAt: questionData.createdAt,\n                        updatedAt: questionData.updatedAt\n                    };\n                    // Validate the complete question\n                    const validation = this.validateQuestion(fullQuestion);\n                    if (!validation.isValid) {\n                        importErrors.push(\"Question \".concat(index + 1, \": \").concat(validation.errors.join(', ')));\n                        return;\n                    }\n                    this.saveQuestion(fullQuestion);\n                    successCount++;\n                } catch (error) {\n                    importErrors.push(\"Question \".concat(index + 1, \": \").concat(error instanceof Error ? error.message : 'Save error'));\n                }\n            });\n            return {\n                success: importErrors.length === 0,\n                processedCount: successCount,\n                errorCount: importErrors.length,\n                errors: importErrors\n            };\n        } catch (error) {\n            return {\n                success: false,\n                processedCount: 0,\n                errorCount: 1,\n                errors: [\n                    error instanceof Error ? error.message : 'Import failed'\n                ]\n            };\n        }\n    }\n    constructor(){\n        this.autoSaveTimer = null;\n    }\n}\n// Export singleton instance\nconst quizDataManager = QuizDataManager.getInstance();\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy91dGlscy9xdWl6RGF0YU1hbmFnZXIudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQVNzQjtBQUV0QiwwQkFBMEI7QUFDbkIsTUFBTUUsbUJBQW1CO0lBQzlCQyxxQkFBcUI7SUFDckJDLHFCQUFxQjtJQUNyQkMsbUJBQW1CO0lBQ25CQyxtQkFBbUI7SUFDbkJDLGFBQWE7SUFDYkMsYUFBYTtJQUNiQyxxQkFBcUI7SUFDckJDLGVBQWUsSUFBSSxPQUFPO0lBQzFCQyxvQkFBb0IsTUFBTSxhQUFhO0FBQ3pDLEVBQVU7QUFFVixjQUFjO0FBQ1AsTUFBTUMsc0JBQXNCQztJQUNqQyxZQUFZQyxPQUFlLEVBQUUsSUFBbUIsQ0FBRTtRQUNoRCxLQUFLLENBQUNBLGVBRDRCQyxPQUFBQTtRQUVsQyxJQUFJLENBQUNDLElBQUksR0FBRztJQUNkO0FBQ0Y7QUFFQSxnREFBZ0Q7QUFDaEQsTUFBTUM7SUFJSixPQUFPQyxjQUErQjtRQUNwQyxJQUFJLENBQUNELGdCQUFnQkUsUUFBUSxFQUFFO1lBQzdCRixnQkFBZ0JFLFFBQVEsR0FBRyxJQUFJRjtRQUNqQztRQUNBLE9BQU9BLGdCQUFnQkUsUUFBUTtJQUNqQztJQUVBLG1EQUFtRDtJQUMzQ0MsWUFBWUMsR0FBVyxFQUFpQjtRQUM5QyxvQ0FBb0M7UUFDcEMsSUFBSSxLQUE2QixFQUFFLEVBRWxDO1FBRUQsSUFBSTtZQUNGLE9BQU9DLGFBQWFDLE9BQU8sQ0FBQ0Y7UUFDOUIsRUFBRSxPQUFPRyxPQUFPO1lBQ2RDLFFBQVFELEtBQUssQ0FBQyx1Q0FBMkMsT0FBSkgsS0FBSSxNQUFJRztZQUM3RCxPQUFPO1FBQ1Q7SUFDRjtJQUVRRSxZQUFZTCxHQUFXLEVBQUVNLEtBQWEsRUFBVztRQUN2RCxxQ0FBcUM7UUFDckMsSUFBSSxLQUE2QixFQUFFLEVBRWxDO1FBRUQsSUFBSTtZQUNGTCxhQUFhTSxPQUFPLENBQUNQLEtBQUtNO1lBQzFCLE9BQU87UUFDVCxFQUFFLE9BQU9ILE9BQU87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QSxJQUFJLENBQUM5RSxZQUFZLENBQUNrSztvQkFDbEJGO2dCQUNGLEVBQUUsT0FBTzlMLE9BQU87b0JBQ2QrTCxhQUFheEosSUFBSSxDQUFDLFlBQTBCdkMsT0FBZDJDLFFBQVEsR0FBRSxNQUEwRCxPQUF0RDNDLGlCQUFpQlgsUUFBUVcsTUFBTVYsT0FBTyxHQUFHO2dCQUN2RjtZQUNGO1lBRUEsT0FBTztnQkFDTGdFLFNBQVN5SSxhQUFhOUksTUFBTSxLQUFLO2dCQUNqQ00sZ0JBQWdCdUk7Z0JBQ2hCdEksWUFBWXVJLGFBQWE5SSxNQUFNO2dCQUMvQlEsUUFBUXNJO1lBQ1Y7UUFDRixFQUFFLE9BQU8vTCxPQUFPO1lBQ2QsT0FBTztnQkFDTHNELFNBQVM7Z0JBQ1RDLGdCQUFnQjtnQkFDaEJDLFlBQVk7Z0JBQ1pDLFFBQVE7b0JBQUN6RCxpQkFBaUJYLFFBQVFXLE1BQU1WLE9BQU8sR0FBRztpQkFBZ0I7WUFDcEU7UUFDRjtJQUNGOzthQW4zQlF3SyxnQkFBdUM7O0FBbzNCakQ7QUFFQSw0QkFBNEI7QUFDckIsTUFBTXFDLGtCQUFrQjFNLGdCQUFnQkMsV0FBVyxHQUFFIiwic291cmNlcyI6WyIvVXNlcnMvamFzZWVtL0RvY3VtZW50cy9HaXRIdWIvVGVjaGt3aXotdjcvZnJvbnRlbmQvc3JjL3V0aWxzL3F1aXpEYXRhTWFuYWdlci50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBcbiAgUXVpelF1ZXN0aW9uLCBcbiAgUXVpekNhdGVnb3J5LCBcbiAgU2VhcmNoRmlsdGVycywgXG4gIEJ1bGtPcGVyYXRpb25SZXN1bHQsIFxuICBRdWVzdGlvbkRyYWZ0LFxuICBRdWl6TWFuYWdlbWVudFNldHRpbmdzLFxuICBRVUlaX1NUT1JBR0VfS0VZUyxcbiAgREVGQVVMVF9DQVRFR09SSUVTIFxufSBmcm9tICdAL3R5cGVzL2FkbWluJ1xuXG4vLyBEYXRhIHZhbGlkYXRpb24gc2NoZW1hc1xuZXhwb3J0IGNvbnN0IFZBTElEQVRJT05fUlVMRVMgPSB7XG4gIFFVRVNUSU9OX01JTl9MRU5HVEg6IDEwLFxuICBRVUVTVElPTl9NQVhfTEVOR1RIOiA1MDAsXG4gIE9QVElPTl9NSU5fTEVOR1RIOiAxLFxuICBPUFRJT05fTUFYX0xFTkdUSDogMTAwLFxuICBNSU5fT1BUSU9OUzogNCxcbiAgTUFYX09QVElPTlM6IDQsXG4gIE1BWF9CVUxLX09QRVJBVElPTlM6IDUwLFxuICBNQVhfRklMRV9TSVpFOiA1ICogMTAyNCAqIDEwMjQsIC8vIDVNQlxuICBBVVRPX1NBVkVfSU5URVJWQUw6IDMwMDAwIC8vIDMwIHNlY29uZHNcbn0gYXMgY29uc3RcblxuLy8gRXJyb3IgdHlwZXNcbmV4cG9ydCBjbGFzcyBRdWl6RGF0YUVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihtZXNzYWdlOiBzdHJpbmcsIHB1YmxpYyBjb2RlOiBzdHJpbmcpIHtcbiAgICBzdXBlcihtZXNzYWdlKVxuICAgIHRoaXMubmFtZSA9ICdRdWl6RGF0YUVycm9yJ1xuICB9XG59XG5cbi8vIFV0aWxpdHkgZnVuY3Rpb25zIGZvciBsb2NhbFN0b3JhZ2Ugb3BlcmF0aW9uc1xuY2xhc3MgUXVpekRhdGFNYW5hZ2VyIHtcbiAgcHJpdmF0ZSBzdGF0aWMgaW5zdGFuY2U6IFF1aXpEYXRhTWFuYWdlclxuICBwcml2YXRlIGF1dG9TYXZlVGltZXI6IE5vZGVKUy5UaW1lb3V0IHwgbnVsbCA9IG51bGxcblxuICBzdGF0aWMgZ2V0SW5zdGFuY2UoKTogUXVpekRhdGFNYW5hZ2VyIHtcbiAgICBpZiAoIVF1aXpEYXRhTWFuYWdlci5pbnN0YW5jZSkge1xuICAgICAgUXVpekRhdGFNYW5hZ2VyLmluc3RhbmNlID0gbmV3IFF1aXpEYXRhTWFuYWdlcigpXG4gICAgfVxuICAgIHJldHVybiBRdWl6RGF0YU1hbmFnZXIuaW5zdGFuY2VcbiAgfVxuXG4gIC8vIFNhZmUgbG9jYWxTdG9yYWdlIG9wZXJhdGlvbnMgd2l0aCBlcnJvciBoYW5kbGluZ1xuICBwcml2YXRlIHNhZmVHZXRJdGVtKGtleTogc3RyaW5nKTogc3RyaW5nIHwgbnVsbCB7XG4gICAgLy8gUmV0dXJuIG51bGwgaWYgbm90IG9uIGNsaWVudCBzaWRlXG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICByZXR1cm4gbnVsbFxuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICByZXR1cm4gbG9jYWxTdG9yYWdlLmdldEl0ZW0oa2V5KVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKGBFcnJvciByZWFkaW5nIGZyb20gbG9jYWxTdG9yYWdlIGtleSAke2tleX06YCwgZXJyb3IpXG4gICAgICByZXR1cm4gbnVsbFxuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgc2FmZVNldEl0ZW0oa2V5OiBzdHJpbmcsIHZhbHVlOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgICAvLyBSZXR1cm4gZmFsc2UgaWYgbm90IG9uIGNsaWVudCBzaWRlXG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oa2V5LCB2YWx1ZSlcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yIHdyaXRpbmcgdG8gbG9jYWxTdG9yYWdlIGtleSAke2tleX06YCwgZXJyb3IpXG4gICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBET01FeGNlcHRpb24gJiYgZXJyb3IuY29kZSA9PT0gMjIpIHtcbiAgICAgICAgdGhyb3cgbmV3IFF1aXpEYXRhRXJyb3IoJ1N0b3JhZ2UgcXVvdGEgZXhjZWVkZWQuIFBsZWFzZSBjbGVhciBzb21lIGRhdGEuJywgJ1FVT1RBX0VYQ0VFREVEJylcbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cbiAgfVxuXG4gIC8vIFF1ZXN0aW9uIENSVUQgb3BlcmF0aW9uc1xuICBnZXRRdWVzdGlvbnMoKTogUXVpelF1ZXN0aW9uW10ge1xuICAgIGNvbnN0IGRhdGEgPSB0aGlzLnNhZmVHZXRJdGVtKFFVSVpfU1RPUkFHRV9LRVlTLlFVRVNUSU9OUylcbiAgICBpZiAoIWRhdGEpIHJldHVybiB0aGlzLmluaXRpYWxpemVXaXRoU2FtcGxlRGF0YSgpXG5cbiAgICB0cnkge1xuICAgICAgY29uc3QgcXVlc3Rpb25zID0gSlNPTi5wYXJzZShkYXRhKVxuICAgICAgcmV0dXJuIEFycmF5LmlzQXJyYXkocXVlc3Rpb25zKSA/IHF1ZXN0aW9ucyA6IFtdXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIHBhcnNpbmcgcXVlc3Rpb25zIGRhdGE6JywgZXJyb3IpXG4gICAgICByZXR1cm4gdGhpcy5pbml0aWFsaXplV2l0aFNhbXBsZURhdGEoKVxuICAgIH1cbiAgfVxuXG4gIC8vIEdldCBxdWVzdGlvbnMgd2l0aCBmaWx0ZXJpbmcgc3VwcG9ydFxuICBnZXRGaWx0ZXJlZFF1ZXN0aW9ucyhmaWx0ZXJzPzoge1xuICAgIGNhdGVnb3J5Pzogc3RyaW5nXG4gICAgZGlmZmljdWx0eT86ICdiZWdpbm5lcicgfCAnaW50ZXJtZWRpYXRlJyB8ICdhZHZhbmNlZCdcbiAgICB0eXBlPzogJ3JlZ3VsYXInIHwgJ2JvbnVzJ1xuICAgIHNlY3Rpb24/OiAnb25ib2FyZGluZycgfCAnaG9tZXBhZ2UnIHwgJ2NhdGVnb3J5JyB8ICdnZW5lcmFsJ1xuICAgIHN1YmNhdGVnb3J5Pzogc3RyaW5nXG4gICAgdGFncz86IHN0cmluZ1tdXG4gIH0pOiBRdWl6UXVlc3Rpb25bXSB7XG4gICAgY29uc3QgcXVlc3Rpb25zID0gdGhpcy5nZXRRdWVzdGlvbnMoKVxuXG4gICAgaWYgKCFmaWx0ZXJzKSByZXR1cm4gcXVlc3Rpb25zXG5cbiAgICByZXR1cm4gcXVlc3Rpb25zLmZpbHRlcihxdWVzdGlvbiA9PiB7XG4gICAgICBpZiAoZmlsdGVycy5jYXRlZ29yeSAmJiBxdWVzdGlvbi5jYXRlZ29yeSAhPT0gZmlsdGVycy5jYXRlZ29yeSkgcmV0dXJuIGZhbHNlXG4gICAgICBpZiAoZmlsdGVycy5kaWZmaWN1bHR5ICYmIHF1ZXN0aW9uLmRpZmZpY3VsdHkgIT09IGZpbHRlcnMuZGlmZmljdWx0eSkgcmV0dXJuIGZhbHNlXG4gICAgICBpZiAoZmlsdGVycy50eXBlICYmIHF1ZXN0aW9uLnR5cGUgIT09IGZpbHRlcnMudHlwZSkgcmV0dXJuIGZhbHNlXG4gICAgICBpZiAoZmlsdGVycy5zZWN0aW9uICYmIHF1ZXN0aW9uLnNlY3Rpb24gIT09IGZpbHRlcnMuc2VjdGlvbikgcmV0dXJuIGZhbHNlXG4gICAgICBpZiAoZmlsdGVycy5zdWJjYXRlZ29yeSAmJiBxdWVzdGlvbi5zdWJjYXRlZ29yeSAhPT0gZmlsdGVycy5zdWJjYXRlZ29yeSkgcmV0dXJuIGZhbHNlXG4gICAgICBpZiAoZmlsdGVycy50YWdzICYmICFmaWx0ZXJzLnRhZ3Muc29tZSh0YWcgPT4gcXVlc3Rpb24udGFncz8uaW5jbHVkZXModGFnKSkpIHJldHVybiBmYWxzZVxuICAgICAgcmV0dXJuIHRydWVcbiAgICB9KVxuICB9XG5cbiAgLy8gR2V0IHF1ZXN0aW9ucyBieSBzZWN0aW9uXG4gIGdldFF1ZXN0aW9uc0J5U2VjdGlvbihzZWN0aW9uOiAnb25ib2FyZGluZycgfCAnaG9tZXBhZ2UnIHwgJ2NhdGVnb3J5JyB8ICdnZW5lcmFsJyk6IFF1aXpRdWVzdGlvbltdIHtcbiAgICByZXR1cm4gdGhpcy5nZXRGaWx0ZXJlZFF1ZXN0aW9ucyh7IHNlY3Rpb24gfSlcbiAgfVxuXG4gIC8vIEdldCBxdWVzdGlvbnMgYnkgY2F0ZWdvcnkgYW5kIHNlY3Rpb25cbiAgZ2V0UXVlc3Rpb25zQnlDYXRlZ29yeUFuZFNlY3Rpb24oY2F0ZWdvcnk6IHN0cmluZywgc2VjdGlvbj86ICdvbmJvYXJkaW5nJyB8ICdob21lcGFnZScgfCAnY2F0ZWdvcnknIHwgJ2dlbmVyYWwnKTogUXVpelF1ZXN0aW9uW10ge1xuICAgIHJldHVybiB0aGlzLmdldEZpbHRlcmVkUXVlc3Rpb25zKHsgY2F0ZWdvcnksIHNlY3Rpb24gfSlcbiAgfVxuXG4gIHNhdmVRdWVzdGlvbihxdWVzdGlvbjogT21pdDxRdWl6UXVlc3Rpb24sICdpZCcgfCAnY3JlYXRlZEF0JyB8ICd1cGRhdGVkQXQnPik6IFF1aXpRdWVzdGlvbiB7XG4gICAgdGhpcy52YWxpZGF0ZVF1ZXN0aW9uKHF1ZXN0aW9uKVxuICAgIFxuICAgIGNvbnN0IHF1ZXN0aW9ucyA9IHRoaXMuZ2V0UXVlc3Rpb25zKClcbiAgICBjb25zdCBub3cgPSBEYXRlLm5vdygpXG4gICAgY29uc3QgbmV3UXVlc3Rpb246IFF1aXpRdWVzdGlvbiA9IHtcbiAgICAgIC4uLnF1ZXN0aW9uLFxuICAgICAgaWQ6IHRoaXMuZ2VuZXJhdGVJZCgpLFxuICAgICAgY3JlYXRlZEF0OiBub3csXG4gICAgICB1cGRhdGVkQXQ6IG5vd1xuICAgIH1cbiAgICBcbiAgICBxdWVzdGlvbnMucHVzaChuZXdRdWVzdGlvbilcbiAgICB0aGlzLnNhdmVRdWVzdGlvbnMocXVlc3Rpb25zKVxuICAgIHJldHVybiBuZXdRdWVzdGlvblxuICB9XG5cbiAgdXBkYXRlUXVlc3Rpb24oaWQ6IHN0cmluZywgdXBkYXRlczogUGFydGlhbDxPbWl0PFF1aXpRdWVzdGlvbiwgJ2lkJyB8ICdjcmVhdGVkQXQnPj4pOiBRdWl6UXVlc3Rpb24ge1xuICAgIGNvbnN0IHF1ZXN0aW9ucyA9IHRoaXMuZ2V0UXVlc3Rpb25zKClcbiAgICBjb25zdCBpbmRleCA9IHF1ZXN0aW9ucy5maW5kSW5kZXgocSA9PiBxLmlkID09PSBpZClcbiAgICBcbiAgICBpZiAoaW5kZXggPT09IC0xKSB7XG4gICAgICB0aHJvdyBuZXcgUXVpekRhdGFFcnJvcihgUXVlc3Rpb24gd2l0aCBpZCAke2lkfSBub3QgZm91bmRgLCAnTk9UX0ZPVU5EJylcbiAgICB9XG4gICAgXG4gICAgY29uc3QgdXBkYXRlZFF1ZXN0aW9uID0ge1xuICAgICAgLi4ucXVlc3Rpb25zW2luZGV4XSxcbiAgICAgIC4uLnVwZGF0ZXMsXG4gICAgICB1cGRhdGVkQXQ6IERhdGUubm93KClcbiAgICB9XG4gICAgXG4gICAgdGhpcy52YWxpZGF0ZVF1ZXN0aW9uKHVwZGF0ZWRRdWVzdGlvbilcbiAgICBxdWVzdGlvbnNbaW5kZXhdID0gdXBkYXRlZFF1ZXN0aW9uXG4gICAgdGhpcy5zYXZlUXVlc3Rpb25zKHF1ZXN0aW9ucylcbiAgICByZXR1cm4gdXBkYXRlZFF1ZXN0aW9uXG4gIH1cblxuICBkZWxldGVRdWVzdGlvbihpZDogc3RyaW5nKTogYm9vbGVhbiB7XG4gICAgY29uc3QgcXVlc3Rpb25zID0gdGhpcy5nZXRRdWVzdGlvbnMoKVxuICAgIGNvbnN0IGZpbHRlcmVkUXVlc3Rpb25zID0gcXVlc3Rpb25zLmZpbHRlcihxID0+IHEuaWQgIT09IGlkKVxuICAgIFxuICAgIGlmIChmaWx0ZXJlZFF1ZXN0aW9ucy5sZW5ndGggPT09IHF1ZXN0aW9ucy5sZW5ndGgpIHtcbiAgICAgIHRocm93IG5ldyBRdWl6RGF0YUVycm9yKGBRdWVzdGlvbiB3aXRoIGlkICR7aWR9IG5vdCBmb3VuZGAsICdOT1RfRk9VTkQnKVxuICAgIH1cbiAgICBcbiAgICB0aGlzLnNhdmVRdWVzdGlvbnMoZmlsdGVyZWRRdWVzdGlvbnMpXG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIGJ1bGtEZWxldGUoaWRzOiBzdHJpbmdbXSk6IEJ1bGtPcGVyYXRpb25SZXN1bHQge1xuICAgIGlmIChpZHMubGVuZ3RoID4gVkFMSURBVElPTl9SVUxFUy5NQVhfQlVMS19PUEVSQVRJT05TKSB7XG4gICAgICB0aHJvdyBuZXcgUXVpekRhdGFFcnJvcihcbiAgICAgICAgYENhbm5vdCBkZWxldGUgbW9yZSB0aGFuICR7VkFMSURBVElPTl9SVUxFUy5NQVhfQlVMS19PUEVSQVRJT05TfSBxdWVzdGlvbnMgYXQgb25jZWAsXG4gICAgICAgICdCVUxLX0xJTUlUX0VYQ0VFREVEJ1xuICAgICAgKVxuICAgIH1cblxuICAgIGNvbnN0IHF1ZXN0aW9ucyA9IHRoaXMuZ2V0UXVlc3Rpb25zKClcbiAgICBjb25zdCBpbml0aWFsQ291bnQgPSBxdWVzdGlvbnMubGVuZ3RoXG4gICAgY29uc3QgZmlsdGVyZWRRdWVzdGlvbnMgPSBxdWVzdGlvbnMuZmlsdGVyKHEgPT4gIWlkcy5pbmNsdWRlcyhxLmlkKSlcbiAgICBjb25zdCBkZWxldGVkQ291bnQgPSBpbml0aWFsQ291bnQgLSBmaWx0ZXJlZFF1ZXN0aW9ucy5sZW5ndGhcbiAgICBcbiAgICB0aGlzLnNhdmVRdWVzdGlvbnMoZmlsdGVyZWRRdWVzdGlvbnMpXG4gICAgXG4gICAgcmV0dXJuIHtcbiAgICAgIHN1Y2Nlc3M6IHRydWUsXG4gICAgICBwcm9jZXNzZWRDb3VudDogZGVsZXRlZENvdW50LFxuICAgICAgZXJyb3JDb3VudDogaWRzLmxlbmd0aCAtIGRlbGV0ZWRDb3VudCxcbiAgICAgIGVycm9yczogaWRzLmxlbmd0aCA+IGRlbGV0ZWRDb3VudCA/IFsnU29tZSBxdWVzdGlvbnMgd2VyZSBub3QgZm91bmQnXSA6IFtdXG4gICAgfVxuICB9XG5cbiAgLy8gU2VhcmNoIGFuZCBmaWx0ZXIgb3BlcmF0aW9uc1xuICBzZWFyY2hRdWVzdGlvbnMoZmlsdGVyczogU2VhcmNoRmlsdGVycyk6IFF1aXpRdWVzdGlvbltdIHtcbiAgICBjb25zdCBxdWVzdGlvbnMgPSB0aGlzLmdldFF1ZXN0aW9ucygpXG4gICAgXG4gICAgcmV0dXJuIHF1ZXN0aW9ucy5maWx0ZXIocXVlc3Rpb24gPT4ge1xuICAgICAgLy8gVGV4dCBzZWFyY2hcbiAgICAgIGlmIChmaWx0ZXJzLnNlYXJjaFRleHQpIHtcbiAgICAgICAgY29uc3Qgc2VhcmNoTG93ZXIgPSBmaWx0ZXJzLnNlYXJjaFRleHQudG9Mb3dlckNhc2UoKVxuICAgICAgICBpZiAoIXF1ZXN0aW9uLnF1ZXN0aW9uLnRvTG93ZXJDYXNlKCkuaW5jbHVkZXMoc2VhcmNoTG93ZXIpKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gQ2F0ZWdvcnkgZmlsdGVyXG4gICAgICBpZiAoZmlsdGVycy5jYXRlZ29yeSAhPT0gJ2FsbCcgJiYgcXVlc3Rpb24uY2F0ZWdvcnkgIT09IGZpbHRlcnMuY2F0ZWdvcnkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIERpZmZpY3VsdHkgZmlsdGVyXG4gICAgICBpZiAoZmlsdGVycy5kaWZmaWN1bHR5ICE9PSAnYWxsJyAmJiBxdWVzdGlvbi5kaWZmaWN1bHR5ICE9PSBmaWx0ZXJzLmRpZmZpY3VsdHkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIFR5cGUgZmlsdGVyXG4gICAgICBpZiAoZmlsdGVycy50eXBlICE9PSAnYWxsJyAmJiBxdWVzdGlvbi50eXBlICE9PSBmaWx0ZXJzLnR5cGUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG4gICAgICBcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfSlcbiAgfVxuXG4gIC8vIENhdGVnb3JpZXMgbWFuYWdlbWVudFxuICBnZXRDYXRlZ29yaWVzKCk6IFF1aXpDYXRlZ29yeVtdIHtcbiAgICBjb25zdCBxdWVzdGlvbnMgPSB0aGlzLmdldFF1ZXN0aW9ucygpXG4gICAgY29uc3QgY2F0ZWdvcnlDb3VudHMgPSBxdWVzdGlvbnMucmVkdWNlKChhY2MsIHF1ZXN0aW9uKSA9PiB7XG4gICAgICBhY2NbcXVlc3Rpb24uY2F0ZWdvcnldID0gKGFjY1txdWVzdGlvbi5jYXRlZ29yeV0gfHwgMCkgKyAxXG4gICAgICByZXR1cm4gYWNjXG4gICAgfSwge30gYXMgUmVjb3JkPHN0cmluZywgbnVtYmVyPilcbiAgICBcbiAgICByZXR1cm4gREVGQVVMVF9DQVRFR09SSUVTLm1hcChjYXRlZ29yeSA9PiAoe1xuICAgICAgLi4uY2F0ZWdvcnksXG4gICAgICBxdWVzdGlvbkNvdW50OiBjYXRlZ29yeUNvdW50c1tjYXRlZ29yeS5pZF0gfHwgMFxuICAgIH0pKVxuICB9XG5cbiAgLy8gRHJhZnQgbWFuYWdlbWVudFxuICBzYXZlRHJhZnQoZHJhZnQ6IFF1ZXN0aW9uRHJhZnQpOiB2b2lkIHtcbiAgICBjb25zdCBkcmFmdHMgPSB0aGlzLmdldERyYWZ0cygpXG4gICAgY29uc3QgZXhpc3RpbmdJbmRleCA9IGRyYWZ0cy5maW5kSW5kZXgoZCA9PiBkLmlkID09PSBkcmFmdC5pZClcbiAgICBcbiAgICBpZiAoZXhpc3RpbmdJbmRleCA+PSAwKSB7XG4gICAgICBkcmFmdHNbZXhpc3RpbmdJbmRleF0gPSB7IC4uLmRyYWZ0LCBsYXN0U2F2ZWQ6IERhdGUubm93KCkgfVxuICAgIH0gZWxzZSB7XG4gICAgICBkcmFmdHMucHVzaCh7IC4uLmRyYWZ0LCBsYXN0U2F2ZWQ6IERhdGUubm93KCkgfSlcbiAgICB9XG4gICAgXG4gICAgdGhpcy5zYWZlU2V0SXRlbShRVUlaX1NUT1JBR0VfS0VZUy5EUkFGVFMsIEpTT04uc3RyaW5naWZ5KGRyYWZ0cykpXG4gIH1cblxuICBnZXREcmFmdHMoKTogUXVlc3Rpb25EcmFmdFtdIHtcbiAgICBjb25zdCBkYXRhID0gdGhpcy5zYWZlR2V0SXRlbShRVUlaX1NUT1JBR0VfS0VZUy5EUkFGVFMpXG4gICAgaWYgKCFkYXRhKSByZXR1cm4gW11cbiAgICBcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIEpTT04ucGFyc2UoZGF0YSlcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgcGFyc2luZyBkcmFmdHMgZGF0YTonLCBlcnJvcilcbiAgICAgIHJldHVybiBbXVxuICAgIH1cbiAgfVxuXG4gIGRlbGV0ZURyYWZ0KGlkOiBzdHJpbmcpOiB2b2lkIHtcbiAgICBjb25zdCBkcmFmdHMgPSB0aGlzLmdldERyYWZ0cygpLmZpbHRlcihkID0+IGQuaWQgIT09IGlkKVxuICAgIHRoaXMuc2FmZVNldEl0ZW0oUVVJWl9TVE9SQUdFX0tFWVMuRFJBRlRTLCBKU09OLnN0cmluZ2lmeShkcmFmdHMpKVxuICB9XG5cbiAgLy8gU2V0dGluZ3MgbWFuYWdlbWVudFxuICBnZXRTZXR0aW5ncygpOiBRdWl6TWFuYWdlbWVudFNldHRpbmdzIHtcbiAgICBjb25zdCBkYXRhID0gdGhpcy5zYWZlR2V0SXRlbShRVUlaX1NUT1JBR0VfS0VZUy5TRVRUSU5HUylcbiAgICBpZiAoIWRhdGEpIHJldHVybiB0aGlzLmdldERlZmF1bHRTZXR0aW5ncygpXG4gICAgXG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiB7IC4uLnRoaXMuZ2V0RGVmYXVsdFNldHRpbmdzKCksIC4uLkpTT04ucGFyc2UoZGF0YSkgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBwYXJzaW5nIHNldHRpbmdzIGRhdGE6JywgZXJyb3IpXG4gICAgICByZXR1cm4gdGhpcy5nZXREZWZhdWx0U2V0dGluZ3MoKVxuICAgIH1cbiAgfVxuXG4gIHNhdmVTZXR0aW5ncyhzZXR0aW5nczogUGFydGlhbDxRdWl6TWFuYWdlbWVudFNldHRpbmdzPik6IHZvaWQge1xuICAgIGNvbnN0IGN1cnJlbnRTZXR0aW5ncyA9IHRoaXMuZ2V0U2V0dGluZ3MoKVxuICAgIGNvbnN0IHVwZGF0ZWRTZXR0aW5ncyA9IHsgLi4uY3VycmVudFNldHRpbmdzLCAuLi5zZXR0aW5ncyB9XG4gICAgdGhpcy5zYWZlU2V0SXRlbShRVUlaX1NUT1JBR0VfS0VZUy5TRVRUSU5HUywgSlNPTi5zdHJpbmdpZnkodXBkYXRlZFNldHRpbmdzKSlcbiAgfVxuXG4gIHByaXZhdGUgZ2V0RGVmYXVsdFNldHRpbmdzKCk6IFF1aXpNYW5hZ2VtZW50U2V0dGluZ3Mge1xuICAgIHJldHVybiB7XG4gICAgICBwYWdlU2l6ZTogMTAsXG4gICAgICBzb3J0Qnk6ICd1cGRhdGVkQXQnLFxuICAgICAgc29ydE9yZGVyOiAnZGVzYycsXG4gICAgICBmaWx0ZXJzOiB7XG4gICAgICAgIHNlYXJjaFRleHQ6ICcnLFxuICAgICAgICBjYXRlZ29yeTogJ2FsbCcsXG4gICAgICAgIGRpZmZpY3VsdHk6ICdhbGwnLFxuICAgICAgICB0eXBlOiAnYWxsJ1xuICAgICAgfSxcbiAgICAgIHNlbGVjdGVkUXVlc3Rpb25zOiBbXVxuICAgIH1cbiAgfVxuXG4gIC8vIFZhbGlkYXRpb25cbiAgcHJpdmF0ZSB2YWxpZGF0ZVF1ZXN0aW9uKHF1ZXN0aW9uOiBQYXJ0aWFsPFF1aXpRdWVzdGlvbj4pOiB2b2lkIHtcbiAgICBpZiAoIXF1ZXN0aW9uLnF1ZXN0aW9uIHx8IHF1ZXN0aW9uLnF1ZXN0aW9uLmxlbmd0aCA8IFZBTElEQVRJT05fUlVMRVMuUVVFU1RJT05fTUlOX0xFTkdUSCkge1xuICAgICAgdGhyb3cgbmV3IFF1aXpEYXRhRXJyb3IoXG4gICAgICAgIGBRdWVzdGlvbiBtdXN0IGJlIGF0IGxlYXN0ICR7VkFMSURBVElPTl9SVUxFUy5RVUVTVElPTl9NSU5fTEVOR1RIfSBjaGFyYWN0ZXJzIGxvbmdgLFxuICAgICAgICAnSU5WQUxJRF9RVUVTVElPTl9MRU5HVEgnXG4gICAgICApXG4gICAgfVxuICAgIFxuICAgIGlmIChxdWVzdGlvbi5xdWVzdGlvbi5sZW5ndGggPiBWQUxJREFUSU9OX1JVTEVTLlFVRVNUSU9OX01BWF9MRU5HVEgpIHtcbiAgICAgIHRocm93IG5ldyBRdWl6RGF0YUVycm9yKFxuICAgICAgICBgUXVlc3Rpb24gbXVzdCBiZSBubyBtb3JlIHRoYW4gJHtWQUxJREFUSU9OX1JVTEVTLlFVRVNUSU9OX01BWF9MRU5HVEh9IGNoYXJhY3RlcnMgbG9uZ2AsXG4gICAgICAgICdJTlZBTElEX1FVRVNUSU9OX0xFTkdUSCdcbiAgICAgIClcbiAgICB9XG4gICAgXG4gICAgaWYgKCFxdWVzdGlvbi5vcHRpb25zIHx8IHF1ZXN0aW9uLm9wdGlvbnMubGVuZ3RoICE9PSBWQUxJREFUSU9OX1JVTEVTLk1JTl9PUFRJT05TKSB7XG4gICAgICB0aHJvdyBuZXcgUXVpekRhdGFFcnJvcihcbiAgICAgICAgYFF1ZXN0aW9uIG11c3QgaGF2ZSBleGFjdGx5ICR7VkFMSURBVElPTl9SVUxFUy5NSU5fT1BUSU9OU30gb3B0aW9uc2AsXG4gICAgICAgICdJTlZBTElEX09QVElPTlNfQ09VTlQnXG4gICAgICApXG4gICAgfVxuICAgIFxuICAgIC8vIFZhbGlkYXRlIGVhY2ggb3B0aW9uXG4gICAgcXVlc3Rpb24ub3B0aW9ucy5mb3JFYWNoKChvcHRpb24sIGluZGV4KSA9PiB7XG4gICAgICBpZiAoIW9wdGlvbiB8fCBvcHRpb24ubGVuZ3RoIDwgVkFMSURBVElPTl9SVUxFUy5PUFRJT05fTUlOX0xFTkdUSCkge1xuICAgICAgICB0aHJvdyBuZXcgUXVpekRhdGFFcnJvcihcbiAgICAgICAgICBgT3B0aW9uICR7aW5kZXggKyAxfSBtdXN0IGJlIGF0IGxlYXN0ICR7VkFMSURBVElPTl9SVUxFUy5PUFRJT05fTUlOX0xFTkdUSH0gY2hhcmFjdGVyIGxvbmdgLFxuICAgICAgICAgICdJTlZBTElEX09QVElPTl9MRU5HVEgnXG4gICAgICAgIClcbiAgICAgIH1cbiAgICAgIFxuICAgICAgaWYgKG9wdGlvbi5sZW5ndGggPiBWQUxJREFUSU9OX1JVTEVTLk9QVElPTl9NQVhfTEVOR1RIKSB7XG4gICAgICAgIHRocm93IG5ldyBRdWl6RGF0YUVycm9yKFxuICAgICAgICAgIGBPcHRpb24gJHtpbmRleCArIDF9IG11c3QgYmUgbm8gbW9yZSB0aGFuICR7VkFMSURBVElPTl9SVUxFUy5PUFRJT05fTUFYX0xFTkdUSH0gY2hhcmFjdGVycyBsb25nYCxcbiAgICAgICAgICAnSU5WQUxJRF9PUFRJT05fTEVOR1RIJ1xuICAgICAgICApXG4gICAgICB9XG4gICAgfSlcbiAgICBcbiAgICAvLyBDaGVjayBmb3IgZHVwbGljYXRlIG9wdGlvbnNcbiAgICBjb25zdCB1bmlxdWVPcHRpb25zID0gbmV3IFNldChxdWVzdGlvbi5vcHRpb25zLm1hcChvcHQgPT4gb3B0LnRvTG93ZXJDYXNlKCkudHJpbSgpKSlcbiAgICBpZiAodW5pcXVlT3B0aW9ucy5zaXplICE9PSBxdWVzdGlvbi5vcHRpb25zLmxlbmd0aCkge1xuICAgICAgdGhyb3cgbmV3IFF1aXpEYXRhRXJyb3IoJ0FsbCBvcHRpb25zIG11c3QgYmUgdW5pcXVlJywgJ0RVUExJQ0FURV9PUFRJT05TJylcbiAgICB9XG4gICAgXG4gICAgLy8gVmFsaWRhdGUgY29ycmVjdCBhbnN3ZXJcbiAgICBpZiAodHlwZW9mIHF1ZXN0aW9uLmNvcnJlY3RBbnN3ZXIgIT09ICdudW1iZXInIHx8IFxuICAgICAgICBxdWVzdGlvbi5jb3JyZWN0QW5zd2VyIDwgMCB8fCBcbiAgICAgICAgcXVlc3Rpb24uY29ycmVjdEFuc3dlciA+PSBxdWVzdGlvbi5vcHRpb25zLmxlbmd0aCkge1xuICAgICAgdGhyb3cgbmV3IFF1aXpEYXRhRXJyb3IoJ0ludmFsaWQgY29ycmVjdCBhbnN3ZXIgc2VsZWN0aW9uJywgJ0lOVkFMSURfQ09SUkVDVF9BTlNXRVInKVxuICAgIH1cbiAgICBcbiAgICAvLyBWYWxpZGF0ZSBjYXRlZ29yeVxuICAgIGNvbnN0IHZhbGlkQ2F0ZWdvcmllcyA9IERFRkFVTFRfQ0FURUdPUklFUy5tYXAoYyA9PiBjLmlkKVxuICAgIGlmICghcXVlc3Rpb24uY2F0ZWdvcnkgfHwgIXZhbGlkQ2F0ZWdvcmllcy5pbmNsdWRlcyhxdWVzdGlvbi5jYXRlZ29yeSkpIHtcbiAgICAgIHRocm93IG5ldyBRdWl6RGF0YUVycm9yKCdJbnZhbGlkIGNhdGVnb3J5IHNlbGVjdGlvbicsICdJTlZBTElEX0NBVEVHT1JZJylcbiAgICB9XG4gIH1cblxuICAvLyBVdGlsaXR5IG1ldGhvZHNcbiAgcHJpdmF0ZSBzYXZlUXVlc3Rpb25zKHF1ZXN0aW9uczogUXVpelF1ZXN0aW9uW10pOiB2b2lkIHtcbiAgICB0aGlzLnNhZmVTZXRJdGVtKFFVSVpfU1RPUkFHRV9LRVlTLlFVRVNUSU9OUywgSlNPTi5zdHJpbmdpZnkocXVlc3Rpb25zKSlcbiAgfVxuXG4gIHByaXZhdGUgZ2VuZXJhdGVJZCgpOiBzdHJpbmcge1xuICAgIHJldHVybiBgcV8ke0RhdGUubm93KCl9XyR7TWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc3Vic3RyKDIsIDkpfWBcbiAgfVxuXG4gIC8vIENTViBFeHBvcnQvSW1wb3J0IGZ1bmN0aW9uYWxpdHlcbiAgZXhwb3J0VG9DU1YocXVlc3Rpb25zPzogUXVpelF1ZXN0aW9uW10pOiBzdHJpbmcge1xuICAgIGNvbnN0IHF1ZXN0aW9uc1RvRXhwb3J0ID0gcXVlc3Rpb25zIHx8IHRoaXMuZ2V0UXVlc3Rpb25zKClcblxuICAgIGNvbnN0IGhlYWRlcnMgPSBbXG4gICAgICAnSUQnLCAnUXVlc3Rpb24nLCAnT3B0aW9uIDEnLCAnT3B0aW9uIDInLCAnT3B0aW9uIDMnLCAnT3B0aW9uIDQnLFxuICAgICAgJ0NvcnJlY3QgQW5zd2VyJywgJ0NhdGVnb3J5JywgJ0RpZmZpY3VsdHknLCAnVHlwZScsICdGdW4gRmFjdCcsICdUYWdzJyxcbiAgICAgICdDcmVhdGVkIEF0JywgJ1VwZGF0ZWQgQXQnXG4gICAgXVxuXG4gICAgY29uc3QgY3N2Um93cyA9IFtcbiAgICAgIGhlYWRlcnMuam9pbignLCcpLFxuICAgICAgLi4ucXVlc3Rpb25zVG9FeHBvcnQubWFwKHEgPT4gW1xuICAgICAgICBxLmlkLFxuICAgICAgICBgXCIke3EucXVlc3Rpb24ucmVwbGFjZSgvXCIvZywgJ1wiXCInKX1cImAsXG4gICAgICAgIGBcIiR7cS5vcHRpb25zWzBdLnJlcGxhY2UoL1wiL2csICdcIlwiJyl9XCJgLFxuICAgICAgICBgXCIke3Eub3B0aW9uc1sxXS5yZXBsYWNlKC9cIi9nLCAnXCJcIicpfVwiYCxcbiAgICAgICAgYFwiJHtxLm9wdGlvbnNbMl0ucmVwbGFjZSgvXCIvZywgJ1wiXCInKX1cImAsXG4gICAgICAgIGBcIiR7cS5vcHRpb25zWzNdLnJlcGxhY2UoL1wiL2csICdcIlwiJyl9XCJgLFxuICAgICAgICBxLmNvcnJlY3RBbnN3ZXIgKyAxLCAvLyAxLWJhc2VkIGZvciBodW1hbiByZWFkYWJpbGl0eVxuICAgICAgICBxLmNhdGVnb3J5LFxuICAgICAgICBxLmRpZmZpY3VsdHksXG4gICAgICAgIHEudHlwZSxcbiAgICAgICAgYFwiJHsocS5mdW5GYWN0IHx8ICcnKS5yZXBsYWNlKC9cIi9nLCAnXCJcIicpfVwiYCxcbiAgICAgICAgYFwiJHsocS50YWdzIHx8IFtdKS5qb2luKCc7Jyl9XCJgLFxuICAgICAgICBuZXcgRGF0ZShxLmNyZWF0ZWRBdCkudG9JU09TdHJpbmcoKSxcbiAgICAgICAgbmV3IERhdGUocS51cGRhdGVkQXQpLnRvSVNPU3RyaW5nKClcbiAgICAgIF0uam9pbignLCcpKVxuICAgIF1cblxuICAgIC8vIEFkZCBVVEYtOCBCT00gZm9yIEV4Y2VsIGNvbXBhdGliaWxpdHlcbiAgICByZXR1cm4gJ1xcdUZFRkYnICsgY3N2Um93cy5qb2luKCdcXG4nKVxuICB9XG5cbiAgYXN5bmMgaW1wb3J0RnJvbUNTVihjc3ZDb250ZW50OiBzdHJpbmcpOiBQcm9taXNlPEJ1bGtPcGVyYXRpb25SZXN1bHQ+IHtcbiAgICBjb25zdCBsaW5lcyA9IGNzdkNvbnRlbnQuc3BsaXQoJ1xcbicpLmZpbHRlcihsaW5lID0+IGxpbmUudHJpbSgpKVxuICAgIGlmIChsaW5lcy5sZW5ndGggPCAyKSB7XG4gICAgICB0aHJvdyBuZXcgUXVpekRhdGFFcnJvcignQ1NWIGZpbGUgbXVzdCBjb250YWluIGF0IGxlYXN0IGEgaGVhZGVyIGFuZCBvbmUgZGF0YSByb3cnLCAnSU5WQUxJRF9DU1ZfRk9STUFUJylcbiAgICB9XG5cbiAgICBjb25zdCBoZWFkZXJzID0gbGluZXNbMF0uc3BsaXQoJywnKS5tYXAoaCA9PiBoLnRyaW0oKS5yZXBsYWNlKC9cIi9nLCAnJykpXG4gICAgY29uc3QgZGF0YUxpbmVzID0gbGluZXMuc2xpY2UoMSlcblxuICAgIGNvbnN0IHJlc3VsdHM6IEJ1bGtPcGVyYXRpb25SZXN1bHQgPSB7XG4gICAgICBzdWNjZXNzOiB0cnVlLFxuICAgICAgcHJvY2Vzc2VkQ291bnQ6IDAsXG4gICAgICBlcnJvckNvdW50OiAwLFxuICAgICAgZXJyb3JzOiBbXVxuICAgIH1cblxuICAgIGNvbnN0IHZhbGlkUXVlc3Rpb25zOiBRdWl6UXVlc3Rpb25bXSA9IFtdXG4gICAgY29uc3QgZXhpc3RpbmdRdWVzdGlvbnMgPSB0aGlzLmdldFF1ZXN0aW9ucygpXG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRhdGFMaW5lcy5sZW5ndGg7IGkrKykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgdmFsdWVzID0gdGhpcy5wYXJzZUNTVkxpbmUoZGF0YUxpbmVzW2ldKVxuICAgICAgICBpZiAodmFsdWVzLmxlbmd0aCA8IDgpIHtcbiAgICAgICAgICByZXN1bHRzLmVycm9ycy5wdXNoKGBMaW5lICR7aSArIDJ9OiBJbnN1ZmZpY2llbnQgZGF0YSBjb2x1bW5zYClcbiAgICAgICAgICByZXN1bHRzLmVycm9yQ291bnQrK1xuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBxdWVzdGlvbjogUXVpelF1ZXN0aW9uID0ge1xuICAgICAgICAgIGlkOiB2YWx1ZXNbMF0gfHwgdGhpcy5nZW5lcmF0ZUlkKCksXG4gICAgICAgICAgcXVlc3Rpb246IHZhbHVlc1sxXSxcbiAgICAgICAgICBvcHRpb25zOiBbdmFsdWVzWzJdLCB2YWx1ZXNbM10sIHZhbHVlc1s0XSwgdmFsdWVzWzVdXSxcbiAgICAgICAgICBjb3JyZWN0QW5zd2VyOiBwYXJzZUludCh2YWx1ZXNbNl0pIC0gMSwgLy8gQ29udmVydCBiYWNrIHRvIDAtYmFzZWRcbiAgICAgICAgICBjYXRlZ29yeTogdmFsdWVzWzddLFxuICAgICAgICAgIGRpZmZpY3VsdHk6IHZhbHVlc1s4XSBhcyAnYmVnaW5uZXInIHwgJ2ludGVybWVkaWF0ZScgfCAnYWR2YW5jZWQnLFxuICAgICAgICAgIHR5cGU6ICh2YWx1ZXNbOV0gfHwgJ3JlZ3VsYXInKSBhcyAncmVndWxhcicgfCAnYm9udXMnLFxuICAgICAgICAgIGZ1bkZhY3Q6IHZhbHVlc1sxMF0gfHwgdW5kZWZpbmVkLFxuICAgICAgICAgIHRhZ3M6IHZhbHVlc1sxMV0gPyB2YWx1ZXNbMTFdLnNwbGl0KCc7JykuZmlsdGVyKHQgPT4gdC50cmltKCkpIDogdW5kZWZpbmVkLFxuICAgICAgICAgIGNyZWF0ZWRBdDogdmFsdWVzWzEyXSA/IG5ldyBEYXRlKHZhbHVlc1sxMl0pLmdldFRpbWUoKSA6IERhdGUubm93KCksXG4gICAgICAgICAgdXBkYXRlZEF0OiB2YWx1ZXNbMTNdID8gbmV3IERhdGUodmFsdWVzWzEzXSkuZ2V0VGltZSgpIDogRGF0ZS5ub3coKVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gVmFsaWRhdGUgdGhlIHF1ZXN0aW9uXG4gICAgICAgIHRoaXMudmFsaWRhdGVRdWVzdGlvbihxdWVzdGlvbilcblxuICAgICAgICAvLyBDaGVjayBmb3IgZHVwbGljYXRlc1xuICAgICAgICBjb25zdCBleGlzdGluZ0luZGV4ID0gZXhpc3RpbmdRdWVzdGlvbnMuZmluZEluZGV4KHEgPT4gcS5pZCA9PT0gcXVlc3Rpb24uaWQpXG4gICAgICAgIGlmIChleGlzdGluZ0luZGV4ID49IDApIHtcbiAgICAgICAgICAvLyBVcGRhdGUgZXhpc3RpbmcgcXVlc3Rpb25cbiAgICAgICAgICBleGlzdGluZ1F1ZXN0aW9uc1tleGlzdGluZ0luZGV4XSA9IHF1ZXN0aW9uXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFsaWRRdWVzdGlvbnMucHVzaChxdWVzdGlvbilcbiAgICAgICAgfVxuXG4gICAgICAgIHJlc3VsdHMucHJvY2Vzc2VkQ291bnQrK1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgcmVzdWx0cy5lcnJvcnMucHVzaChgTGluZSAke2kgKyAyfTogJHtlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6ICdVbmtub3duIGVycm9yJ31gKVxuICAgICAgICByZXN1bHRzLmVycm9yQ291bnQrK1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFNhdmUgYWxsIHZhbGlkIHF1ZXN0aW9uc1xuICAgIGlmICh2YWxpZFF1ZXN0aW9ucy5sZW5ndGggPiAwKSB7XG4gICAgICBjb25zdCBhbGxRdWVzdGlvbnMgPSBbLi4uZXhpc3RpbmdRdWVzdGlvbnMsIC4uLnZhbGlkUXVlc3Rpb25zXVxuICAgICAgdGhpcy5zYXZlUXVlc3Rpb25zKGFsbFF1ZXN0aW9ucylcbiAgICB9XG5cbiAgICByZXN1bHRzLnN1Y2Nlc3MgPSByZXN1bHRzLmVycm9yQ291bnQgPT09IDBcbiAgICByZXR1cm4gcmVzdWx0c1xuICB9XG5cbiAgcHJpdmF0ZSBwYXJzZUNTVkxpbmUobGluZTogc3RyaW5nKTogc3RyaW5nW10ge1xuICAgIGNvbnN0IHJlc3VsdDogc3RyaW5nW10gPSBbXVxuICAgIGxldCBjdXJyZW50ID0gJydcbiAgICBsZXQgaW5RdW90ZXMgPSBmYWxzZVxuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaW5lLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBjaGFyID0gbGluZVtpXVxuXG4gICAgICBpZiAoY2hhciA9PT0gJ1wiJykge1xuICAgICAgICBpZiAoaW5RdW90ZXMgJiYgbGluZVtpICsgMV0gPT09ICdcIicpIHtcbiAgICAgICAgICBjdXJyZW50ICs9ICdcIidcbiAgICAgICAgICBpKysgLy8gU2tpcCBuZXh0IHF1b3RlXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaW5RdW90ZXMgPSAhaW5RdW90ZXNcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChjaGFyID09PSAnLCcgJiYgIWluUXVvdGVzKSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKGN1cnJlbnQudHJpbSgpKVxuICAgICAgICBjdXJyZW50ID0gJydcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGN1cnJlbnQgKz0gY2hhclxuICAgICAgfVxuICAgIH1cblxuICAgIHJlc3VsdC5wdXNoKGN1cnJlbnQudHJpbSgpKVxuICAgIHJldHVybiByZXN1bHRcbiAgfVxuXG4gIHByaXZhdGUgaW5pdGlhbGl6ZVdpdGhTYW1wbGVEYXRhKCk6IFF1aXpRdWVzdGlvbltdIHtcbiAgICAvLyBDaGVjayBpZiB3ZSBzaG91bGQgaW1wb3J0IGV4aXN0aW5nIHF1ZXN0aW9uc1xuICAgIGlmICh0aGlzLnNob3VsZEltcG9ydEV4aXN0aW5nUXVlc3Rpb25zKCkpIHtcbiAgICAgIHJldHVybiB0aGlzLmltcG9ydEFsbEV4aXN0aW5nUXVlc3Rpb25zKClcbiAgICB9XG5cbiAgICAvLyBJbml0aWFsaXplIHdpdGggYSBmZXcgc2FtcGxlIHF1ZXN0aW9ucyBmb3IgZGVtb25zdHJhdGlvblxuICAgIGNvbnN0IHNhbXBsZVF1ZXN0aW9uczogUXVpelF1ZXN0aW9uW10gPSBbXG4gICAgICB7XG4gICAgICAgIGlkOiAnc2FtcGxlXzEnLFxuICAgICAgICBxdWVzdGlvbjogJ1doaWNoIHNvY2lhbCBtZWRpYSBwbGF0Zm9ybSBpcyBrbm93biBmb3IgaXRzIHNob3J0LWZvcm0gdmlkZW8gY29udGVudCBhbmQgdmlyYWwgZGFuY2VzPycsXG4gICAgICAgIG9wdGlvbnM6IFsnSW5zdGFncmFtJywgJ1Rpa1RvaycsICdUd2l0dGVyJywgJ1NuYXBjaGF0J10sXG4gICAgICAgIGNvcnJlY3RBbnN3ZXI6IDEsXG4gICAgICAgIGNhdGVnb3J5OiAnc29jaWFsLW1lZGlhJyxcbiAgICAgICAgZGlmZmljdWx0eTogJ2JlZ2lubmVyJyxcbiAgICAgICAgdHlwZTogJ3JlZ3VsYXInLFxuICAgICAgICBzZWN0aW9uOiAnaG9tZXBhZ2UnLFxuICAgICAgICBmdW5GYWN0OiAnVGlrVG9rIHdhcyBvcmlnaW5hbGx5IGNhbGxlZCBNdXNpY2FsLmx5IGJlZm9yZSBiZWluZyBhY3F1aXJlZCBieSBCeXRlRGFuY2UuJyxcbiAgICAgICAgdGFnczogWydzb2NpYWwtbWVkaWEnLCAndmlkZW8nLCAndmlyYWwnXSxcbiAgICAgICAgY3JlYXRlZEF0OiBEYXRlLm5vdygpIC0gODY0MDAwMDAsIC8vIDEgZGF5IGFnb1xuICAgICAgICB1cGRhdGVkQXQ6IERhdGUubm93KCkgLSA4NjQwMDAwMFxuICAgICAgfVxuICAgICAgLy8gQWRkIG1vcmUgc2FtcGxlIHF1ZXN0aW9ucyBhcyBuZWVkZWRcbiAgICBdXG5cbiAgICB0aGlzLnNhdmVRdWVzdGlvbnMoc2FtcGxlUXVlc3Rpb25zKVxuICAgIHJldHVybiBzYW1wbGVRdWVzdGlvbnNcbiAgfVxuXG4gIC8vIENoZWNrIGlmIHdlIHNob3VsZCBpbXBvcnQgZXhpc3RpbmcgcXVlc3Rpb25zXG4gIHByaXZhdGUgc2hvdWxkSW1wb3J0RXhpc3RpbmdRdWVzdGlvbnMoKTogYm9vbGVhbiB7XG4gICAgLy8gT25seSBpbXBvcnQgaWYgbG9jYWxTdG9yYWdlIGlzIGVtcHR5IGFuZCB3ZSdyZSBvbiBjbGllbnQgc2lkZVxuICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykgcmV0dXJuIGZhbHNlXG5cbiAgICBjb25zdCBoYXNJbXBvcnRlZCA9IHRoaXMuc2FmZUdldEl0ZW0oJ3F1aXpfcXVlc3Rpb25zX2ltcG9ydGVkJylcbiAgICByZXR1cm4gIWhhc0ltcG9ydGVkXG4gIH1cblxuICAvLyBJbXBvcnQgYWxsIGV4aXN0aW5nIHF1ZXN0aW9ucyBmcm9tIGRpZmZlcmVudCBzb3VyY2VzXG4gIHByaXZhdGUgaW1wb3J0QWxsRXhpc3RpbmdRdWVzdGlvbnMoKTogUXVpelF1ZXN0aW9uW10ge1xuICAgIGNvbnN0IGFsbFF1ZXN0aW9uczogUXVpelF1ZXN0aW9uW10gPSBbXVxuXG4gICAgdHJ5IHtcbiAgICAgIC8vIEltcG9ydCBvbmJvYXJkaW5nIHF1ZXN0aW9uc1xuICAgICAgY29uc3Qgb25ib2FyZGluZ1F1ZXN0aW9ucyA9IHRoaXMuaW1wb3J0T25ib2FyZGluZ1F1ZXN0aW9ucygpXG4gICAgICBhbGxRdWVzdGlvbnMucHVzaCguLi5vbmJvYXJkaW5nUXVlc3Rpb25zKVxuXG4gICAgICAvLyBJbXBvcnQgaG9tZXBhZ2UgZmFsbGJhY2sgcXVlc3Rpb25zXG4gICAgICBjb25zdCBob21lcGFnZVF1ZXN0aW9ucyA9IHRoaXMuaW1wb3J0SG9tZXBhZ2VRdWVzdGlvbnMoKVxuICAgICAgYWxsUXVlc3Rpb25zLnB1c2goLi4uaG9tZXBhZ2VRdWVzdGlvbnMpXG5cbiAgICAgIC8vIEltcG9ydCBjYXRlZ29yeSBxdWVzdGlvbnMgZnJvbSBxdWl6IGRhdGFiYXNlXG4gICAgICBjb25zdCBjYXRlZ29yeVF1ZXN0aW9ucyA9IHRoaXMuaW1wb3J0Q2F0ZWdvcnlRdWVzdGlvbnMoKVxuICAgICAgYWxsUXVlc3Rpb25zLnB1c2goLi4uY2F0ZWdvcnlRdWVzdGlvbnMpXG5cbiAgICAgIGNvbnNvbGUubG9nKGDwn5OKIEltcG9ydGVkICR7YWxsUXVlc3Rpb25zLmxlbmd0aH0gcXVlc3Rpb25zIGZyb20gZXhpc3Rpbmcgc291cmNlc2ApXG5cbiAgICAgIC8vIFNhdmUgYWxsIGltcG9ydGVkIHF1ZXN0aW9uc1xuICAgICAgdGhpcy5zYXZlUXVlc3Rpb25zKGFsbFF1ZXN0aW9ucylcblxuICAgICAgLy8gTWFyayBhcyBpbXBvcnRlZFxuICAgICAgdGhpcy5zYWZlU2V0SXRlbSgncXVpel9xdWVzdGlvbnNfaW1wb3J0ZWQnLCAndHJ1ZScpXG5cbiAgICAgIHJldHVybiBhbGxRdWVzdGlvbnNcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgaW1wb3J0aW5nIGV4aXN0aW5nIHF1ZXN0aW9uczonLCBlcnJvcilcbiAgICAgIHJldHVybiBbXVxuICAgIH1cbiAgfVxuXG4gIC8vIEJhY2t1cCBhbmQgcmVzdG9yZSBmdW5jdGlvbmFsaXR5XG4gIGNyZWF0ZUJhY2t1cCgpOiBzdHJpbmcge1xuICAgIGNvbnN0IGJhY2t1cCA9IHtcbiAgICAgIHF1ZXN0aW9uczogdGhpcy5nZXRRdWVzdGlvbnMoKSxcbiAgICAgIHNldHRpbmdzOiB0aGlzLmdldFNldHRpbmdzKCksXG4gICAgICBkcmFmdHM6IHRoaXMuZ2V0RHJhZnRzKCksXG4gICAgICB0aW1lc3RhbXA6IERhdGUubm93KCksXG4gICAgICB2ZXJzaW9uOiAnMS4wJ1xuICAgIH1cblxuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShiYWNrdXAsIG51bGwsIDIpXG4gIH1cblxuICByZXN0b3JlRnJvbUJhY2t1cChiYWNrdXBEYXRhOiBzdHJpbmcpOiBCdWxrT3BlcmF0aW9uUmVzdWx0IHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgYmFja3VwID0gSlNPTi5wYXJzZShiYWNrdXBEYXRhKVxuXG4gICAgICBpZiAoIWJhY2t1cC5xdWVzdGlvbnMgfHwgIUFycmF5LmlzQXJyYXkoYmFja3VwLnF1ZXN0aW9ucykpIHtcbiAgICAgICAgdGhyb3cgbmV3IFF1aXpEYXRhRXJyb3IoJ0ludmFsaWQgYmFja3VwIGZvcm1hdDogbWlzc2luZyBxdWVzdGlvbnMgYXJyYXknLCAnSU5WQUxJRF9CQUNLVVAnKVxuICAgICAgfVxuXG4gICAgICAvLyBWYWxpZGF0ZSBhbGwgcXVlc3Rpb25zIGluIGJhY2t1cFxuICAgICAgYmFja3VwLnF1ZXN0aW9ucy5mb3JFYWNoKChxOiBhbnksIGluZGV4OiBudW1iZXIpID0+IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB0aGlzLnZhbGlkYXRlUXVlc3Rpb24ocSlcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgUXVpekRhdGFFcnJvcihcbiAgICAgICAgICAgIGBJbnZhbGlkIHF1ZXN0aW9uIGF0IGluZGV4ICR7aW5kZXh9OiAke2Vycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogJ1Vua25vd24gZXJyb3InfWAsXG4gICAgICAgICAgICAnSU5WQUxJRF9CQUNLVVBfUVVFU1RJT04nXG4gICAgICAgICAgKVxuICAgICAgICB9XG4gICAgICB9KVxuXG4gICAgICAvLyBDcmVhdGUgY3VycmVudCBiYWNrdXAgYmVmb3JlIHJlc3RvcmVcbiAgICAgIGNvbnN0IGN1cnJlbnRCYWNrdXAgPSB0aGlzLmNyZWF0ZUJhY2t1cCgpXG4gICAgICB0aGlzLnNhZmVTZXRJdGVtKFFVSVpfU1RPUkFHRV9LRVlTLkJBQ0tVUCwgY3VycmVudEJhY2t1cClcblxuICAgICAgLy8gUmVzdG9yZSBkYXRhXG4gICAgICB0aGlzLnNhdmVRdWVzdGlvbnMoYmFja3VwLnF1ZXN0aW9ucylcbiAgICAgIGlmIChiYWNrdXAuc2V0dGluZ3MpIHtcbiAgICAgICAgdGhpcy5zYWZlU2V0SXRlbShRVUlaX1NUT1JBR0VfS0VZUy5TRVRUSU5HUywgSlNPTi5zdHJpbmdpZnkoYmFja3VwLnNldHRpbmdzKSlcbiAgICAgIH1cbiAgICAgIGlmIChiYWNrdXAuZHJhZnRzKSB7XG4gICAgICAgIHRoaXMuc2FmZVNldEl0ZW0oUVVJWl9TVE9SQUdFX0tFWVMuRFJBRlRTLCBKU09OLnN0cmluZ2lmeShiYWNrdXAuZHJhZnRzKSlcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc3VjY2VzczogdHJ1ZSxcbiAgICAgICAgcHJvY2Vzc2VkQ291bnQ6IGJhY2t1cC5xdWVzdGlvbnMubGVuZ3RoLFxuICAgICAgICBlcnJvckNvdW50OiAwLFxuICAgICAgICBlcnJvcnM6IFtdXG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHRocm93IG5ldyBRdWl6RGF0YUVycm9yKFxuICAgICAgICBgRmFpbGVkIHRvIHJlc3RvcmUgYmFja3VwOiAke2Vycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogJ1Vua25vd24gZXJyb3InfWAsXG4gICAgICAgICdSRVNUT1JFX0ZBSUxFRCdcbiAgICAgIClcbiAgICB9XG4gIH1cblxuICAvLyBBdXRvLXNhdmUgZnVuY3Rpb25hbGl0eSBmb3IgZHJhZnRzXG4gIHN0YXJ0QXV0b1NhdmUoZHJhZnRJZDogc3RyaW5nLCBnZXREcmFmdERhdGE6ICgpID0+IFBhcnRpYWw8UXVlc3Rpb25EcmFmdD4pOiB2b2lkIHtcbiAgICB0aGlzLnN0b3BBdXRvU2F2ZSgpXG5cbiAgICB0aGlzLmF1dG9TYXZlVGltZXIgPSBzZXRJbnRlcnZhbCgoKSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBkcmFmdERhdGEgPSBnZXREcmFmdERhdGEoKVxuICAgICAgICBpZiAoZHJhZnREYXRhLnF1ZXN0aW9uICYmIGRyYWZ0RGF0YS5xdWVzdGlvbi5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgY29uc3QgZHJhZnQ6IFF1ZXN0aW9uRHJhZnQgPSB7XG4gICAgICAgICAgICBpZDogZHJhZnRJZCxcbiAgICAgICAgICAgIHF1ZXN0aW9uOiBkcmFmdERhdGEucXVlc3Rpb24gfHwgJycsXG4gICAgICAgICAgICBvcHRpb25zOiBkcmFmdERhdGEub3B0aW9ucyB8fCBbJycsICcnLCAnJywgJyddLFxuICAgICAgICAgICAgY29ycmVjdEFuc3dlcjogZHJhZnREYXRhLmNvcnJlY3RBbnN3ZXIgfHwgMCxcbiAgICAgICAgICAgIGNhdGVnb3J5OiBkcmFmdERhdGEuY2F0ZWdvcnkgfHwgJ2ZhY3RzJyxcbiAgICAgICAgICAgIGRpZmZpY3VsdHk6IGRyYWZ0RGF0YS5kaWZmaWN1bHR5IHx8ICdiZWdpbm5lcicsXG4gICAgICAgICAgICB0eXBlOiBkcmFmdERhdGEudHlwZSB8fCAncmVndWxhcicsXG4gICAgICAgICAgICBmdW5GYWN0OiBkcmFmdERhdGEuZnVuRmFjdCxcbiAgICAgICAgICAgIHRhZ3M6IGRyYWZ0RGF0YS50YWdzLFxuICAgICAgICAgICAgbGFzdFNhdmVkOiBEYXRlLm5vdygpXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGhpcy5zYXZlRHJhZnQoZHJhZnQpXG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0F1dG8tc2F2ZSBmYWlsZWQ6JywgZXJyb3IpXG4gICAgICB9XG4gICAgfSwgVkFMSURBVElPTl9SVUxFUy5BVVRPX1NBVkVfSU5URVJWQUwpXG4gIH1cblxuICBzdG9wQXV0b1NhdmUoKTogdm9pZCB7XG4gICAgaWYgKHRoaXMuYXV0b1NhdmVUaW1lcikge1xuICAgICAgY2xlYXJJbnRlcnZhbCh0aGlzLmF1dG9TYXZlVGltZXIpXG4gICAgICB0aGlzLmF1dG9TYXZlVGltZXIgPSBudWxsXG4gICAgfVxuICB9XG5cbiAgLy8gQ1NWIEV4cG9ydCBmdW5jdGlvbmFsaXR5XG4gIGV4cG9ydFRvQ1NWKHF1ZXN0aW9uc1RvRXhwb3J0PzogUXVpelF1ZXN0aW9uW10pOiBzdHJpbmcge1xuICAgIGNvbnN0IHF1ZXN0aW9ucyA9IHF1ZXN0aW9uc1RvRXhwb3J0IHx8IHRoaXMuZ2V0UXVlc3Rpb25zKClcbiAgICBjb25zdCBoZWFkZXJzID0gW1xuICAgICAgJ0lEJyxcbiAgICAgICdRdWVzdGlvbicsXG4gICAgICAnT3B0aW9uIDEnLFxuICAgICAgJ09wdGlvbiAyJyxcbiAgICAgICdPcHRpb24gMycsXG4gICAgICAnT3B0aW9uIDQnLFxuICAgICAgJ0NvcnJlY3QgQW5zd2VyICgxLTQpJyxcbiAgICAgICdDYXRlZ29yeScsXG4gICAgICAnRGlmZmljdWx0eScsXG4gICAgICAnVHlwZScsXG4gICAgICAnRnVuIEZhY3QnLFxuICAgICAgJ1RhZ3MnLFxuICAgICAgJ0NyZWF0ZWQgQXQnLFxuICAgICAgJ1VwZGF0ZWQgQXQnXG4gICAgXVxuXG4gICAgY29uc3QgY3N2Um93cyA9IFtoZWFkZXJzLmpvaW4oJywnKV1cblxuICAgIHF1ZXN0aW9ucy5mb3JFYWNoKHF1ZXN0aW9uID0+IHtcbiAgICAgIGNvbnN0IHJvdyA9IFtcbiAgICAgICAgcXVlc3Rpb24uaWQsXG4gICAgICAgIGBcIiR7cXVlc3Rpb24ucXVlc3Rpb24ucmVwbGFjZSgvXCIvZywgJ1wiXCInKX1cImAsIC8vIEVzY2FwZSBxdW90ZXNcbiAgICAgICAgYFwiJHtxdWVzdGlvbi5vcHRpb25zWzBdPy5yZXBsYWNlKC9cIi9nLCAnXCJcIicpIHx8ICcnfVwiYCxcbiAgICAgICAgYFwiJHtxdWVzdGlvbi5vcHRpb25zWzFdPy5yZXBsYWNlKC9cIi9nLCAnXCJcIicpIHx8ICcnfVwiYCxcbiAgICAgICAgYFwiJHtxdWVzdGlvbi5vcHRpb25zWzJdPy5yZXBsYWNlKC9cIi9nLCAnXCJcIicpIHx8ICcnfVwiYCxcbiAgICAgICAgYFwiJHtxdWVzdGlvbi5vcHRpb25zWzNdPy5yZXBsYWNlKC9cIi9nLCAnXCJcIicpIHx8ICcnfVwiYCxcbiAgICAgICAgcXVlc3Rpb24uY29ycmVjdEFuc3dlciArIDEsIC8vIENvbnZlcnQgMC1iYXNlZCB0byAxLWJhc2VkXG4gICAgICAgIHF1ZXN0aW9uLmNhdGVnb3J5LFxuICAgICAgICBxdWVzdGlvbi5kaWZmaWN1bHR5LFxuICAgICAgICBxdWVzdGlvbi50eXBlLFxuICAgICAgICBgXCIkeyhxdWVzdGlvbi5mdW5GYWN0IHx8ICcnKS5yZXBsYWNlKC9cIi9nLCAnXCJcIicpfVwiYCxcbiAgICAgICAgYFwiJHsocXVlc3Rpb24udGFncyB8fCBbXSkuam9pbignOycpfVwiYCxcbiAgICAgICAgbmV3IERhdGUocXVlc3Rpb24uY3JlYXRlZEF0KS50b0lTT1N0cmluZygpLFxuICAgICAgICBuZXcgRGF0ZShxdWVzdGlvbi51cGRhdGVkQXQpLnRvSVNPU3RyaW5nKClcbiAgICAgIF1cbiAgICAgIGNzdlJvd3MucHVzaChyb3cuam9pbignLCcpKVxuICAgIH0pXG5cbiAgICByZXR1cm4gY3N2Um93cy5qb2luKCdcXG4nKVxuICB9XG5cbiAgLy8gRG93bmxvYWQgQ1NWIGZpbGVcbiAgZG93bmxvYWRDU1YoKTogdm9pZCB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGNzdkNvbnRlbnQgPSB0aGlzLmV4cG9ydFRvQ1NWKClcbiAgICAgIGNvbnN0IGJsb2IgPSBuZXcgQmxvYihbY3N2Q29udGVudF0sIHsgdHlwZTogJ3RleHQvY3N2O2NoYXJzZXQ9dXRmLTg7JyB9KVxuICAgICAgY29uc3QgbGluayA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2EnKVxuXG4gICAgICBpZiAobGluay5kb3dubG9hZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNvbnN0IHVybCA9IFVSTC5jcmVhdGVPYmplY3RVUkwoYmxvYilcbiAgICAgICAgbGluay5zZXRBdHRyaWJ1dGUoJ2hyZWYnLCB1cmwpXG4gICAgICAgIGxpbmsuc2V0QXR0cmlidXRlKCdkb3dubG9hZCcsIGB0ZWNoa3dpei1xdWVzdGlvbnMtJHtuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCkuc3BsaXQoJ1QnKVswXX0uY3N2YClcbiAgICAgICAgbGluay5zdHlsZS52aXNpYmlsaXR5ID0gJ2hpZGRlbidcbiAgICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChsaW5rKVxuICAgICAgICBsaW5rLmNsaWNrKClcbiAgICAgICAgZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZChsaW5rKVxuICAgICAgICBVUkwucmV2b2tlT2JqZWN0VVJMKHVybClcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgdGhyb3cgbmV3IFF1aXpEYXRhRXJyb3IoJ0ZhaWxlZCB0byBkb3dubG9hZCBDU1YgZmlsZScsICdFWFBPUlRfRVJST1InKVxuICAgIH1cbiAgfVxuXG4gIC8vIFBhcnNlIENTViBjb250ZW50XG4gIHBhcnNlQ1NWKGNzdkNvbnRlbnQ6IHN0cmluZyk6IHsgcXVlc3Rpb25zOiBQYXJ0aWFsPFF1aXpRdWVzdGlvbj5bXTsgZXJyb3JzOiBzdHJpbmdbXSB9IHtcbiAgICBjb25zdCBsaW5lcyA9IGNzdkNvbnRlbnQuc3BsaXQoJ1xcbicpLmZpbHRlcihsaW5lID0+IGxpbmUudHJpbSgpKVxuICAgIGNvbnN0IGVycm9yczogc3RyaW5nW10gPSBbXVxuICAgIGNvbnN0IHF1ZXN0aW9uczogUGFydGlhbDxRdWl6UXVlc3Rpb24+W10gPSBbXVxuXG4gICAgaWYgKGxpbmVzLmxlbmd0aCA8IDIpIHtcbiAgICAgIGVycm9ycy5wdXNoKCdDU1YgZmlsZSBtdXN0IGNvbnRhaW4gYXQgbGVhc3QgYSBoZWFkZXIgcm93IGFuZCBvbmUgZGF0YSByb3cnKVxuICAgICAgcmV0dXJuIHsgcXVlc3Rpb25zLCBlcnJvcnMgfVxuICAgIH1cblxuICAgIC8vIFNraXAgaGVhZGVyIHJvd1xuICAgIGNvbnN0IGRhdGFMaW5lcyA9IGxpbmVzLnNsaWNlKDEpXG5cbiAgICBkYXRhTGluZXMuZm9yRWFjaCgobGluZSwgaW5kZXgpID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHZhbHVlcyA9IHRoaXMucGFyc2VDU1ZMaW5lKGxpbmUpXG5cbiAgICAgICAgaWYgKHZhbHVlcy5sZW5ndGggPCA4KSB7XG4gICAgICAgICAgZXJyb3JzLnB1c2goYFJvdyAke2luZGV4ICsgMn06IEluc3VmZmljaWVudCBjb2x1bW5zIChtaW5pbXVtIDggcmVxdWlyZWQpYClcbiAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IFtpZCwgcXVlc3Rpb24sIG9wdDEsIG9wdDIsIG9wdDMsIG9wdDQsIGNvcnJlY3RBbnN3ZXIsIGNhdGVnb3J5LCBkaWZmaWN1bHR5LCB0eXBlLCBmdW5GYWN0LCB0YWdzLCBjcmVhdGVkQXQsIHVwZGF0ZWRBdF0gPSB2YWx1ZXNcblxuICAgICAgICAvLyBWYWxpZGF0ZSByZXF1aXJlZCBmaWVsZHNcbiAgICAgICAgaWYgKCFxdWVzdGlvbj8udHJpbSgpKSB7XG4gICAgICAgICAgZXJyb3JzLnB1c2goYFJvdyAke2luZGV4ICsgMn06IFF1ZXN0aW9uIGlzIHJlcXVpcmVkYClcbiAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghb3B0MT8udHJpbSgpIHx8ICFvcHQyPy50cmltKCkgfHwgIW9wdDM/LnRyaW0oKSB8fCAhb3B0ND8udHJpbSgpKSB7XG4gICAgICAgICAgZXJyb3JzLnB1c2goYFJvdyAke2luZGV4ICsgMn06IEFsbCA0IG9wdGlvbnMgYXJlIHJlcXVpcmVkYClcbiAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGNvcnJlY3RBbnN3ZXJOdW0gPSBwYXJzZUludChjb3JyZWN0QW5zd2VyKSAtIDEgLy8gQ29udmVydCAxLWJhc2VkIHRvIDAtYmFzZWRcbiAgICAgICAgaWYgKGlzTmFOKGNvcnJlY3RBbnN3ZXJOdW0pIHx8IGNvcnJlY3RBbnN3ZXJOdW0gPCAwIHx8IGNvcnJlY3RBbnN3ZXJOdW0gPiAzKSB7XG4gICAgICAgICAgZXJyb3JzLnB1c2goYFJvdyAke2luZGV4ICsgMn06IENvcnJlY3QgYW5zd2VyIG11c3QgYmUgMSwgMiwgMywgb3IgNGApXG4gICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWNhdGVnb3J5Py50cmltKCkpIHtcbiAgICAgICAgICBlcnJvcnMucHVzaChgUm93ICR7aW5kZXggKyAyfTogQ2F0ZWdvcnkgaXMgcmVxdWlyZWRgKVxuICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFbJ2JlZ2lubmVyJywgJ2ludGVybWVkaWF0ZScsICdhZHZhbmNlZCddLmluY2x1ZGVzKGRpZmZpY3VsdHkpKSB7XG4gICAgICAgICAgZXJyb3JzLnB1c2goYFJvdyAke2luZGV4ICsgMn06IERpZmZpY3VsdHkgbXVzdCBiZSAnYmVnaW5uZXInLCAnaW50ZXJtZWRpYXRlJywgb3IgJ2FkdmFuY2VkJ2ApXG4gICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIVsncmVndWxhcicsICdib251cyddLmluY2x1ZGVzKHR5cGUpKSB7XG4gICAgICAgICAgZXJyb3JzLnB1c2goYFJvdyAke2luZGV4ICsgMn06IFR5cGUgbXVzdCBiZSAncmVndWxhcicgb3IgJ2JvbnVzJ2ApXG4gICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBxdWVzdGlvbkRhdGE6IFBhcnRpYWw8UXVpelF1ZXN0aW9uPiA9IHtcbiAgICAgICAgICBpZDogaWQgfHwgYGltcG9ydGVkXyR7RGF0ZS5ub3coKX1fJHtpbmRleH1gLFxuICAgICAgICAgIHF1ZXN0aW9uOiBxdWVzdGlvbi50cmltKCksXG4gICAgICAgICAgb3B0aW9uczogW29wdDEudHJpbSgpLCBvcHQyLnRyaW0oKSwgb3B0My50cmltKCksIG9wdDQudHJpbSgpXSxcbiAgICAgICAgICBjb3JyZWN0QW5zd2VyOiBjb3JyZWN0QW5zd2VyTnVtLFxuICAgICAgICAgIGNhdGVnb3J5OiBjYXRlZ29yeS50cmltKCksXG4gICAgICAgICAgZGlmZmljdWx0eTogZGlmZmljdWx0eSBhcyAnYmVnaW5uZXInIHwgJ2ludGVybWVkaWF0ZScgfCAnYWR2YW5jZWQnLFxuICAgICAgICAgIHR5cGU6IHR5cGUgYXMgJ3JlZ3VsYXInIHwgJ2JvbnVzJyxcbiAgICAgICAgICBmdW5GYWN0OiBmdW5GYWN0Py50cmltKCkgfHwgdW5kZWZpbmVkLFxuICAgICAgICAgIHRhZ3M6IHRhZ3MgPyB0YWdzLnNwbGl0KCc7JykubWFwKHRhZyA9PiB0YWcudHJpbSgpKS5maWx0ZXIoQm9vbGVhbikgOiBbXSxcbiAgICAgICAgICBjcmVhdGVkQXQ6IGNyZWF0ZWRBdCA/IG5ldyBEYXRlKGNyZWF0ZWRBdCkuZ2V0VGltZSgpIDogRGF0ZS5ub3coKSxcbiAgICAgICAgICB1cGRhdGVkQXQ6IHVwZGF0ZWRBdCA/IG5ldyBEYXRlKHVwZGF0ZWRBdCkuZ2V0VGltZSgpIDogRGF0ZS5ub3coKVxuICAgICAgICB9XG5cbiAgICAgICAgcXVlc3Rpb25zLnB1c2gocXVlc3Rpb25EYXRhKVxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgZXJyb3JzLnB1c2goYFJvdyAke2luZGV4ICsgMn06ICR7ZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiAnUGFyc2UgZXJyb3InfWApXG4gICAgICB9XG4gICAgfSlcblxuICAgIHJldHVybiB7IHF1ZXN0aW9ucywgZXJyb3JzIH1cbiAgfVxuXG4gIC8vIEhlbHBlciB0byBwYXJzZSBDU1YgbGluZSB3aXRoIHByb3BlciBxdW90ZSBoYW5kbGluZ1xuICBwcml2YXRlIHBhcnNlQ1NWTGluZShsaW5lOiBzdHJpbmcpOiBzdHJpbmdbXSB7XG4gICAgY29uc3QgcmVzdWx0OiBzdHJpbmdbXSA9IFtdXG4gICAgbGV0IGN1cnJlbnQgPSAnJ1xuICAgIGxldCBpblF1b3RlcyA9IGZhbHNlXG4gICAgbGV0IGkgPSAwXG5cbiAgICB3aGlsZSAoaSA8IGxpbmUubGVuZ3RoKSB7XG4gICAgICBjb25zdCBjaGFyID0gbGluZVtpXVxuXG4gICAgICBpZiAoY2hhciA9PT0gJ1wiJykge1xuICAgICAgICBpZiAoaW5RdW90ZXMgJiYgbGluZVtpICsgMV0gPT09ICdcIicpIHtcbiAgICAgICAgICAvLyBFc2NhcGVkIHF1b3RlXG4gICAgICAgICAgY3VycmVudCArPSAnXCInXG4gICAgICAgICAgaSArPSAyXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gVG9nZ2xlIHF1b3RlIHN0YXRlXG4gICAgICAgICAgaW5RdW90ZXMgPSAhaW5RdW90ZXNcbiAgICAgICAgICBpKytcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChjaGFyID09PSAnLCcgJiYgIWluUXVvdGVzKSB7XG4gICAgICAgIC8vIEVuZCBvZiBmaWVsZFxuICAgICAgICByZXN1bHQucHVzaChjdXJyZW50KVxuICAgICAgICBjdXJyZW50ID0gJydcbiAgICAgICAgaSsrXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjdXJyZW50ICs9IGNoYXJcbiAgICAgICAgaSsrXG4gICAgICB9XG4gICAgfVxuXG4gICAgcmVzdWx0LnB1c2goY3VycmVudCkgLy8gQWRkIGxhc3QgZmllbGRcbiAgICByZXR1cm4gcmVzdWx0XG4gIH1cblxuICAvLyBJbXBvcnQgZnJvbSBDU1ZcbiAgaW1wb3J0RnJvbUNTVihjc3ZDb250ZW50OiBzdHJpbmcpOiBCdWxrT3BlcmF0aW9uUmVzdWx0IHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgeyBxdWVzdGlvbnMsIGVycm9ycyB9ID0gdGhpcy5wYXJzZUNTVihjc3ZDb250ZW50KVxuXG4gICAgICBpZiAoZXJyb3JzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgICBwcm9jZXNzZWRDb3VudDogMCxcbiAgICAgICAgICBlcnJvckNvdW50OiBlcnJvcnMubGVuZ3RoLFxuICAgICAgICAgIGVycm9yc1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGxldCBzdWNjZXNzQ291bnQgPSAwXG4gICAgICBjb25zdCBpbXBvcnRFcnJvcnM6IHN0cmluZ1tdID0gW11cblxuICAgICAgcXVlc3Rpb25zLmZvckVhY2goKHF1ZXN0aW9uRGF0YSwgaW5kZXgpID0+IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjb25zdCBmdWxsUXVlc3Rpb246IFF1aXpRdWVzdGlvbiA9IHtcbiAgICAgICAgICAgIGlkOiBxdWVzdGlvbkRhdGEuaWQhLFxuICAgICAgICAgICAgcXVlc3Rpb246IHF1ZXN0aW9uRGF0YS5xdWVzdGlvbiEsXG4gICAgICAgICAgICBvcHRpb25zOiBxdWVzdGlvbkRhdGEub3B0aW9ucyEsXG4gICAgICAgICAgICBjb3JyZWN0QW5zd2VyOiBxdWVzdGlvbkRhdGEuY29ycmVjdEFuc3dlciEsXG4gICAgICAgICAgICBjYXRlZ29yeTogcXVlc3Rpb25EYXRhLmNhdGVnb3J5ISxcbiAgICAgICAgICAgIGRpZmZpY3VsdHk6IHF1ZXN0aW9uRGF0YS5kaWZmaWN1bHR5ISxcbiAgICAgICAgICAgIHR5cGU6IHF1ZXN0aW9uRGF0YS50eXBlISxcbiAgICAgICAgICAgIGZ1bkZhY3Q6IHF1ZXN0aW9uRGF0YS5mdW5GYWN0LFxuICAgICAgICAgICAgdGFnczogcXVlc3Rpb25EYXRhLnRhZ3MgfHwgW10sXG4gICAgICAgICAgICBjcmVhdGVkQXQ6IHF1ZXN0aW9uRGF0YS5jcmVhdGVkQXQhLFxuICAgICAgICAgICAgdXBkYXRlZEF0OiBxdWVzdGlvbkRhdGEudXBkYXRlZEF0IVxuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIFZhbGlkYXRlIHRoZSBjb21wbGV0ZSBxdWVzdGlvblxuICAgICAgICAgIGNvbnN0IHZhbGlkYXRpb24gPSB0aGlzLnZhbGlkYXRlUXVlc3Rpb24oZnVsbFF1ZXN0aW9uKVxuICAgICAgICAgIGlmICghdmFsaWRhdGlvbi5pc1ZhbGlkKSB7XG4gICAgICAgICAgICBpbXBvcnRFcnJvcnMucHVzaChgUXVlc3Rpb24gJHtpbmRleCArIDF9OiAke3ZhbGlkYXRpb24uZXJyb3JzLmpvaW4oJywgJyl9YClcbiAgICAgICAgICAgIHJldHVyblxuICAgICAgICAgIH1cblxuICAgICAgICAgIHRoaXMuc2F2ZVF1ZXN0aW9uKGZ1bGxRdWVzdGlvbilcbiAgICAgICAgICBzdWNjZXNzQ291bnQrK1xuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgIGltcG9ydEVycm9ycy5wdXNoKGBRdWVzdGlvbiAke2luZGV4ICsgMX06ICR7ZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiAnU2F2ZSBlcnJvcid9YClcbiAgICAgICAgfVxuICAgICAgfSlcblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc3VjY2VzczogaW1wb3J0RXJyb3JzLmxlbmd0aCA9PT0gMCxcbiAgICAgICAgcHJvY2Vzc2VkQ291bnQ6IHN1Y2Nlc3NDb3VudCxcbiAgICAgICAgZXJyb3JDb3VudDogaW1wb3J0RXJyb3JzLmxlbmd0aCxcbiAgICAgICAgZXJyb3JzOiBpbXBvcnRFcnJvcnNcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICAgIHByb2Nlc3NlZENvdW50OiAwLFxuICAgICAgICBlcnJvckNvdW50OiAxLFxuICAgICAgICBlcnJvcnM6IFtlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6ICdJbXBvcnQgZmFpbGVkJ11cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLy8gRXhwb3J0IHNpbmdsZXRvbiBpbnN0YW5jZVxuZXhwb3J0IGNvbnN0IHF1aXpEYXRhTWFuYWdlciA9IFF1aXpEYXRhTWFuYWdlci5nZXRJbnN0YW5jZSgpXG4iXSwibmFtZXMiOlsiUVVJWl9TVE9SQUdFX0tFWVMiLCJERUZBVUxUX0NBVEVHT1JJRVMiLCJWQUxJREFUSU9OX1JVTEVTIiwiUVVFU1RJT05fTUlOX0xFTkdUSCIsIlFVRVNUSU9OX01BWF9MRU5HVEgiLCJPUFRJT05fTUlOX0xFTkdUSCIsIk9QVElPTl9NQVhfTEVOR1RIIiwiTUlOX09QVElPTlMiLCJNQVhfT1BUSU9OUyIsIk1BWF9CVUxLX09QRVJBVElPTlMiLCJNQVhfRklMRV9TSVpFIiwiQVVUT19TQVZFX0lOVEVSVkFMIiwiUXVpekRhdGFFcnJvciIsIkVycm9yIiwibWVzc2FnZSIsImNvZGUiLCJuYW1lIiwiUXVpekRhdGFNYW5hZ2VyIiwiZ2V0SW5zdGFuY2UiLCJpbnN0YW5jZSIsInNhZmVHZXRJdGVtIiwia2V5IiwibG9jYWxTdG9yYWdlIiwiZ2V0SXRlbSIsImVycm9yIiwiY29uc29sZSIsInNhZmVTZXRJdGVtIiwidmFsdWUiLCJzZXRJdGVtIiwiRE9NRXhjZXB0aW9uIiwiZ2V0UXVlc3Rpb25zIiwiZGF0YSIsIlFVRVNUSU9OUyIsImluaXRpYWxpemVXaXRoU2FtcGxlRGF0YSIsInF1ZXN0aW9ucyIsIkpTT04iLCJwYXJzZSIsIkFycmF5IiwiaXNBcnJheSIsImdldEZpbHRlcmVkUXVlc3Rpb25zIiwiZmlsdGVycyIsImZpbHRlciIsInF1ZXN0aW9uIiwiY2F0ZWdvcnkiLCJkaWZmaWN1bHR5IiwidHlwZSIsInNlY3Rpb24iLCJzdWJjYXRlZ29yeSIsInRhZ3MiLCJzb21lIiwidGFnIiwiaW5jbHVkZXMiLCJnZXRRdWVzdGlvbnNCeVNlY3Rpb24iLCJnZXRRdWVzdGlvbnNCeUNhdGVnb3J5QW5kU2VjdGlvbiIsInNhdmVRdWVzdGlvbiIsInZhbGlkYXRlUXVlc3Rpb24iLCJub3ciLCJEYXRlIiwibmV3UXVlc3Rpb24iLCJpZCIsImdlbmVyYXRlSWQiLCJjcmVhdGVkQXQiLCJ1cGRhdGVkQXQiLCJwdXNoIiwic2F2ZVF1ZXN0aW9ucyIsInVwZGF0ZVF1ZXN0aW9uIiwidXBkYXRlcyIsImluZGV4IiwiZmluZEluZGV4IiwicSIsInVwZGF0ZWRRdWVzdGlvbiIsImRlbGV0ZVF1ZXN0aW9uIiwiZmlsdGVyZWRRdWVzdGlvbnMiLCJsZW5ndGgiLCJidWxrRGVsZXRlIiwiaWRzIiwiaW5pdGlhbENvdW50IiwiZGVsZXRlZENvdW50Iiwic3VjY2VzcyIsInByb2Nlc3NlZENvdW50IiwiZXJyb3JDb3VudCIsImVycm9ycyIsInNlYXJjaFF1ZXN0aW9ucyIsInNlYXJjaFRleHQiLCJzZWFyY2hMb3dlciIsInRvTG93ZXJDYXNlIiwiZ2V0Q2F0ZWdvcmllcyIsImNhdGVnb3J5Q291bnRzIiwicmVkdWNlIiwiYWNjIiwibWFwIiwicXVlc3Rpb25Db3VudCIsInNhdmVEcmFmdCIsImRyYWZ0IiwiZHJhZnRzIiwiZ2V0RHJhZnRzIiwiZXhpc3RpbmdJbmRleCIsImQiLCJsYXN0U2F2ZWQiLCJEUkFGVFMiLCJzdHJpbmdpZnkiLCJkZWxldGVEcmFmdCIsImdldFNldHRpbmdzIiwiU0VUVElOR1MiLCJnZXREZWZhdWx0U2V0dGluZ3MiLCJzYXZlU2V0dGluZ3MiLCJzZXR0aW5ncyIsImN1cnJlbnRTZXR0aW5ncyIsInVwZGF0ZWRTZXR0aW5ncyIsInBhZ2VTaXplIiwic29ydEJ5Iiwic29ydE9yZGVyIiwic2VsZWN0ZWRRdWVzdGlvbnMiLCJvcHRpb25zIiwiZm9yRWFjaCIsIm9wdGlvbiIsInVuaXF1ZU9wdGlvbnMiLCJTZXQiLCJvcHQiLCJ0cmltIiwic2l6ZSIsImNvcnJlY3RBbnN3ZXIiLCJ2YWxpZENhdGVnb3JpZXMiLCJjIiwiTWF0aCIsInJhbmRvbSIsInRvU3RyaW5nIiwic3Vic3RyIiwiZXhwb3J0VG9DU1YiLCJxdWVzdGlvbnNUb0V4cG9ydCIsImhlYWRlcnMiLCJjc3ZSb3dzIiwiam9pbiIsInJlcGxhY2UiLCJmdW5GYWN0IiwidG9JU09TdHJpbmciLCJpbXBvcnRGcm9tQ1NWIiwiY3N2Q29udGVudCIsImxpbmVzIiwic3BsaXQiLCJsaW5lIiwiaCIsImRhdGFMaW5lcyIsInNsaWNlIiwicmVzdWx0cyIsInZhbGlkUXVlc3Rpb25zIiwiZXhpc3RpbmdRdWVzdGlvbnMiLCJpIiwidmFsdWVzIiwicGFyc2VDU1ZMaW5lIiwicGFyc2VJbnQiLCJ1bmRlZmluZWQiLCJ0IiwiZ2V0VGltZSIsImFsbFF1ZXN0aW9ucyIsInJlc3VsdCIsImN1cnJlbnQiLCJpblF1b3RlcyIsImNoYXIiLCJzaG91bGRJbXBvcnRFeGlzdGluZ1F1ZXN0aW9ucyIsImltcG9ydEFsbEV4aXN0aW5nUXVlc3Rpb25zIiwic2FtcGxlUXVlc3Rpb25zIiwiaGFzSW1wb3J0ZWQiLCJvbmJvYXJkaW5nUXVlc3Rpb25zIiwiaW1wb3J0T25ib2FyZGluZ1F1ZXN0aW9ucyIsImhvbWVwYWdlUXVlc3Rpb25zIiwiaW1wb3J0SG9tZXBhZ2VRdWVzdGlvbnMiLCJjYXRlZ29yeVF1ZXN0aW9ucyIsImltcG9ydENhdGVnb3J5UXVlc3Rpb25zIiwibG9nIiwiY3JlYXRlQmFja3VwIiwiYmFja3VwIiwidGltZXN0YW1wIiwidmVyc2lvbiIsInJlc3RvcmVGcm9tQmFja3VwIiwiYmFja3VwRGF0YSIsImN1cnJlbnRCYWNrdXAiLCJCQUNLVVAiLCJzdGFydEF1dG9TYXZlIiwiZHJhZnRJZCIsImdldERyYWZ0RGF0YSIsInN0b3BBdXRvU2F2ZSIsImF1dG9TYXZlVGltZXIiLCJzZXRJbnRlcnZhbCIsImRyYWZ0RGF0YSIsImNsZWFySW50ZXJ2YWwiLCJyb3ciLCJkb3dubG9hZENTViIsImJsb2IiLCJCbG9iIiwibGluayIsImRvY3VtZW50IiwiY3JlYXRlRWxlbWVudCIsImRvd25sb2FkIiwidXJsIiwiVVJMIiwiY3JlYXRlT2JqZWN0VVJMIiwic2V0QXR0cmlidXRlIiwic3R5bGUiLCJ2aXNpYmlsaXR5IiwiYm9keSIsImFwcGVuZENoaWxkIiwiY2xpY2siLCJyZW1vdmVDaGlsZCIsInJldm9rZU9iamVjdFVSTCIsInBhcnNlQ1NWIiwib3B0MSIsIm9wdDIiLCJvcHQzIiwib3B0NCIsImNvcnJlY3RBbnN3ZXJOdW0iLCJpc05hTiIsInF1ZXN0aW9uRGF0YSIsIkJvb2xlYW4iLCJzdWNjZXNzQ291bnQiLCJpbXBvcnRFcnJvcnMiLCJmdWxsUXVlc3Rpb24iLCJ2YWxpZGF0aW9uIiwiaXNWYWxpZCIsInF1aXpEYXRhTWFuYWdlciJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/utils/quizDataManager.ts\n"));

/***/ })

});