"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./src/utils/quizDataManager.ts":
/*!**************************************!*\
  !*** ./src/utils/quizDataManager.ts ***!
  \**************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   QuizDataError: () => (/* binding */ QuizDataError),\n/* harmony export */   VALIDATION_RULES: () => (/* binding */ VALIDATION_RULES),\n/* harmony export */   quizDataManager: () => (/* binding */ quizDataManager)\n/* harmony export */ });\n/* harmony import */ var _types_admin__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/types/admin */ \"(app-pages-browser)/./src/types/admin.ts\");\n\n// Data validation schemas\nconst VALIDATION_RULES = {\n    QUESTION_MIN_LENGTH: 10,\n    QUESTION_MAX_LENGTH: 500,\n    OPTION_MIN_LENGTH: 1,\n    OPTION_MAX_LENGTH: 100,\n    MIN_OPTIONS: 4,\n    MAX_OPTIONS: 4,\n    MAX_BULK_OPERATIONS: 50,\n    MAX_FILE_SIZE: 5 * 1024 * 1024,\n    AUTO_SAVE_INTERVAL: 30000 // 30 seconds\n};\n// Error types\nclass QuizDataError extends Error {\n    constructor(message, code){\n        super(message), this.code = code;\n        this.name = 'QuizDataError';\n    }\n}\n// Utility functions for localStorage operations\nclass QuizDataManager {\n    static getInstance() {\n        if (!QuizDataManager.instance) {\n            QuizDataManager.instance = new QuizDataManager();\n        }\n        return QuizDataManager.instance;\n    }\n    // Safe localStorage operations with error handling\n    safeGetItem(key) {\n        // Return null if not on client side\n        if (false) {}\n        try {\n            return localStorage.getItem(key);\n        } catch (error) {\n            console.error(\"Error reading from localStorage key \".concat(key, \":\"), error);\n            return null;\n        }\n    }\n    safeSetItem(key, value) {\n        // Return false if not on client side\n        if (false) {}\n        try {\n            localStorage.setItem(key, value);\n            return true;\n        } catch (error) {\n            console.error(\"Error writing to localStorage key \".concat(key, \":\"), error);\n            if (error instanceof DOMException && error.code === 22) {\n                throw new QuizDataError('Storage quota exceeded. Please clear some data.', 'QUOTA_EXCEEDED');\n            }\n            return false;\n        }\n    }\n    // Question CRUD operations\n    getQuestions() {\n        const data = this.safeGetItem(_types_admin__WEBPACK_IMPORTED_MODULE_0__.QUIZ_STORAGE_KEYS.QUESTIONS);\n        if (!data) return this.initializeWithSampleData();\n        try {\n            const questions = JSON.parse(data);\n            return Array.isArray(questions) ? questions : [];\n        } catch (error) {\n            console.error('Error parsing questions data:', error);\n            return this.initializeWithSampleData();\n        }\n    }\n    // Get questions with filtering support\n    getFilteredQuestions(filters) {\n        const questions = this.getQuestions();\n        if (!filters) return questions;\n        return questions.filter((question)=>{\n            if (filters.category && question.category !== filters.category) return false;\n            if (filters.difficulty && question.difficulty !== filters.difficulty) return false;\n            if (filters.type && question.type !== filters.type) return false;\n            if (filters.section && question.section !== filters.section) return false;\n            if (filters.subcategory && question.subcategory !== filters.subcategory) return false;\n            if (filters.tags && !filters.tags.some((tag)=>{\n                var _question_tags;\n                return (_question_tags = question.tags) === null || _question_tags === void 0 ? void 0 : _question_tags.includes(tag);\n            })) return false;\n            return true;\n        });\n    }\n    // Get questions by section\n    getQuestionsBySection(section) {\n        return this.getFilteredQuestions({\n            section\n        });\n    }\n    // Get questions by category and section\n    getQuestionsByCategoryAndSection(category, section) {\n        return this.getFilteredQuestions({\n            category,\n            section\n        });\n    }\n    saveQuestion(question) {\n        this.validateQuestion(question);\n        const questions = this.getQuestions();\n        const now = Date.now();\n        const newQuestion = {\n            ...question,\n            id: this.generateId(),\n            createdAt: now,\n            updatedAt: now\n        };\n        questions.push(newQuestion);\n        this.saveQuestions(questions);\n        return newQuestion;\n    }\n    updateQuestion(id, updates) {\n        const questions = this.getQuestions();\n        const index = questions.findIndex((q)=>q.id === id);\n        if (index === -1) {\n            throw new QuizDataError(\"Question with id \".concat(id, \" not found\"), 'NOT_FOUND');\n        }\n        const updatedQuestion = {\n            ...questions[index],\n            ...updates,\n            updatedAt: Date.now()\n        };\n        this.validateQuestion(updatedQuestion);\n        questions[index] = updatedQuestion;\n        this.saveQuestions(questions);\n        return updatedQuestion;\n    }\n    deleteQuestion(id) {\n        const questions = this.getQuestions();\n        const filteredQuestions = questions.filter((q)=>q.id !== id);\n        if (filteredQuestions.length === questions.length) {\n            throw new QuizDataError(\"Question with id \".concat(id, \" not found\"), 'NOT_FOUND');\n        }\n        this.saveQuestions(filteredQuestions);\n        return true;\n    }\n    bulkDelete(ids) {\n        if (ids.length > VALIDATION_RULES.MAX_BULK_OPERATIONS) {\n            throw new QuizDataError(\"Cannot delete more than \".concat(VALIDATION_RULES.MAX_BULK_OPERATIONS, \" questions at once\"), 'BULK_LIMIT_EXCEEDED');\n        }\n        const questions = this.getQuestions();\n        const initialCount = questions.length;\n        const filteredQuestions = questions.filter((q)=>!ids.includes(q.id));\n        const deletedCount = initialCount - filteredQuestions.length;\n        this.saveQuestions(filteredQuestions);\n        return {\n            success: true,\n            processedCount: deletedCount,\n            errorCount: ids.length - deletedCount,\n            errors: ids.length > deletedCount ? [\n                'Some questions were not found'\n            ] : []\n        };\n    }\n    // Search and filter operations\n    searchQuestions(filters) {\n        const questions = this.getQuestions();\n        return questions.filter((question)=>{\n            // Text search\n            if (filters.searchText) {\n                const searchLower = filters.searchText.toLowerCase();\n                if (!question.question.toLowerCase().includes(searchLower)) {\n                    return false;\n                }\n            }\n            // Category filter\n            if (filters.category !== 'all' && question.category !== filters.category) {\n                return false;\n            }\n            // Difficulty filter\n            if (filters.difficulty !== 'all' && question.difficulty !== filters.difficulty) {\n                return false;\n            }\n            // Type filter\n            if (filters.type !== 'all' && question.type !== filters.type) {\n                return false;\n            }\n            return true;\n        });\n    }\n    // Categories management\n    getCategories() {\n        const questions = this.getQuestions();\n        const categoryCounts = questions.reduce((acc, question)=>{\n            acc[question.category] = (acc[question.category] || 0) + 1;\n            return acc;\n        }, {});\n        return _types_admin__WEBPACK_IMPORTED_MODULE_0__.DEFAULT_CATEGORIES.map((category)=>({\n                ...category,\n                questionCount: categoryCounts[category.id] || 0\n            }));\n    }\n    // Draft management\n    saveDraft(draft) {\n        const drafts = this.getDrafts();\n        const existingIndex = drafts.findIndex((d)=>d.id === draft.id);\n        if (existingIndex >= 0) {\n            drafts[existingIndex] = {\n                ...draft,\n                lastSaved: Date.now()\n            };\n        } else {\n            drafts.push({\n                ...draft,\n                lastSaved: Date.now()\n            });\n        }\n        this.safeSetItem(_types_admin__WEBPACK_IMPORTED_MODULE_0__.QUIZ_STORAGE_KEYS.DRAFTS, JSON.stringify(drafts));\n    }\n    getDrafts() {\n        const data = this.safeGetItem(_types_admin__WEBPACK_IMPORTED_MODULE_0__.QUIZ_STORAGE_KEYS.DRAFTS);\n        if (!data) return [];\n        try {\n            return JSON.parse(data);\n        } catch (error) {\n            console.error('Error parsing drafts data:', error);\n            return [];\n        }\n    }\n    deleteDraft(id) {\n        const drafts = this.getDrafts().filter((d)=>d.id !== id);\n        this.safeSetItem(_types_admin__WEBPACK_IMPORTED_MODULE_0__.QUIZ_STORAGE_KEYS.DRAFTS, JSON.stringify(drafts));\n    }\n    // Settings management\n    getSettings() {\n        const data = this.safeGetItem(_types_admin__WEBPACK_IMPORTED_MODULE_0__.QUIZ_STORAGE_KEYS.SETTINGS);\n        if (!data) return this.getDefaultSettings();\n        try {\n            return {\n                ...this.getDefaultSettings(),\n                ...JSON.parse(data)\n            };\n        } catch (error) {\n            console.error('Error parsing settings data:', error);\n            return this.getDefaultSettings();\n        }\n    }\n    saveSettings(settings) {\n        const currentSettings = this.getSettings();\n        const updatedSettings = {\n            ...currentSettings,\n            ...settings\n        };\n        this.safeSetItem(_types_admin__WEBPACK_IMPORTED_MODULE_0__.QUIZ_STORAGE_KEYS.SETTINGS, JSON.stringify(updatedSettings));\n    }\n    getDefaultSettings() {\n        return {\n            pageSize: 10,\n            sortBy: 'updatedAt',\n            sortOrder: 'desc',\n            filters: {\n                searchText: '',\n                category: 'all',\n                difficulty: 'all',\n                type: 'all'\n            },\n            selectedQuestions: []\n        };\n    }\n    // Validation\n    validateQuestion(question) {\n        if (!question.question || question.question.length < VALIDATION_RULES.QUESTION_MIN_LENGTH) {\n            throw new QuizDataError(\"Question must be at least \".concat(VALIDATION_RULES.QUESTION_MIN_LENGTH, \" characters long\"), 'INVALID_QUESTION_LENGTH');\n        }\n        if (question.question.length > VALIDATION_RULES.QUESTION_MAX_LENGTH) {\n            throw new QuizDataError(\"Question must be no more than \".concat(VALIDATION_RULES.QUESTION_MAX_LENGTH, \" characters long\"), 'INVALID_QUESTION_LENGTH');\n        }\n        if (!question.options || question.options.length !== VALIDATION_RULES.MIN_OPTIONS) {\n            throw new QuizDataError(\"Question must have exactly \".concat(VALIDATION_RULES.MIN_OPTIONS, \" options\"), 'INVALID_OPTIONS_COUNT');\n        }\n        // Validate each option\n        question.options.forEach((option, index)=>{\n            if (!option || option.length < VALIDATION_RULES.OPTION_MIN_LENGTH) {\n                throw new QuizDataError(\"Option \".concat(index + 1, \" must be at least \").concat(VALIDATION_RULES.OPTION_MIN_LENGTH, \" character long\"), 'INVALID_OPTION_LENGTH');\n            }\n            if (option.length > VALIDATION_RULES.OPTION_MAX_LENGTH) {\n                throw new QuizDataError(\"Option \".concat(index + 1, \" must be no more than \").concat(VALIDATION_RULES.OPTION_MAX_LENGTH, \" characters long\"), 'INVALID_OPTION_LENGTH');\n            }\n        });\n        // Check for duplicate options\n        const uniqueOptions = new Set(question.options.map((opt)=>opt.toLowerCase().trim()));\n        if (uniqueOptions.size !== question.options.length) {\n            throw new QuizDataError('All options must be unique', 'DUPLICATE_OPTIONS');\n        }\n        // Validate correct answer\n        if (typeof question.correctAnswer !== 'number' || question.correctAnswer < 0 || question.correctAnswer >= question.options.length) {\n            throw new QuizDataError('Invalid correct answer selection', 'INVALID_CORRECT_ANSWER');\n        }\n        // Validate category\n        const validCategories = _types_admin__WEBPACK_IMPORTED_MODULE_0__.DEFAULT_CATEGORIES.map((c)=>c.id);\n        if (!question.category || !validCategories.includes(question.category)) {\n            throw new QuizDataError('Invalid category selection', 'INVALID_CATEGORY');\n        }\n    }\n    // Utility methods\n    saveQuestions(questions) {\n        this.safeSetItem(_types_admin__WEBPACK_IMPORTED_MODULE_0__.QUIZ_STORAGE_KEYS.QUESTIONS, JSON.stringify(questions));\n    }\n    generateId() {\n        return \"q_\".concat(Date.now(), \"_\").concat(Math.random().toString(36).substr(2, 9));\n    }\n    // CSV Export/Import functionality\n    exportToCSV(questions) {\n        const questionsToExport = questions || this.getQuestions();\n        const headers = [\n            'ID',\n            'Question',\n            'Option 1',\n            'Option 2',\n            'Option 3',\n            'Option 4',\n            'Correct Answer',\n            'Category',\n            'Difficulty',\n            'Type',\n            'Fun Fact',\n            'Tags',\n            'Created At',\n            'Updated At'\n        ];\n        const csvRows = [\n            headers.join(','),\n            ...questionsToExport.map((q)=>[\n                    q.id,\n                    '\"'.concat(q.question.replace(/\"/g, '\"\"'), '\"'),\n                    '\"'.concat(q.options[0].replace(/\"/g, '\"\"'), '\"'),\n                    '\"'.concat(q.options[1].replace(/\"/g, '\"\"'), '\"'),\n                    '\"'.concat(q.options[2].replace(/\"/g, '\"\"'), '\"'),\n                    '\"'.concat(q.options[3].replace(/\"/g, '\"\"'), '\"'),\n                    q.correctAnswer + 1,\n                    q.category,\n                    q.difficulty,\n                    q.type,\n                    '\"'.concat((q.funFact || '').replace(/\"/g, '\"\"'), '\"'),\n                    '\"'.concat((q.tags || []).join(';'), '\"'),\n                    new Date(q.createdAt).toISOString(),\n                    new Date(q.updatedAt).toISOString()\n                ].join(','))\n        ];\n        // Add UTF-8 BOM for Excel compatibility\n        return '\\uFEFF' + csvRows.join('\\n');\n    }\n    async importFromCSV(csvContent) {\n        const lines = csvContent.split('\\n').filter((line)=>line.trim());\n        if (lines.length < 2) {\n            throw new QuizDataError('CSV file must contain at least a header and one data row', 'INVALID_CSV_FORMAT');\n        }\n        const headers = lines[0].split(',').map((h)=>h.trim().replace(/\"/g, ''));\n        const dataLines = lines.slice(1);\n        const results = {\n            success: true,\n            processedCount: 0,\n            errorCount: 0,\n            errors: []\n        };\n        const validQuestions = [];\n        const existingQuestions = this.getQuestions();\n        for(let i = 0; i < dataLines.length; i++){\n            try {\n                const values = this.parseCSVLine(dataLines[i]);\n                if (values.length < 8) {\n                    results.errors.push(\"Line \".concat(i + 2, \": Insufficient data columns\"));\n                    results.errorCount++;\n                    continue;\n                }\n                const question = {\n                    id: values[0] || this.generateId(),\n                    question: values[1],\n                    options: [\n                        values[2],\n                        values[3],\n                        values[4],\n                        values[5]\n                    ],\n                    correctAnswer: parseInt(values[6]) - 1,\n                    category: values[7],\n                    difficulty: values[8],\n                    type: values[9] || 'regular',\n                    funFact: values[10] || undefined,\n                    tags: values[11] ? values[11].split(';').filter((t)=>t.trim()) : undefined,\n                    createdAt: values[12] ? new Date(values[12]).getTime() : Date.now(),\n                    updatedAt: values[13] ? new Date(values[13]).getTime() : Date.now()\n                };\n                // Validate the question\n                this.validateQuestion(question);\n                // Check for duplicates\n                const existingIndex = existingQuestions.findIndex((q)=>q.id === question.id);\n                if (existingIndex >= 0) {\n                    // Update existing question\n                    existingQuestions[existingIndex] = question;\n                } else {\n                    validQuestions.push(question);\n                }\n                results.processedCount++;\n            } catch (error) {\n                results.errors.push(\"Line \".concat(i + 2, \": \").concat(error instanceof Error ? error.message : 'Unknown error'));\n                results.errorCount++;\n            }\n        }\n        // Save all valid questions\n        if (validQuestions.length > 0) {\n            const allQuestions = [\n                ...existingQuestions,\n                ...validQuestions\n            ];\n            this.saveQuestions(allQuestions);\n        }\n        results.success = results.errorCount === 0;\n        return results;\n    }\n    parseCSVLine(line) {\n        const result = [];\n        let current = '';\n        let inQuotes = false;\n        for(let i = 0; i < line.length; i++){\n            const char = line[i];\n            if (char === '\"') {\n                if (inQuotes && line[i + 1] === '\"') {\n                    current += '\"';\n                    i++; // Skip next quote\n                } else {\n                    inQuotes = !inQuotes;\n                }\n            } else if (char === ',' && !inQuotes) {\n                result.push(current.trim());\n                current = '';\n            } else {\n                current += char;\n            }\n        }\n        result.push(current.trim());\n        return result;\n    }\n    initializeWithSampleData() {\n        // Check if we should import existing questions\n        if (this.shouldImportExistingQuestions()) {\n            return this.importAllExistingQuestions();\n        }\n        // Initialize with a few sample questions for demonstration\n        const sampleQuestions = [\n            {\n                id: 'sample_1',\n                question: 'Which social media platform is known for its short-form video content and viral dances?',\n                options: [\n                    'Instagram',\n                    'TikTok',\n                    'Twitter',\n                    'Snapchat'\n                ],\n                correctAnswer: 1,\n                category: 'social-media',\n                difficulty: 'beginner',\n                type: 'regular',\n                section: 'homepage',\n                funFact: 'TikTok was originally called Musical.ly before being acquired by ByteDance.',\n                tags: [\n                    'social-media',\n                    'video',\n                    'viral'\n                ],\n                createdAt: Date.now() - 86400000,\n                updatedAt: Date.now() - 86400000\n            }\n        ];\n        this.saveQuestions(sampleQuestions);\n        return sampleQuestions;\n    }\n    // Check if we should import existing questions\n    shouldImportExistingQuestions() {\n        // Only import if localStorage is empty and we're on client side\n        if (false) {}\n        const hasImported = this.safeGetItem('quiz_questions_imported');\n        return !hasImported;\n    }\n    // Import all existing questions from different sources\n    importAllExistingQuestions() {\n        const allQuestions = [];\n        try {\n            // Import onboarding questions\n            const onboardingQuestions = this.importOnboardingQuestions();\n            allQuestions.push(...onboardingQuestions);\n            // Import homepage fallback questions\n            const homepageQuestions = this.importHomepageQuestions();\n            allQuestions.push(...homepageQuestions);\n            // Import category questions from quiz database\n            const categoryQuestions = this.importCategoryQuestions();\n            allQuestions.push(...categoryQuestions);\n            console.log(\"\\uD83D\\uDCCA Imported \".concat(allQuestions.length, \" questions from existing sources\"));\n            // Save all imported questions\n            this.saveQuestions(allQuestions);\n            // Mark as imported\n            this.safeSetItem('quiz_questions_imported', 'true');\n            return allQuestions;\n        } catch (error) {\n            console.error('Error importing existing questions:', error);\n            return [];\n        }\n    }\n    // Import methods for existing questions\n    importOnboardingQuestions() {\n        const onboardingQuestions = [\n            {\n                id: 'onboard-1',\n                question: \"Which tech company created the iPhone?\",\n                options: [\n                    \"Apple ðŸŽ\",\n                    \"Google ðŸ”\",\n                    \"Samsung ðŸ“±\",\n                    \"Microsoft ðŸ’»\"\n                ],\n                correctAnswer: 0,\n                category: 'technology',\n                difficulty: 'beginner',\n                type: 'regular',\n                section: 'onboarding',\n                rewardCoins: 150,\n                funFact: \"The first iPhone was released on June 29, 2007, revolutionizing the smartphone industry.\",\n                tags: [\n                    'technology',\n                    'apple',\n                    'smartphone'\n                ],\n                createdAt: Date.now(),\n                updatedAt: Date.now()\n            },\n            {\n                id: 'onboard-2',\n                question: \"What does 'WWW' stand for?\",\n                options: [\n                    \"World Wide Web ðŸŒ\",\n                    \"World Web Works ðŸ”§\",\n                    \"Web World Wide ðŸŒ\",\n                    \"Wide World Web ðŸ“¡\"\n                ],\n                correctAnswer: 0,\n                category: 'technology',\n                difficulty: 'beginner',\n                type: 'regular',\n                section: 'onboarding',\n                rewardCoins: 150,\n                funFact: \"The World Wide Web was invented by Tim Berners-Lee in 1989 while working at CERN.\",\n                tags: [\n                    'technology',\n                    'internet',\n                    'web'\n                ],\n                createdAt: Date.now(),\n                updatedAt: Date.now()\n            }\n        ];\n        return onboardingQuestions;\n    }\n    importHomepageQuestions() {\n        const homepageQuestions = [\n            {\n                id: 'homepage-1',\n                question: \"Which social media platform is known for short-form videos?\",\n                options: [\n                    \"Instagram\",\n                    \"TikTok\",\n                    \"Twitter\",\n                    \"Snapchat\"\n                ],\n                correctAnswer: 1,\n                category: 'social-media',\n                difficulty: 'beginner',\n                type: 'regular',\n                section: 'homepage',\n                funFact: \"TikTok was originally called Musical.ly!\",\n                tags: [\n                    'social-media',\n                    'video',\n                    'apps'\n                ],\n                createdAt: Date.now(),\n                updatedAt: Date.now()\n            },\n            {\n                id: 'homepage-2',\n                question: \"What does 'AI' stand for?\",\n                options: [\n                    \"Artificial Intelligence\",\n                    \"Automated Internet\",\n                    \"Advanced Interface\",\n                    \"Algorithmic Integration\"\n                ],\n                correctAnswer: 0,\n                category: 'technology',\n                difficulty: 'beginner',\n                type: 'regular',\n                section: 'homepage',\n                funFact: \"The term 'Artificial Intelligence' was first coined in 1956!\",\n                tags: [\n                    'technology',\n                    'ai',\n                    'computing'\n                ],\n                createdAt: Date.now(),\n                updatedAt: Date.now()\n            },\n            {\n                id: 'homepage-3',\n                question: \"Which company created the iPhone?\",\n                options: [\n                    \"Google\",\n                    \"Samsung\",\n                    \"Apple\",\n                    \"Microsoft\"\n                ],\n                correctAnswer: 2,\n                category: 'technology',\n                difficulty: 'beginner',\n                type: 'regular',\n                section: 'homepage',\n                funFact: \"The first iPhone was released in 2007!\",\n                tags: [\n                    'technology',\n                    'apple',\n                    'smartphone'\n                ],\n                createdAt: Date.now(),\n                updatedAt: Date.now()\n            }\n        ];\n        return homepageQuestions;\n    }\n    importCategoryQuestions() {\n        // Import a subset of questions from the quiz database\n        const categoryQuestions = [];\n        try {\n            // Sample category questions - in a real implementation, this would import from the actual quiz database\n            const sampleCategoryQuestions = [\n                {\n                    id: 'cat-tech-1',\n                    question: \"Which programming language is known for its use in web development and has a coffee-related name?\",\n                    options: [\n                        \"Python\",\n                        \"Java\",\n                        \"JavaScript\",\n                        \"C++\"\n                    ],\n                    correctAnswer: 1,\n                    category: 'technology',\n                    difficulty: 'intermediate',\n                    type: 'regular',\n                    section: 'category',\n                    subcategory: 'programming',\n                    funFact: \"Java was originally called Oak and was developed by James Gosling at Sun Microsystems.\",\n                    tags: [\n                        'programming',\n                        'java',\n                        'development'\n                    ],\n                    createdAt: Date.now(),\n                    updatedAt: Date.now()\n                },\n                {\n                    id: 'cat-social-1',\n                    question: \"Which social media platform was originally called 'The Facebook'?\",\n                    options: [\n                        \"Instagram\",\n                        \"Twitter\",\n                        \"Facebook\",\n                        \"LinkedIn\"\n                    ],\n                    correctAnswer: 2,\n                    category: 'social-media',\n                    difficulty: 'beginner',\n                    type: 'regular',\n                    section: 'category',\n                    subcategory: 'history',\n                    funFact: \"Facebook was founded by Mark Zuckerberg in 2004 while he was a student at Harvard University.\",\n                    tags: [\n                        'social-media',\n                        'facebook',\n                        'history'\n                    ],\n                    createdAt: Date.now(),\n                    updatedAt: Date.now()\n                }\n            ];\n            categoryQuestions.push(...sampleCategoryQuestions);\n        } catch (error) {\n            console.error('Error importing category questions:', error);\n        }\n        return categoryQuestions;\n    }\n    // Force reimport of all questions (for admin use)\n    forceReimportQuestions() {\n        try {\n            // Clear the import flag\n            this.safeSetItem('quiz_questions_imported', '');\n            // Clear existing questions\n            this.safeSetItem(_types_admin__WEBPACK_IMPORTED_MODULE_0__.QUIZ_STORAGE_KEYS.QUESTIONS, '');\n            // Import all questions\n            const importedQuestions = this.importAllExistingQuestions();\n            return {\n                success: true,\n                processedCount: importedQuestions.length,\n                errorCount: 0,\n                errors: []\n            };\n        } catch (error) {\n            return {\n                success: false,\n                processedCount: 0,\n                errorCount: 1,\n                errors: [\n                    error instanceof Error ? error.message : 'Import failed'\n                ]\n            };\n        }\n    }\n    // Backup and restore functionality\n    createBackup() {\n        const backup = {\n            questions: this.getQuestions(),\n            settings: this.getSettings(),\n            drafts: this.getDrafts(),\n            timestamp: Date.now(),\n            version: '1.0'\n        };\n        return JSON.stringify(backup, null, 2);\n    }\n    restoreFromBackup(backupData) {\n        try {\n            const backup = JSON.parse(backupData);\n            if (!backup.questions || !Array.isArray(backup.questions)) {\n                throw new QuizDataError('Invalid backup format: missing questions array', 'INVALID_BACKUP');\n            }\n            // Validate all questions in backup\n            backup.questions.forEach((q, index)=>{\n                try {\n                    this.validateQuestion(q);\n                } catch (error) {\n                    throw new QuizDataError(\"Invalid question at index \".concat(index, \": \").concat(error instanceof Error ? error.message : 'Unknown error'), 'INVALID_BACKUP_QUESTION');\n                }\n            });\n            // Create current backup before restore\n            const currentBackup = this.createBackup();\n            this.safeSetItem(_types_admin__WEBPACK_IMPORTED_MODULE_0__.QUIZ_STORAGE_KEYS.BACKUP, currentBackup);\n            // Restore data\n            this.saveQuestions(backup.questions);\n            if (backup.settings) {\n                this.safeSetItem(_types_admin__WEBPACK_IMPORTED_MODULE_0__.QUIZ_STORAGE_KEYS.SETTINGS, JSON.stringify(backup.settings));\n            }\n            if (backup.drafts) {\n                this.safeSetItem(_types_admin__WEBPACK_IMPORTED_MODULE_0__.QUIZ_STORAGE_KEYS.DRAFTS, JSON.stringify(backup.drafts));\n            }\n            return {\n                success: true,\n                processedCount: backup.questions.length,\n                errorCount: 0,\n                errors: []\n            };\n        } catch (error) {\n            throw new QuizDataError(\"Failed to restore backup: \".concat(error instanceof Error ? error.message : 'Unknown error'), 'RESTORE_FAILED');\n        }\n    }\n    // Auto-save functionality for drafts\n    startAutoSave(draftId, getDraftData) {\n        this.stopAutoSave();\n        this.autoSaveTimer = setInterval(()=>{\n            try {\n                const draftData = getDraftData();\n                if (draftData.question && draftData.question.length > 0) {\n                    const draft = {\n                        id: draftId,\n                        question: draftData.question || '',\n                        options: draftData.options || [\n                            '',\n                            '',\n                            '',\n                            ''\n                        ],\n                        correctAnswer: draftData.correctAnswer || 0,\n                        category: draftData.category || 'facts',\n                        difficulty: draftData.difficulty || 'beginner',\n                        type: draftData.type || 'regular',\n                        funFact: draftData.funFact,\n                        tags: draftData.tags,\n                        lastSaved: Date.now()\n                    };\n                    this.saveDraft(draft);\n                }\n            } catch (error) {\n                console.error('Auto-save failed:', error);\n            }\n        }, VALIDATION_RULES.AUTO_SAVE_INTERVAL);\n    }\n    stopAutoSave() {\n        if (this.autoSaveTimer) {\n            clearInterval(this.autoSaveTimer);\n            this.autoSaveTimer = null;\n        }\n    }\n    // CSV Export functionality\n    exportToCSV(questionsToExport) {\n        const questions = questionsToExport || this.getQuestions();\n        const headers = [\n            'ID',\n            'Question',\n            'Option 1',\n            'Option 2',\n            'Option 3',\n            'Option 4',\n            'Correct Answer (1-4)',\n            'Category',\n            'Difficulty',\n            'Type',\n            'Fun Fact',\n            'Tags',\n            'Created At',\n            'Updated At'\n        ];\n        const csvRows = [\n            headers.join(',')\n        ];\n        questions.forEach((question)=>{\n            var _question_options_, _question_options_1, _question_options_2, _question_options_3;\n            const row = [\n                question.id,\n                '\"'.concat(question.question.replace(/\"/g, '\"\"'), '\"'),\n                '\"'.concat(((_question_options_ = question.options[0]) === null || _question_options_ === void 0 ? void 0 : _question_options_.replace(/\"/g, '\"\"')) || '', '\"'),\n                '\"'.concat(((_question_options_1 = question.options[1]) === null || _question_options_1 === void 0 ? void 0 : _question_options_1.replace(/\"/g, '\"\"')) || '', '\"'),\n                '\"'.concat(((_question_options_2 = question.options[2]) === null || _question_options_2 === void 0 ? void 0 : _question_options_2.replace(/\"/g, '\"\"')) || '', '\"'),\n                '\"'.concat(((_question_options_3 = question.options[3]) === null || _question_options_3 === void 0 ? void 0 : _question_options_3.replace(/\"/g, '\"\"')) || '', '\"'),\n                question.correctAnswer + 1,\n                question.category,\n                question.difficulty,\n                question.type,\n                '\"'.concat((question.funFact || '').replace(/\"/g, '\"\"'), '\"'),\n                '\"'.concat((question.tags || []).join(';'), '\"'),\n                new Date(question.createdAt).toISOString(),\n                new Date(question.updatedAt).toISOString()\n            ];\n            csvRows.push(row.join(','));\n        });\n        return csvRows.join('\\n');\n    }\n    // Download CSV file\n    downloadCSV() {\n        try {\n            const csvContent = this.exportToCSV();\n            const blob = new Blob([\n                csvContent\n            ], {\n                type: 'text/csv;charset=utf-8;'\n            });\n            const link = document.createElement('a');\n            if (link.download !== undefined) {\n                const url = URL.createObjectURL(blob);\n                link.setAttribute('href', url);\n                link.setAttribute('download', \"techkwiz-questions-\".concat(new Date().toISOString().split('T')[0], \".csv\"));\n                link.style.visibility = 'hidden';\n                document.body.appendChild(link);\n                link.click();\n                document.body.removeChild(link);\n                URL.revokeObjectURL(url);\n            }\n        } catch (error) {\n            throw new QuizDataError('Failed to download CSV file', 'EXPORT_ERROR');\n        }\n    }\n    // Parse CSV content\n    parseCSV(csvContent) {\n        const lines = csvContent.split('\\n').filter((line)=>line.trim());\n        const errors = [];\n        const questions = [];\n        if (lines.length < 2) {\n            errors.push('CSV file must contain at least a header row and one data row');\n            return {\n                questions,\n                errors\n            };\n        }\n        // Skip header row\n        const dataLines = lines.slice(1);\n        dataLines.forEach((line, index)=>{\n            try {\n                const values = this.parseCSVLine(line);\n                if (values.length < 8) {\n                    errors.push(\"Row \".concat(index + 2, \": Insufficient columns (minimum 8 required)\"));\n                    return;\n                }\n                const [id, question, opt1, opt2, opt3, opt4, correctAnswer, category, difficulty, type, funFact, tags, createdAt, updatedAt] = values;\n                // Validate required fields\n                if (!(question === null || question === void 0 ? void 0 : question.trim())) {\n                    errors.push(\"Row \".concat(index + 2, \": Question is required\"));\n                    return;\n                }\n                if (!(opt1 === null || opt1 === void 0 ? void 0 : opt1.trim()) || !(opt2 === null || opt2 === void 0 ? void 0 : opt2.trim()) || !(opt3 === null || opt3 === void 0 ? void 0 : opt3.trim()) || !(opt4 === null || opt4 === void 0 ? void 0 : opt4.trim())) {\n                    errors.push(\"Row \".concat(index + 2, \": All 4 options are required\"));\n                    return;\n                }\n                const correctAnswerNum = parseInt(correctAnswer) - 1 // Convert 1-based to 0-based\n                ;\n                if (isNaN(correctAnswerNum) || correctAnswerNum < 0 || correctAnswerNum > 3) {\n                    errors.push(\"Row \".concat(index + 2, \": Correct answer must be 1, 2, 3, or 4\"));\n                    return;\n                }\n                if (!(category === null || category === void 0 ? void 0 : category.trim())) {\n                    errors.push(\"Row \".concat(index + 2, \": Category is required\"));\n                    return;\n                }\n                if (![\n                    'beginner',\n                    'intermediate',\n                    'advanced'\n                ].includes(difficulty)) {\n                    errors.push(\"Row \".concat(index + 2, \": Difficulty must be 'beginner', 'intermediate', or 'advanced'\"));\n                    return;\n                }\n                if (![\n                    'regular',\n                    'bonus'\n                ].includes(type)) {\n                    errors.push(\"Row \".concat(index + 2, \": Type must be 'regular' or 'bonus'\"));\n                    return;\n                }\n                const questionData = {\n                    id: id || \"imported_\".concat(Date.now(), \"_\").concat(index),\n                    question: question.trim(),\n                    options: [\n                        opt1.trim(),\n                        opt2.trim(),\n                        opt3.trim(),\n                        opt4.trim()\n                    ],\n                    correctAnswer: correctAnswerNum,\n                    category: category.trim(),\n                    difficulty: difficulty,\n                    type: type,\n                    funFact: (funFact === null || funFact === void 0 ? void 0 : funFact.trim()) || undefined,\n                    tags: tags ? tags.split(';').map((tag)=>tag.trim()).filter(Boolean) : [],\n                    createdAt: createdAt ? new Date(createdAt).getTime() : Date.now(),\n                    updatedAt: updatedAt ? new Date(updatedAt).getTime() : Date.now()\n                };\n                questions.push(questionData);\n            } catch (error) {\n                errors.push(\"Row \".concat(index + 2, \": \").concat(error instanceof Error ? error.message : 'Parse error'));\n            }\n        });\n        return {\n            questions,\n            errors\n        };\n    }\n    // Helper to parse CSV line with proper quote handling\n    parseCSVLine(line) {\n        const result = [];\n        let current = '';\n        let inQuotes = false;\n        let i = 0;\n        while(i < line.length){\n            const char = line[i];\n            if (char === '\"') {\n                if (inQuotes && line[i + 1] === '\"') {\n                    // Escaped quote\n                    current += '\"';\n                    i += 2;\n                } else {\n                    // Toggle quote state\n                    inQuotes = !inQuotes;\n                    i++;\n                }\n            } else if (char === ',' && !inQuotes) {\n                // End of field\n                result.push(current);\n                current = '';\n                i++;\n            } else {\n                current += char;\n                i++;\n            }\n        }\n        result.push(current); // Add last field\n        return result;\n    }\n    // Import from CSV\n    importFromCSV(csvContent) {\n        try {\n            const { questions, errors } = this.parseCSV(csvContent);\n            if (errors.length > 0) {\n                return {\n                    success: false,\n                    processedCount: 0,\n                    errorCount: errors.length,\n                    errors\n                };\n            }\n            let successCount = 0;\n            const importErrors = [];\n            questions.forEach((questionData, index)=>{\n                try {\n                    const fullQuestion = {\n                        id: questionData.id,\n                        question: questionData.question,\n                        options: questionData.options,\n                        correctAnswer: questionData.correctAnswer,\n                        category: questionData.category,\n                        difficulty: questionData.difficulty,\n                        type: questionData.type,\n                        funFact: questionData.funFact,\n                        tags: questionData.tags || [],\n                        createdAt: questionData.createdAt,\n                        updatedAt: questionData.updatedAt\n                    };\n                    // Validate the complete question\n                    const validation = this.validateQuestion(fullQuestion);\n                    if (!validation.isValid) {\n                        importErrors.push(\"Question \".concat(index + 1, \": \").concat(validation.errors.join(', ')));\n                        return;\n                    }\n                    this.saveQuestion(fullQuestion);\n                    successCount++;\n                } catch (error) {\n                    importErrors.push(\"Question \".concat(index + 1, \": \").concat(error instanceof Error ? error.message : 'Save error'));\n                }\n            });\n            return {\n                success: importErrors.length === 0,\n                processedCount: successCount,\n                errorCount: importErrors.length,\n                errors: importErrors\n            };\n        } catch (error) {\n            return {\n                success: false,\n                processedCount: 0,\n                errorCount: 1,\n                errors: [\n                    error instanceof Error ? error.message : 'Import failed'\n                ]\n            };\n        }\n    }\n    constructor(){\n        this.autoSaveTimer = null;\n    }\n}\n// Export singleton instance\nconst quizDataManager = QuizDataManager.getInstance();\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy91dGlscy9xdWl6RGF0YU1hbmFnZXIudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQVNzQjtBQUV0QiwwQkFBMEI7QUFDbkIsTUFBTUUsbUJBQW1CO0lBQzlCQyxxQkFBcUI7SUFDckJDLHFCQUFxQjtJQUNyQkMsbUJBQW1CO0lBQ25CQyxtQkFBbUI7SUFDbkJDLGFBQWE7SUFDYkMsYUFBYTtJQUNiQyxxQkFBcUI7SUFDckJDLGVBQWUsSUFBSSxPQUFPO0lBQzFCQyxvQkFBb0IsTUFBTSxhQUFhO0FBQ3pDLEVBQVU7QUFFVixjQUFjO0FBQ1AsTUFBTUMsc0JBQXNCQztJQUNqQyxZQUFZQyxPQUFlLEVBQUUsSUFBbUIsQ0FBRTtRQUNoRCxLQUFLLENBQUNBLGVBRDRCQyxPQUFBQTtRQUVsQyxJQUFJLENBQUNDLElBQUksR0FBRztJQUNkO0FBQ0Y7QUFFQSxnREFBZ0Q7QUFDaEQsTUFBTUM7SUFJSixPQUFPQyxjQUErQjtRQUNwQyxJQUFJLENBQUNELGdCQUFnQkUsUUFBUSxFQUFFO1lBQzdCRixnQkFBZ0JFLFFBQVEsR0FBRyxJQUFJRjtRQUNqQztRQUNBLE9BQU9BLGdCQUFnQkUsUUFBUTtJQUNqQztJQUVBLG1EQUFtRDtJQUMzQ0MsWUFBWUMsR0FBVyxFQUFpQjtRQUM5QyxvQ0FBb0M7UUFDcEMsSUFBSSxLQUE2QixFQUFFLEVBRWxDO1FBRUQsSUFBSTtZQUNGLE9BQU9DLGFBQWFDLE9BQU8sQ0FBQ0Y7UUFDOUIsRUFBRSxPQUFPRyxPQUFPO1lBQ2RDLFFBQVFELEtBQUssQ0FBQyx1Q0FBMkMsT0FBSkgsS0FBSSxNQUFJRztZQUM3RCxPQUFPO1FBQ1Q7SUFDRjtJQUVRRSxZQUFZTCxHQUFXLEVBQUVNLEtBQWEsRUFBVztRQUN2RCxxQ0FBcUM7UUFDckMsSUFBSSxLQUE2QixFQUFFLEVBRWxDO1FBRUQsSUFBSTtZQUNGTCxhQUFhTSxPQUFPLENBQUNQLEtBQUtNO1lBQzFCLE9BQU87UUFDVCxFQUFFLE9BQU9ILE9BQU87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UzZJLGFBQWFsSixNQUFNLEtBQUs7Z0JBQ2pDTSxnQkFBZ0IySTtnQkFDaEIxSSxZQUFZMkksYUFBYWxKLE1BQU07Z0JBQy9CUSxRQUFRMEk7WUFDVjtRQUNGLEVBQUUsT0FBT25NLE9BQU87WUFDZCxPQUFPO2dCQUNMc0QsU0FBUztnQkFDVEMsZ0JBQWdCO2dCQUNoQkMsWUFBWTtnQkFDWkMsUUFBUTtvQkFBQ3pELGlCQUFpQlgsUUFBUVcsTUFBTVYsT0FBTyxHQUFHO2lCQUFnQjtZQUNwRTtRQUNGO0lBQ0Y7O2FBcmhDUTRLLGdCQUF1Qzs7QUFzaENqRDtBQUVBLDRCQUE0QjtBQUNyQixNQUFNcUMsa0JBQWtCOU0sZ0JBQWdCQyxXQUFXLEdBQUUiLCJzb3VyY2VzIjpbIi9Vc2Vycy9qYXNlZW0vRG9jdW1lbnRzL0dpdEh1Yi9UZWNoa3dpei12Ny9mcm9udGVuZC9zcmMvdXRpbHMvcXVpekRhdGFNYW5hZ2VyLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFxuICBRdWl6UXVlc3Rpb24sIFxuICBRdWl6Q2F0ZWdvcnksIFxuICBTZWFyY2hGaWx0ZXJzLCBcbiAgQnVsa09wZXJhdGlvblJlc3VsdCwgXG4gIFF1ZXN0aW9uRHJhZnQsXG4gIFF1aXpNYW5hZ2VtZW50U2V0dGluZ3MsXG4gIFFVSVpfU1RPUkFHRV9LRVlTLFxuICBERUZBVUxUX0NBVEVHT1JJRVMgXG59IGZyb20gJ0AvdHlwZXMvYWRtaW4nXG5cbi8vIERhdGEgdmFsaWRhdGlvbiBzY2hlbWFzXG5leHBvcnQgY29uc3QgVkFMSURBVElPTl9SVUxFUyA9IHtcbiAgUVVFU1RJT05fTUlOX0xFTkdUSDogMTAsXG4gIFFVRVNUSU9OX01BWF9MRU5HVEg6IDUwMCxcbiAgT1BUSU9OX01JTl9MRU5HVEg6IDEsXG4gIE9QVElPTl9NQVhfTEVOR1RIOiAxMDAsXG4gIE1JTl9PUFRJT05TOiA0LFxuICBNQVhfT1BUSU9OUzogNCxcbiAgTUFYX0JVTEtfT1BFUkFUSU9OUzogNTAsXG4gIE1BWF9GSUxFX1NJWkU6IDUgKiAxMDI0ICogMTAyNCwgLy8gNU1CXG4gIEFVVE9fU0FWRV9JTlRFUlZBTDogMzAwMDAgLy8gMzAgc2Vjb25kc1xufSBhcyBjb25zdFxuXG4vLyBFcnJvciB0eXBlc1xuZXhwb3J0IGNsYXNzIFF1aXpEYXRhRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yKG1lc3NhZ2U6IHN0cmluZywgcHVibGljIGNvZGU6IHN0cmluZykge1xuICAgIHN1cGVyKG1lc3NhZ2UpXG4gICAgdGhpcy5uYW1lID0gJ1F1aXpEYXRhRXJyb3InXG4gIH1cbn1cblxuLy8gVXRpbGl0eSBmdW5jdGlvbnMgZm9yIGxvY2FsU3RvcmFnZSBvcGVyYXRpb25zXG5jbGFzcyBRdWl6RGF0YU1hbmFnZXIge1xuICBwcml2YXRlIHN0YXRpYyBpbnN0YW5jZTogUXVpekRhdGFNYW5hZ2VyXG4gIHByaXZhdGUgYXV0b1NhdmVUaW1lcjogTm9kZUpTLlRpbWVvdXQgfCBudWxsID0gbnVsbFxuXG4gIHN0YXRpYyBnZXRJbnN0YW5jZSgpOiBRdWl6RGF0YU1hbmFnZXIge1xuICAgIGlmICghUXVpekRhdGFNYW5hZ2VyLmluc3RhbmNlKSB7XG4gICAgICBRdWl6RGF0YU1hbmFnZXIuaW5zdGFuY2UgPSBuZXcgUXVpekRhdGFNYW5hZ2VyKClcbiAgICB9XG4gICAgcmV0dXJuIFF1aXpEYXRhTWFuYWdlci5pbnN0YW5jZVxuICB9XG5cbiAgLy8gU2FmZSBsb2NhbFN0b3JhZ2Ugb3BlcmF0aW9ucyB3aXRoIGVycm9yIGhhbmRsaW5nXG4gIHByaXZhdGUgc2FmZUdldEl0ZW0oa2V5OiBzdHJpbmcpOiBzdHJpbmcgfCBudWxsIHtcbiAgICAvLyBSZXR1cm4gbnVsbCBpZiBub3Qgb24gY2xpZW50IHNpZGVcbiAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHJldHVybiBudWxsXG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBsb2NhbFN0b3JhZ2UuZ2V0SXRlbShrZXkpXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yIHJlYWRpbmcgZnJvbSBsb2NhbFN0b3JhZ2Uga2V5ICR7a2V5fTpgLCBlcnJvcilcbiAgICAgIHJldHVybiBudWxsXG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBzYWZlU2V0SXRlbShrZXk6IHN0cmluZywgdmFsdWU6IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgIC8vIFJldHVybiBmYWxzZSBpZiBub3Qgb24gY2xpZW50IHNpZGVcbiAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbShrZXksIHZhbHVlKVxuICAgICAgcmV0dXJuIHRydWVcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcihgRXJyb3Igd3JpdGluZyB0byBsb2NhbFN0b3JhZ2Uga2V5ICR7a2V5fTpgLCBlcnJvcilcbiAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIERPTUV4Y2VwdGlvbiAmJiBlcnJvci5jb2RlID09PSAyMikge1xuICAgICAgICB0aHJvdyBuZXcgUXVpekRhdGFFcnJvcignU3RvcmFnZSBxdW90YSBleGNlZWRlZC4gUGxlYXNlIGNsZWFyIHNvbWUgZGF0YS4nLCAnUVVPVEFfRVhDRUVERUQnKVxuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuICB9XG5cbiAgLy8gUXVlc3Rpb24gQ1JVRCBvcGVyYXRpb25zXG4gIGdldFF1ZXN0aW9ucygpOiBRdWl6UXVlc3Rpb25bXSB7XG4gICAgY29uc3QgZGF0YSA9IHRoaXMuc2FmZUdldEl0ZW0oUVVJWl9TVE9SQUdFX0tFWVMuUVVFU1RJT05TKVxuICAgIGlmICghZGF0YSkgcmV0dXJuIHRoaXMuaW5pdGlhbGl6ZVdpdGhTYW1wbGVEYXRhKClcblxuICAgIHRyeSB7XG4gICAgICBjb25zdCBxdWVzdGlvbnMgPSBKU09OLnBhcnNlKGRhdGEpXG4gICAgICByZXR1cm4gQXJyYXkuaXNBcnJheShxdWVzdGlvbnMpID8gcXVlc3Rpb25zIDogW11cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgcGFyc2luZyBxdWVzdGlvbnMgZGF0YTonLCBlcnJvcilcbiAgICAgIHJldHVybiB0aGlzLmluaXRpYWxpemVXaXRoU2FtcGxlRGF0YSgpXG4gICAgfVxuICB9XG5cbiAgLy8gR2V0IHF1ZXN0aW9ucyB3aXRoIGZpbHRlcmluZyBzdXBwb3J0XG4gIGdldEZpbHRlcmVkUXVlc3Rpb25zKGZpbHRlcnM/OiB7XG4gICAgY2F0ZWdvcnk/OiBzdHJpbmdcbiAgICBkaWZmaWN1bHR5PzogJ2JlZ2lubmVyJyB8ICdpbnRlcm1lZGlhdGUnIHwgJ2FkdmFuY2VkJ1xuICAgIHR5cGU/OiAncmVndWxhcicgfCAnYm9udXMnXG4gICAgc2VjdGlvbj86ICdvbmJvYXJkaW5nJyB8ICdob21lcGFnZScgfCAnY2F0ZWdvcnknIHwgJ2dlbmVyYWwnXG4gICAgc3ViY2F0ZWdvcnk/OiBzdHJpbmdcbiAgICB0YWdzPzogc3RyaW5nW11cbiAgfSk6IFF1aXpRdWVzdGlvbltdIHtcbiAgICBjb25zdCBxdWVzdGlvbnMgPSB0aGlzLmdldFF1ZXN0aW9ucygpXG5cbiAgICBpZiAoIWZpbHRlcnMpIHJldHVybiBxdWVzdGlvbnNcblxuICAgIHJldHVybiBxdWVzdGlvbnMuZmlsdGVyKHF1ZXN0aW9uID0+IHtcbiAgICAgIGlmIChmaWx0ZXJzLmNhdGVnb3J5ICYmIHF1ZXN0aW9uLmNhdGVnb3J5ICE9PSBmaWx0ZXJzLmNhdGVnb3J5KSByZXR1cm4gZmFsc2VcbiAgICAgIGlmIChmaWx0ZXJzLmRpZmZpY3VsdHkgJiYgcXVlc3Rpb24uZGlmZmljdWx0eSAhPT0gZmlsdGVycy5kaWZmaWN1bHR5KSByZXR1cm4gZmFsc2VcbiAgICAgIGlmIChmaWx0ZXJzLnR5cGUgJiYgcXVlc3Rpb24udHlwZSAhPT0gZmlsdGVycy50eXBlKSByZXR1cm4gZmFsc2VcbiAgICAgIGlmIChmaWx0ZXJzLnNlY3Rpb24gJiYgcXVlc3Rpb24uc2VjdGlvbiAhPT0gZmlsdGVycy5zZWN0aW9uKSByZXR1cm4gZmFsc2VcbiAgICAgIGlmIChmaWx0ZXJzLnN1YmNhdGVnb3J5ICYmIHF1ZXN0aW9uLnN1YmNhdGVnb3J5ICE9PSBmaWx0ZXJzLnN1YmNhdGVnb3J5KSByZXR1cm4gZmFsc2VcbiAgICAgIGlmIChmaWx0ZXJzLnRhZ3MgJiYgIWZpbHRlcnMudGFncy5zb21lKHRhZyA9PiBxdWVzdGlvbi50YWdzPy5pbmNsdWRlcyh0YWcpKSkgcmV0dXJuIGZhbHNlXG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH0pXG4gIH1cblxuICAvLyBHZXQgcXVlc3Rpb25zIGJ5IHNlY3Rpb25cbiAgZ2V0UXVlc3Rpb25zQnlTZWN0aW9uKHNlY3Rpb246ICdvbmJvYXJkaW5nJyB8ICdob21lcGFnZScgfCAnY2F0ZWdvcnknIHwgJ2dlbmVyYWwnKTogUXVpelF1ZXN0aW9uW10ge1xuICAgIHJldHVybiB0aGlzLmdldEZpbHRlcmVkUXVlc3Rpb25zKHsgc2VjdGlvbiB9KVxuICB9XG5cbiAgLy8gR2V0IHF1ZXN0aW9ucyBieSBjYXRlZ29yeSBhbmQgc2VjdGlvblxuICBnZXRRdWVzdGlvbnNCeUNhdGVnb3J5QW5kU2VjdGlvbihjYXRlZ29yeTogc3RyaW5nLCBzZWN0aW9uPzogJ29uYm9hcmRpbmcnIHwgJ2hvbWVwYWdlJyB8ICdjYXRlZ29yeScgfCAnZ2VuZXJhbCcpOiBRdWl6UXVlc3Rpb25bXSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0RmlsdGVyZWRRdWVzdGlvbnMoeyBjYXRlZ29yeSwgc2VjdGlvbiB9KVxuICB9XG5cbiAgc2F2ZVF1ZXN0aW9uKHF1ZXN0aW9uOiBPbWl0PFF1aXpRdWVzdGlvbiwgJ2lkJyB8ICdjcmVhdGVkQXQnIHwgJ3VwZGF0ZWRBdCc+KTogUXVpelF1ZXN0aW9uIHtcbiAgICB0aGlzLnZhbGlkYXRlUXVlc3Rpb24ocXVlc3Rpb24pXG4gICAgXG4gICAgY29uc3QgcXVlc3Rpb25zID0gdGhpcy5nZXRRdWVzdGlvbnMoKVxuICAgIGNvbnN0IG5vdyA9IERhdGUubm93KClcbiAgICBjb25zdCBuZXdRdWVzdGlvbjogUXVpelF1ZXN0aW9uID0ge1xuICAgICAgLi4ucXVlc3Rpb24sXG4gICAgICBpZDogdGhpcy5nZW5lcmF0ZUlkKCksXG4gICAgICBjcmVhdGVkQXQ6IG5vdyxcbiAgICAgIHVwZGF0ZWRBdDogbm93XG4gICAgfVxuICAgIFxuICAgIHF1ZXN0aW9ucy5wdXNoKG5ld1F1ZXN0aW9uKVxuICAgIHRoaXMuc2F2ZVF1ZXN0aW9ucyhxdWVzdGlvbnMpXG4gICAgcmV0dXJuIG5ld1F1ZXN0aW9uXG4gIH1cblxuICB1cGRhdGVRdWVzdGlvbihpZDogc3RyaW5nLCB1cGRhdGVzOiBQYXJ0aWFsPE9taXQ8UXVpelF1ZXN0aW9uLCAnaWQnIHwgJ2NyZWF0ZWRBdCc+Pik6IFF1aXpRdWVzdGlvbiB7XG4gICAgY29uc3QgcXVlc3Rpb25zID0gdGhpcy5nZXRRdWVzdGlvbnMoKVxuICAgIGNvbnN0IGluZGV4ID0gcXVlc3Rpb25zLmZpbmRJbmRleChxID0+IHEuaWQgPT09IGlkKVxuICAgIFxuICAgIGlmIChpbmRleCA9PT0gLTEpIHtcbiAgICAgIHRocm93IG5ldyBRdWl6RGF0YUVycm9yKGBRdWVzdGlvbiB3aXRoIGlkICR7aWR9IG5vdCBmb3VuZGAsICdOT1RfRk9VTkQnKVxuICAgIH1cbiAgICBcbiAgICBjb25zdCB1cGRhdGVkUXVlc3Rpb24gPSB7XG4gICAgICAuLi5xdWVzdGlvbnNbaW5kZXhdLFxuICAgICAgLi4udXBkYXRlcyxcbiAgICAgIHVwZGF0ZWRBdDogRGF0ZS5ub3coKVxuICAgIH1cbiAgICBcbiAgICB0aGlzLnZhbGlkYXRlUXVlc3Rpb24odXBkYXRlZFF1ZXN0aW9uKVxuICAgIHF1ZXN0aW9uc1tpbmRleF0gPSB1cGRhdGVkUXVlc3Rpb25cbiAgICB0aGlzLnNhdmVRdWVzdGlvbnMocXVlc3Rpb25zKVxuICAgIHJldHVybiB1cGRhdGVkUXVlc3Rpb25cbiAgfVxuXG4gIGRlbGV0ZVF1ZXN0aW9uKGlkOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgICBjb25zdCBxdWVzdGlvbnMgPSB0aGlzLmdldFF1ZXN0aW9ucygpXG4gICAgY29uc3QgZmlsdGVyZWRRdWVzdGlvbnMgPSBxdWVzdGlvbnMuZmlsdGVyKHEgPT4gcS5pZCAhPT0gaWQpXG4gICAgXG4gICAgaWYgKGZpbHRlcmVkUXVlc3Rpb25zLmxlbmd0aCA9PT0gcXVlc3Rpb25zLmxlbmd0aCkge1xuICAgICAgdGhyb3cgbmV3IFF1aXpEYXRhRXJyb3IoYFF1ZXN0aW9uIHdpdGggaWQgJHtpZH0gbm90IGZvdW5kYCwgJ05PVF9GT1VORCcpXG4gICAgfVxuICAgIFxuICAgIHRoaXMuc2F2ZVF1ZXN0aW9ucyhmaWx0ZXJlZFF1ZXN0aW9ucylcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgYnVsa0RlbGV0ZShpZHM6IHN0cmluZ1tdKTogQnVsa09wZXJhdGlvblJlc3VsdCB7XG4gICAgaWYgKGlkcy5sZW5ndGggPiBWQUxJREFUSU9OX1JVTEVTLk1BWF9CVUxLX09QRVJBVElPTlMpIHtcbiAgICAgIHRocm93IG5ldyBRdWl6RGF0YUVycm9yKFxuICAgICAgICBgQ2Fubm90IGRlbGV0ZSBtb3JlIHRoYW4gJHtWQUxJREFUSU9OX1JVTEVTLk1BWF9CVUxLX09QRVJBVElPTlN9IHF1ZXN0aW9ucyBhdCBvbmNlYCxcbiAgICAgICAgJ0JVTEtfTElNSVRfRVhDRUVERUQnXG4gICAgICApXG4gICAgfVxuXG4gICAgY29uc3QgcXVlc3Rpb25zID0gdGhpcy5nZXRRdWVzdGlvbnMoKVxuICAgIGNvbnN0IGluaXRpYWxDb3VudCA9IHF1ZXN0aW9ucy5sZW5ndGhcbiAgICBjb25zdCBmaWx0ZXJlZFF1ZXN0aW9ucyA9IHF1ZXN0aW9ucy5maWx0ZXIocSA9PiAhaWRzLmluY2x1ZGVzKHEuaWQpKVxuICAgIGNvbnN0IGRlbGV0ZWRDb3VudCA9IGluaXRpYWxDb3VudCAtIGZpbHRlcmVkUXVlc3Rpb25zLmxlbmd0aFxuICAgIFxuICAgIHRoaXMuc2F2ZVF1ZXN0aW9ucyhmaWx0ZXJlZFF1ZXN0aW9ucylcbiAgICBcbiAgICByZXR1cm4ge1xuICAgICAgc3VjY2VzczogdHJ1ZSxcbiAgICAgIHByb2Nlc3NlZENvdW50OiBkZWxldGVkQ291bnQsXG4gICAgICBlcnJvckNvdW50OiBpZHMubGVuZ3RoIC0gZGVsZXRlZENvdW50LFxuICAgICAgZXJyb3JzOiBpZHMubGVuZ3RoID4gZGVsZXRlZENvdW50ID8gWydTb21lIHF1ZXN0aW9ucyB3ZXJlIG5vdCBmb3VuZCddIDogW11cbiAgICB9XG4gIH1cblxuICAvLyBTZWFyY2ggYW5kIGZpbHRlciBvcGVyYXRpb25zXG4gIHNlYXJjaFF1ZXN0aW9ucyhmaWx0ZXJzOiBTZWFyY2hGaWx0ZXJzKTogUXVpelF1ZXN0aW9uW10ge1xuICAgIGNvbnN0IHF1ZXN0aW9ucyA9IHRoaXMuZ2V0UXVlc3Rpb25zKClcbiAgICBcbiAgICByZXR1cm4gcXVlc3Rpb25zLmZpbHRlcihxdWVzdGlvbiA9PiB7XG4gICAgICAvLyBUZXh0IHNlYXJjaFxuICAgICAgaWYgKGZpbHRlcnMuc2VhcmNoVGV4dCkge1xuICAgICAgICBjb25zdCBzZWFyY2hMb3dlciA9IGZpbHRlcnMuc2VhcmNoVGV4dC50b0xvd2VyQ2FzZSgpXG4gICAgICAgIGlmICghcXVlc3Rpb24ucXVlc3Rpb24udG9Mb3dlckNhc2UoKS5pbmNsdWRlcyhzZWFyY2hMb3dlcikpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBDYXRlZ29yeSBmaWx0ZXJcbiAgICAgIGlmIChmaWx0ZXJzLmNhdGVnb3J5ICE9PSAnYWxsJyAmJiBxdWVzdGlvbi5jYXRlZ29yeSAhPT0gZmlsdGVycy5jYXRlZ29yeSkge1xuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gRGlmZmljdWx0eSBmaWx0ZXJcbiAgICAgIGlmIChmaWx0ZXJzLmRpZmZpY3VsdHkgIT09ICdhbGwnICYmIHF1ZXN0aW9uLmRpZmZpY3VsdHkgIT09IGZpbHRlcnMuZGlmZmljdWx0eSkge1xuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gVHlwZSBmaWx0ZXJcbiAgICAgIGlmIChmaWx0ZXJzLnR5cGUgIT09ICdhbGwnICYmIHF1ZXN0aW9uLnR5cGUgIT09IGZpbHRlcnMudHlwZSkge1xuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cbiAgICAgIFxuICAgICAgcmV0dXJuIHRydWVcbiAgICB9KVxuICB9XG5cbiAgLy8gQ2F0ZWdvcmllcyBtYW5hZ2VtZW50XG4gIGdldENhdGVnb3JpZXMoKTogUXVpekNhdGVnb3J5W10ge1xuICAgIGNvbnN0IHF1ZXN0aW9ucyA9IHRoaXMuZ2V0UXVlc3Rpb25zKClcbiAgICBjb25zdCBjYXRlZ29yeUNvdW50cyA9IHF1ZXN0aW9ucy5yZWR1Y2UoKGFjYywgcXVlc3Rpb24pID0+IHtcbiAgICAgIGFjY1txdWVzdGlvbi5jYXRlZ29yeV0gPSAoYWNjW3F1ZXN0aW9uLmNhdGVnb3J5XSB8fCAwKSArIDFcbiAgICAgIHJldHVybiBhY2NcbiAgICB9LCB7fSBhcyBSZWNvcmQ8c3RyaW5nLCBudW1iZXI+KVxuICAgIFxuICAgIHJldHVybiBERUZBVUxUX0NBVEVHT1JJRVMubWFwKGNhdGVnb3J5ID0+ICh7XG4gICAgICAuLi5jYXRlZ29yeSxcbiAgICAgIHF1ZXN0aW9uQ291bnQ6IGNhdGVnb3J5Q291bnRzW2NhdGVnb3J5LmlkXSB8fCAwXG4gICAgfSkpXG4gIH1cblxuICAvLyBEcmFmdCBtYW5hZ2VtZW50XG4gIHNhdmVEcmFmdChkcmFmdDogUXVlc3Rpb25EcmFmdCk6IHZvaWQge1xuICAgIGNvbnN0IGRyYWZ0cyA9IHRoaXMuZ2V0RHJhZnRzKClcbiAgICBjb25zdCBleGlzdGluZ0luZGV4ID0gZHJhZnRzLmZpbmRJbmRleChkID0+IGQuaWQgPT09IGRyYWZ0LmlkKVxuICAgIFxuICAgIGlmIChleGlzdGluZ0luZGV4ID49IDApIHtcbiAgICAgIGRyYWZ0c1tleGlzdGluZ0luZGV4XSA9IHsgLi4uZHJhZnQsIGxhc3RTYXZlZDogRGF0ZS5ub3coKSB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGRyYWZ0cy5wdXNoKHsgLi4uZHJhZnQsIGxhc3RTYXZlZDogRGF0ZS5ub3coKSB9KVxuICAgIH1cbiAgICBcbiAgICB0aGlzLnNhZmVTZXRJdGVtKFFVSVpfU1RPUkFHRV9LRVlTLkRSQUZUUywgSlNPTi5zdHJpbmdpZnkoZHJhZnRzKSlcbiAgfVxuXG4gIGdldERyYWZ0cygpOiBRdWVzdGlvbkRyYWZ0W10ge1xuICAgIGNvbnN0IGRhdGEgPSB0aGlzLnNhZmVHZXRJdGVtKFFVSVpfU1RPUkFHRV9LRVlTLkRSQUZUUylcbiAgICBpZiAoIWRhdGEpIHJldHVybiBbXVxuICAgIFxuICAgIHRyeSB7XG4gICAgICByZXR1cm4gSlNPTi5wYXJzZShkYXRhKVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBwYXJzaW5nIGRyYWZ0cyBkYXRhOicsIGVycm9yKVxuICAgICAgcmV0dXJuIFtdXG4gICAgfVxuICB9XG5cbiAgZGVsZXRlRHJhZnQoaWQ6IHN0cmluZyk6IHZvaWQge1xuICAgIGNvbnN0IGRyYWZ0cyA9IHRoaXMuZ2V0RHJhZnRzKCkuZmlsdGVyKGQgPT4gZC5pZCAhPT0gaWQpXG4gICAgdGhpcy5zYWZlU2V0SXRlbShRVUlaX1NUT1JBR0VfS0VZUy5EUkFGVFMsIEpTT04uc3RyaW5naWZ5KGRyYWZ0cykpXG4gIH1cblxuICAvLyBTZXR0aW5ncyBtYW5hZ2VtZW50XG4gIGdldFNldHRpbmdzKCk6IFF1aXpNYW5hZ2VtZW50U2V0dGluZ3Mge1xuICAgIGNvbnN0IGRhdGEgPSB0aGlzLnNhZmVHZXRJdGVtKFFVSVpfU1RPUkFHRV9LRVlTLlNFVFRJTkdTKVxuICAgIGlmICghZGF0YSkgcmV0dXJuIHRoaXMuZ2V0RGVmYXVsdFNldHRpbmdzKClcbiAgICBcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIHsgLi4udGhpcy5nZXREZWZhdWx0U2V0dGluZ3MoKSwgLi4uSlNPTi5wYXJzZShkYXRhKSB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIHBhcnNpbmcgc2V0dGluZ3MgZGF0YTonLCBlcnJvcilcbiAgICAgIHJldHVybiB0aGlzLmdldERlZmF1bHRTZXR0aW5ncygpXG4gICAgfVxuICB9XG5cbiAgc2F2ZVNldHRpbmdzKHNldHRpbmdzOiBQYXJ0aWFsPFF1aXpNYW5hZ2VtZW50U2V0dGluZ3M+KTogdm9pZCB7XG4gICAgY29uc3QgY3VycmVudFNldHRpbmdzID0gdGhpcy5nZXRTZXR0aW5ncygpXG4gICAgY29uc3QgdXBkYXRlZFNldHRpbmdzID0geyAuLi5jdXJyZW50U2V0dGluZ3MsIC4uLnNldHRpbmdzIH1cbiAgICB0aGlzLnNhZmVTZXRJdGVtKFFVSVpfU1RPUkFHRV9LRVlTLlNFVFRJTkdTLCBKU09OLnN0cmluZ2lmeSh1cGRhdGVkU2V0dGluZ3MpKVxuICB9XG5cbiAgcHJpdmF0ZSBnZXREZWZhdWx0U2V0dGluZ3MoKTogUXVpek1hbmFnZW1lbnRTZXR0aW5ncyB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHBhZ2VTaXplOiAxMCxcbiAgICAgIHNvcnRCeTogJ3VwZGF0ZWRBdCcsXG4gICAgICBzb3J0T3JkZXI6ICdkZXNjJyxcbiAgICAgIGZpbHRlcnM6IHtcbiAgICAgICAgc2VhcmNoVGV4dDogJycsXG4gICAgICAgIGNhdGVnb3J5OiAnYWxsJyxcbiAgICAgICAgZGlmZmljdWx0eTogJ2FsbCcsXG4gICAgICAgIHR5cGU6ICdhbGwnXG4gICAgICB9LFxuICAgICAgc2VsZWN0ZWRRdWVzdGlvbnM6IFtdXG4gICAgfVxuICB9XG5cbiAgLy8gVmFsaWRhdGlvblxuICBwcml2YXRlIHZhbGlkYXRlUXVlc3Rpb24ocXVlc3Rpb246IFBhcnRpYWw8UXVpelF1ZXN0aW9uPik6IHZvaWQge1xuICAgIGlmICghcXVlc3Rpb24ucXVlc3Rpb24gfHwgcXVlc3Rpb24ucXVlc3Rpb24ubGVuZ3RoIDwgVkFMSURBVElPTl9SVUxFUy5RVUVTVElPTl9NSU5fTEVOR1RIKSB7XG4gICAgICB0aHJvdyBuZXcgUXVpekRhdGFFcnJvcihcbiAgICAgICAgYFF1ZXN0aW9uIG11c3QgYmUgYXQgbGVhc3QgJHtWQUxJREFUSU9OX1JVTEVTLlFVRVNUSU9OX01JTl9MRU5HVEh9IGNoYXJhY3RlcnMgbG9uZ2AsXG4gICAgICAgICdJTlZBTElEX1FVRVNUSU9OX0xFTkdUSCdcbiAgICAgIClcbiAgICB9XG4gICAgXG4gICAgaWYgKHF1ZXN0aW9uLnF1ZXN0aW9uLmxlbmd0aCA+IFZBTElEQVRJT05fUlVMRVMuUVVFU1RJT05fTUFYX0xFTkdUSCkge1xuICAgICAgdGhyb3cgbmV3IFF1aXpEYXRhRXJyb3IoXG4gICAgICAgIGBRdWVzdGlvbiBtdXN0IGJlIG5vIG1vcmUgdGhhbiAke1ZBTElEQVRJT05fUlVMRVMuUVVFU1RJT05fTUFYX0xFTkdUSH0gY2hhcmFjdGVycyBsb25nYCxcbiAgICAgICAgJ0lOVkFMSURfUVVFU1RJT05fTEVOR1RIJ1xuICAgICAgKVxuICAgIH1cbiAgICBcbiAgICBpZiAoIXF1ZXN0aW9uLm9wdGlvbnMgfHwgcXVlc3Rpb24ub3B0aW9ucy5sZW5ndGggIT09IFZBTElEQVRJT05fUlVMRVMuTUlOX09QVElPTlMpIHtcbiAgICAgIHRocm93IG5ldyBRdWl6RGF0YUVycm9yKFxuICAgICAgICBgUXVlc3Rpb24gbXVzdCBoYXZlIGV4YWN0bHkgJHtWQUxJREFUSU9OX1JVTEVTLk1JTl9PUFRJT05TfSBvcHRpb25zYCxcbiAgICAgICAgJ0lOVkFMSURfT1BUSU9OU19DT1VOVCdcbiAgICAgIClcbiAgICB9XG4gICAgXG4gICAgLy8gVmFsaWRhdGUgZWFjaCBvcHRpb25cbiAgICBxdWVzdGlvbi5vcHRpb25zLmZvckVhY2goKG9wdGlvbiwgaW5kZXgpID0+IHtcbiAgICAgIGlmICghb3B0aW9uIHx8IG9wdGlvbi5sZW5ndGggPCBWQUxJREFUSU9OX1JVTEVTLk9QVElPTl9NSU5fTEVOR1RIKSB7XG4gICAgICAgIHRocm93IG5ldyBRdWl6RGF0YUVycm9yKFxuICAgICAgICAgIGBPcHRpb24gJHtpbmRleCArIDF9IG11c3QgYmUgYXQgbGVhc3QgJHtWQUxJREFUSU9OX1JVTEVTLk9QVElPTl9NSU5fTEVOR1RIfSBjaGFyYWN0ZXIgbG9uZ2AsXG4gICAgICAgICAgJ0lOVkFMSURfT1BUSU9OX0xFTkdUSCdcbiAgICAgICAgKVxuICAgICAgfVxuICAgICAgXG4gICAgICBpZiAob3B0aW9uLmxlbmd0aCA+IFZBTElEQVRJT05fUlVMRVMuT1BUSU9OX01BWF9MRU5HVEgpIHtcbiAgICAgICAgdGhyb3cgbmV3IFF1aXpEYXRhRXJyb3IoXG4gICAgICAgICAgYE9wdGlvbiAke2luZGV4ICsgMX0gbXVzdCBiZSBubyBtb3JlIHRoYW4gJHtWQUxJREFUSU9OX1JVTEVTLk9QVElPTl9NQVhfTEVOR1RIfSBjaGFyYWN0ZXJzIGxvbmdgLFxuICAgICAgICAgICdJTlZBTElEX09QVElPTl9MRU5HVEgnXG4gICAgICAgIClcbiAgICAgIH1cbiAgICB9KVxuICAgIFxuICAgIC8vIENoZWNrIGZvciBkdXBsaWNhdGUgb3B0aW9uc1xuICAgIGNvbnN0IHVuaXF1ZU9wdGlvbnMgPSBuZXcgU2V0KHF1ZXN0aW9uLm9wdGlvbnMubWFwKG9wdCA9PiBvcHQudG9Mb3dlckNhc2UoKS50cmltKCkpKVxuICAgIGlmICh1bmlxdWVPcHRpb25zLnNpemUgIT09IHF1ZXN0aW9uLm9wdGlvbnMubGVuZ3RoKSB7XG4gICAgICB0aHJvdyBuZXcgUXVpekRhdGFFcnJvcignQWxsIG9wdGlvbnMgbXVzdCBiZSB1bmlxdWUnLCAnRFVQTElDQVRFX09QVElPTlMnKVxuICAgIH1cbiAgICBcbiAgICAvLyBWYWxpZGF0ZSBjb3JyZWN0IGFuc3dlclxuICAgIGlmICh0eXBlb2YgcXVlc3Rpb24uY29ycmVjdEFuc3dlciAhPT0gJ251bWJlcicgfHwgXG4gICAgICAgIHF1ZXN0aW9uLmNvcnJlY3RBbnN3ZXIgPCAwIHx8IFxuICAgICAgICBxdWVzdGlvbi5jb3JyZWN0QW5zd2VyID49IHF1ZXN0aW9uLm9wdGlvbnMubGVuZ3RoKSB7XG4gICAgICB0aHJvdyBuZXcgUXVpekRhdGFFcnJvcignSW52YWxpZCBjb3JyZWN0IGFuc3dlciBzZWxlY3Rpb24nLCAnSU5WQUxJRF9DT1JSRUNUX0FOU1dFUicpXG4gICAgfVxuICAgIFxuICAgIC8vIFZhbGlkYXRlIGNhdGVnb3J5XG4gICAgY29uc3QgdmFsaWRDYXRlZ29yaWVzID0gREVGQVVMVF9DQVRFR09SSUVTLm1hcChjID0+IGMuaWQpXG4gICAgaWYgKCFxdWVzdGlvbi5jYXRlZ29yeSB8fCAhdmFsaWRDYXRlZ29yaWVzLmluY2x1ZGVzKHF1ZXN0aW9uLmNhdGVnb3J5KSkge1xuICAgICAgdGhyb3cgbmV3IFF1aXpEYXRhRXJyb3IoJ0ludmFsaWQgY2F0ZWdvcnkgc2VsZWN0aW9uJywgJ0lOVkFMSURfQ0FURUdPUlknKVxuICAgIH1cbiAgfVxuXG4gIC8vIFV0aWxpdHkgbWV0aG9kc1xuICBwcml2YXRlIHNhdmVRdWVzdGlvbnMocXVlc3Rpb25zOiBRdWl6UXVlc3Rpb25bXSk6IHZvaWQge1xuICAgIHRoaXMuc2FmZVNldEl0ZW0oUVVJWl9TVE9SQUdFX0tFWVMuUVVFU1RJT05TLCBKU09OLnN0cmluZ2lmeShxdWVzdGlvbnMpKVxuICB9XG5cbiAgcHJpdmF0ZSBnZW5lcmF0ZUlkKCk6IHN0cmluZyB7XG4gICAgcmV0dXJuIGBxXyR7RGF0ZS5ub3coKX1fJHtNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zdWJzdHIoMiwgOSl9YFxuICB9XG5cbiAgLy8gQ1NWIEV4cG9ydC9JbXBvcnQgZnVuY3Rpb25hbGl0eVxuICBleHBvcnRUb0NTVihxdWVzdGlvbnM/OiBRdWl6UXVlc3Rpb25bXSk6IHN0cmluZyB7XG4gICAgY29uc3QgcXVlc3Rpb25zVG9FeHBvcnQgPSBxdWVzdGlvbnMgfHwgdGhpcy5nZXRRdWVzdGlvbnMoKVxuXG4gICAgY29uc3QgaGVhZGVycyA9IFtcbiAgICAgICdJRCcsICdRdWVzdGlvbicsICdPcHRpb24gMScsICdPcHRpb24gMicsICdPcHRpb24gMycsICdPcHRpb24gNCcsXG4gICAgICAnQ29ycmVjdCBBbnN3ZXInLCAnQ2F0ZWdvcnknLCAnRGlmZmljdWx0eScsICdUeXBlJywgJ0Z1biBGYWN0JywgJ1RhZ3MnLFxuICAgICAgJ0NyZWF0ZWQgQXQnLCAnVXBkYXRlZCBBdCdcbiAgICBdXG5cbiAgICBjb25zdCBjc3ZSb3dzID0gW1xuICAgICAgaGVhZGVycy5qb2luKCcsJyksXG4gICAgICAuLi5xdWVzdGlvbnNUb0V4cG9ydC5tYXAocSA9PiBbXG4gICAgICAgIHEuaWQsXG4gICAgICAgIGBcIiR7cS5xdWVzdGlvbi5yZXBsYWNlKC9cIi9nLCAnXCJcIicpfVwiYCxcbiAgICAgICAgYFwiJHtxLm9wdGlvbnNbMF0ucmVwbGFjZSgvXCIvZywgJ1wiXCInKX1cImAsXG4gICAgICAgIGBcIiR7cS5vcHRpb25zWzFdLnJlcGxhY2UoL1wiL2csICdcIlwiJyl9XCJgLFxuICAgICAgICBgXCIke3Eub3B0aW9uc1syXS5yZXBsYWNlKC9cIi9nLCAnXCJcIicpfVwiYCxcbiAgICAgICAgYFwiJHtxLm9wdGlvbnNbM10ucmVwbGFjZSgvXCIvZywgJ1wiXCInKX1cImAsXG4gICAgICAgIHEuY29ycmVjdEFuc3dlciArIDEsIC8vIDEtYmFzZWQgZm9yIGh1bWFuIHJlYWRhYmlsaXR5XG4gICAgICAgIHEuY2F0ZWdvcnksXG4gICAgICAgIHEuZGlmZmljdWx0eSxcbiAgICAgICAgcS50eXBlLFxuICAgICAgICBgXCIkeyhxLmZ1bkZhY3QgfHwgJycpLnJlcGxhY2UoL1wiL2csICdcIlwiJyl9XCJgLFxuICAgICAgICBgXCIkeyhxLnRhZ3MgfHwgW10pLmpvaW4oJzsnKX1cImAsXG4gICAgICAgIG5ldyBEYXRlKHEuY3JlYXRlZEF0KS50b0lTT1N0cmluZygpLFxuICAgICAgICBuZXcgRGF0ZShxLnVwZGF0ZWRBdCkudG9JU09TdHJpbmcoKVxuICAgICAgXS5qb2luKCcsJykpXG4gICAgXVxuXG4gICAgLy8gQWRkIFVURi04IEJPTSBmb3IgRXhjZWwgY29tcGF0aWJpbGl0eVxuICAgIHJldHVybiAnXFx1RkVGRicgKyBjc3ZSb3dzLmpvaW4oJ1xcbicpXG4gIH1cblxuICBhc3luYyBpbXBvcnRGcm9tQ1NWKGNzdkNvbnRlbnQ6IHN0cmluZyk6IFByb21pc2U8QnVsa09wZXJhdGlvblJlc3VsdD4ge1xuICAgIGNvbnN0IGxpbmVzID0gY3N2Q29udGVudC5zcGxpdCgnXFxuJykuZmlsdGVyKGxpbmUgPT4gbGluZS50cmltKCkpXG4gICAgaWYgKGxpbmVzLmxlbmd0aCA8IDIpIHtcbiAgICAgIHRocm93IG5ldyBRdWl6RGF0YUVycm9yKCdDU1YgZmlsZSBtdXN0IGNvbnRhaW4gYXQgbGVhc3QgYSBoZWFkZXIgYW5kIG9uZSBkYXRhIHJvdycsICdJTlZBTElEX0NTVl9GT1JNQVQnKVxuICAgIH1cblxuICAgIGNvbnN0IGhlYWRlcnMgPSBsaW5lc1swXS5zcGxpdCgnLCcpLm1hcChoID0+IGgudHJpbSgpLnJlcGxhY2UoL1wiL2csICcnKSlcbiAgICBjb25zdCBkYXRhTGluZXMgPSBsaW5lcy5zbGljZSgxKVxuXG4gICAgY29uc3QgcmVzdWx0czogQnVsa09wZXJhdGlvblJlc3VsdCA9IHtcbiAgICAgIHN1Y2Nlc3M6IHRydWUsXG4gICAgICBwcm9jZXNzZWRDb3VudDogMCxcbiAgICAgIGVycm9yQ291bnQ6IDAsXG4gICAgICBlcnJvcnM6IFtdXG4gICAgfVxuXG4gICAgY29uc3QgdmFsaWRRdWVzdGlvbnM6IFF1aXpRdWVzdGlvbltdID0gW11cbiAgICBjb25zdCBleGlzdGluZ1F1ZXN0aW9ucyA9IHRoaXMuZ2V0UXVlc3Rpb25zKClcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGF0YUxpbmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCB2YWx1ZXMgPSB0aGlzLnBhcnNlQ1NWTGluZShkYXRhTGluZXNbaV0pXG4gICAgICAgIGlmICh2YWx1ZXMubGVuZ3RoIDwgOCkge1xuICAgICAgICAgIHJlc3VsdHMuZXJyb3JzLnB1c2goYExpbmUgJHtpICsgMn06IEluc3VmZmljaWVudCBkYXRhIGNvbHVtbnNgKVxuICAgICAgICAgIHJlc3VsdHMuZXJyb3JDb3VudCsrXG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHF1ZXN0aW9uOiBRdWl6UXVlc3Rpb24gPSB7XG4gICAgICAgICAgaWQ6IHZhbHVlc1swXSB8fCB0aGlzLmdlbmVyYXRlSWQoKSxcbiAgICAgICAgICBxdWVzdGlvbjogdmFsdWVzWzFdLFxuICAgICAgICAgIG9wdGlvbnM6IFt2YWx1ZXNbMl0sIHZhbHVlc1szXSwgdmFsdWVzWzRdLCB2YWx1ZXNbNV1dLFxuICAgICAgICAgIGNvcnJlY3RBbnN3ZXI6IHBhcnNlSW50KHZhbHVlc1s2XSkgLSAxLCAvLyBDb252ZXJ0IGJhY2sgdG8gMC1iYXNlZFxuICAgICAgICAgIGNhdGVnb3J5OiB2YWx1ZXNbN10sXG4gICAgICAgICAgZGlmZmljdWx0eTogdmFsdWVzWzhdIGFzICdiZWdpbm5lcicgfCAnaW50ZXJtZWRpYXRlJyB8ICdhZHZhbmNlZCcsXG4gICAgICAgICAgdHlwZTogKHZhbHVlc1s5XSB8fCAncmVndWxhcicpIGFzICdyZWd1bGFyJyB8ICdib251cycsXG4gICAgICAgICAgZnVuRmFjdDogdmFsdWVzWzEwXSB8fCB1bmRlZmluZWQsXG4gICAgICAgICAgdGFnczogdmFsdWVzWzExXSA/IHZhbHVlc1sxMV0uc3BsaXQoJzsnKS5maWx0ZXIodCA9PiB0LnRyaW0oKSkgOiB1bmRlZmluZWQsXG4gICAgICAgICAgY3JlYXRlZEF0OiB2YWx1ZXNbMTJdID8gbmV3IERhdGUodmFsdWVzWzEyXSkuZ2V0VGltZSgpIDogRGF0ZS5ub3coKSxcbiAgICAgICAgICB1cGRhdGVkQXQ6IHZhbHVlc1sxM10gPyBuZXcgRGF0ZSh2YWx1ZXNbMTNdKS5nZXRUaW1lKCkgOiBEYXRlLm5vdygpXG4gICAgICAgIH1cblxuICAgICAgICAvLyBWYWxpZGF0ZSB0aGUgcXVlc3Rpb25cbiAgICAgICAgdGhpcy52YWxpZGF0ZVF1ZXN0aW9uKHF1ZXN0aW9uKVxuXG4gICAgICAgIC8vIENoZWNrIGZvciBkdXBsaWNhdGVzXG4gICAgICAgIGNvbnN0IGV4aXN0aW5nSW5kZXggPSBleGlzdGluZ1F1ZXN0aW9ucy5maW5kSW5kZXgocSA9PiBxLmlkID09PSBxdWVzdGlvbi5pZClcbiAgICAgICAgaWYgKGV4aXN0aW5nSW5kZXggPj0gMCkge1xuICAgICAgICAgIC8vIFVwZGF0ZSBleGlzdGluZyBxdWVzdGlvblxuICAgICAgICAgIGV4aXN0aW5nUXVlc3Rpb25zW2V4aXN0aW5nSW5kZXhdID0gcXVlc3Rpb25cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YWxpZFF1ZXN0aW9ucy5wdXNoKHF1ZXN0aW9uKVxuICAgICAgICB9XG5cbiAgICAgICAgcmVzdWx0cy5wcm9jZXNzZWRDb3VudCsrXG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICByZXN1bHRzLmVycm9ycy5wdXNoKGBMaW5lICR7aSArIDJ9OiAke2Vycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogJ1Vua25vd24gZXJyb3InfWApXG4gICAgICAgIHJlc3VsdHMuZXJyb3JDb3VudCsrXG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gU2F2ZSBhbGwgdmFsaWQgcXVlc3Rpb25zXG4gICAgaWYgKHZhbGlkUXVlc3Rpb25zLmxlbmd0aCA+IDApIHtcbiAgICAgIGNvbnN0IGFsbFF1ZXN0aW9ucyA9IFsuLi5leGlzdGluZ1F1ZXN0aW9ucywgLi4udmFsaWRRdWVzdGlvbnNdXG4gICAgICB0aGlzLnNhdmVRdWVzdGlvbnMoYWxsUXVlc3Rpb25zKVxuICAgIH1cblxuICAgIHJlc3VsdHMuc3VjY2VzcyA9IHJlc3VsdHMuZXJyb3JDb3VudCA9PT0gMFxuICAgIHJldHVybiByZXN1bHRzXG4gIH1cblxuICBwcml2YXRlIHBhcnNlQ1NWTGluZShsaW5lOiBzdHJpbmcpOiBzdHJpbmdbXSB7XG4gICAgY29uc3QgcmVzdWx0OiBzdHJpbmdbXSA9IFtdXG4gICAgbGV0IGN1cnJlbnQgPSAnJ1xuICAgIGxldCBpblF1b3RlcyA9IGZhbHNlXG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxpbmUubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGNoYXIgPSBsaW5lW2ldXG5cbiAgICAgIGlmIChjaGFyID09PSAnXCInKSB7XG4gICAgICAgIGlmIChpblF1b3RlcyAmJiBsaW5lW2kgKyAxXSA9PT0gJ1wiJykge1xuICAgICAgICAgIGN1cnJlbnQgKz0gJ1wiJ1xuICAgICAgICAgIGkrKyAvLyBTa2lwIG5leHQgcXVvdGVcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpblF1b3RlcyA9ICFpblF1b3Rlc1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGNoYXIgPT09ICcsJyAmJiAhaW5RdW90ZXMpIHtcbiAgICAgICAgcmVzdWx0LnB1c2goY3VycmVudC50cmltKCkpXG4gICAgICAgIGN1cnJlbnQgPSAnJ1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY3VycmVudCArPSBjaGFyXG4gICAgICB9XG4gICAgfVxuXG4gICAgcmVzdWx0LnB1c2goY3VycmVudC50cmltKCkpXG4gICAgcmV0dXJuIHJlc3VsdFxuICB9XG5cbiAgcHJpdmF0ZSBpbml0aWFsaXplV2l0aFNhbXBsZURhdGEoKTogUXVpelF1ZXN0aW9uW10ge1xuICAgIC8vIENoZWNrIGlmIHdlIHNob3VsZCBpbXBvcnQgZXhpc3RpbmcgcXVlc3Rpb25zXG4gICAgaWYgKHRoaXMuc2hvdWxkSW1wb3J0RXhpc3RpbmdRdWVzdGlvbnMoKSkge1xuICAgICAgcmV0dXJuIHRoaXMuaW1wb3J0QWxsRXhpc3RpbmdRdWVzdGlvbnMoKVxuICAgIH1cblxuICAgIC8vIEluaXRpYWxpemUgd2l0aCBhIGZldyBzYW1wbGUgcXVlc3Rpb25zIGZvciBkZW1vbnN0cmF0aW9uXG4gICAgY29uc3Qgc2FtcGxlUXVlc3Rpb25zOiBRdWl6UXVlc3Rpb25bXSA9IFtcbiAgICAgIHtcbiAgICAgICAgaWQ6ICdzYW1wbGVfMScsXG4gICAgICAgIHF1ZXN0aW9uOiAnV2hpY2ggc29jaWFsIG1lZGlhIHBsYXRmb3JtIGlzIGtub3duIGZvciBpdHMgc2hvcnQtZm9ybSB2aWRlbyBjb250ZW50IGFuZCB2aXJhbCBkYW5jZXM/JyxcbiAgICAgICAgb3B0aW9uczogWydJbnN0YWdyYW0nLCAnVGlrVG9rJywgJ1R3aXR0ZXInLCAnU25hcGNoYXQnXSxcbiAgICAgICAgY29ycmVjdEFuc3dlcjogMSxcbiAgICAgICAgY2F0ZWdvcnk6ICdzb2NpYWwtbWVkaWEnLFxuICAgICAgICBkaWZmaWN1bHR5OiAnYmVnaW5uZXInLFxuICAgICAgICB0eXBlOiAncmVndWxhcicsXG4gICAgICAgIHNlY3Rpb246ICdob21lcGFnZScsXG4gICAgICAgIGZ1bkZhY3Q6ICdUaWtUb2sgd2FzIG9yaWdpbmFsbHkgY2FsbGVkIE11c2ljYWwubHkgYmVmb3JlIGJlaW5nIGFjcXVpcmVkIGJ5IEJ5dGVEYW5jZS4nLFxuICAgICAgICB0YWdzOiBbJ3NvY2lhbC1tZWRpYScsICd2aWRlbycsICd2aXJhbCddLFxuICAgICAgICBjcmVhdGVkQXQ6IERhdGUubm93KCkgLSA4NjQwMDAwMCwgLy8gMSBkYXkgYWdvXG4gICAgICAgIHVwZGF0ZWRBdDogRGF0ZS5ub3coKSAtIDg2NDAwMDAwXG4gICAgICB9XG4gICAgICAvLyBBZGQgbW9yZSBzYW1wbGUgcXVlc3Rpb25zIGFzIG5lZWRlZFxuICAgIF1cblxuICAgIHRoaXMuc2F2ZVF1ZXN0aW9ucyhzYW1wbGVRdWVzdGlvbnMpXG4gICAgcmV0dXJuIHNhbXBsZVF1ZXN0aW9uc1xuICB9XG5cbiAgLy8gQ2hlY2sgaWYgd2Ugc2hvdWxkIGltcG9ydCBleGlzdGluZyBxdWVzdGlvbnNcbiAgcHJpdmF0ZSBzaG91bGRJbXBvcnRFeGlzdGluZ1F1ZXN0aW9ucygpOiBib29sZWFuIHtcbiAgICAvLyBPbmx5IGltcG9ydCBpZiBsb2NhbFN0b3JhZ2UgaXMgZW1wdHkgYW5kIHdlJ3JlIG9uIGNsaWVudCBzaWRlXG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSByZXR1cm4gZmFsc2VcblxuICAgIGNvbnN0IGhhc0ltcG9ydGVkID0gdGhpcy5zYWZlR2V0SXRlbSgncXVpel9xdWVzdGlvbnNfaW1wb3J0ZWQnKVxuICAgIHJldHVybiAhaGFzSW1wb3J0ZWRcbiAgfVxuXG4gIC8vIEltcG9ydCBhbGwgZXhpc3RpbmcgcXVlc3Rpb25zIGZyb20gZGlmZmVyZW50IHNvdXJjZXNcbiAgcHJpdmF0ZSBpbXBvcnRBbGxFeGlzdGluZ1F1ZXN0aW9ucygpOiBRdWl6UXVlc3Rpb25bXSB7XG4gICAgY29uc3QgYWxsUXVlc3Rpb25zOiBRdWl6UXVlc3Rpb25bXSA9IFtdXG5cbiAgICB0cnkge1xuICAgICAgLy8gSW1wb3J0IG9uYm9hcmRpbmcgcXVlc3Rpb25zXG4gICAgICBjb25zdCBvbmJvYXJkaW5nUXVlc3Rpb25zID0gdGhpcy5pbXBvcnRPbmJvYXJkaW5nUXVlc3Rpb25zKClcbiAgICAgIGFsbFF1ZXN0aW9ucy5wdXNoKC4uLm9uYm9hcmRpbmdRdWVzdGlvbnMpXG5cbiAgICAgIC8vIEltcG9ydCBob21lcGFnZSBmYWxsYmFjayBxdWVzdGlvbnNcbiAgICAgIGNvbnN0IGhvbWVwYWdlUXVlc3Rpb25zID0gdGhpcy5pbXBvcnRIb21lcGFnZVF1ZXN0aW9ucygpXG4gICAgICBhbGxRdWVzdGlvbnMucHVzaCguLi5ob21lcGFnZVF1ZXN0aW9ucylcblxuICAgICAgLy8gSW1wb3J0IGNhdGVnb3J5IHF1ZXN0aW9ucyBmcm9tIHF1aXogZGF0YWJhc2VcbiAgICAgIGNvbnN0IGNhdGVnb3J5UXVlc3Rpb25zID0gdGhpcy5pbXBvcnRDYXRlZ29yeVF1ZXN0aW9ucygpXG4gICAgICBhbGxRdWVzdGlvbnMucHVzaCguLi5jYXRlZ29yeVF1ZXN0aW9ucylcblxuICAgICAgY29uc29sZS5sb2coYPCfk4ogSW1wb3J0ZWQgJHthbGxRdWVzdGlvbnMubGVuZ3RofSBxdWVzdGlvbnMgZnJvbSBleGlzdGluZyBzb3VyY2VzYClcblxuICAgICAgLy8gU2F2ZSBhbGwgaW1wb3J0ZWQgcXVlc3Rpb25zXG4gICAgICB0aGlzLnNhdmVRdWVzdGlvbnMoYWxsUXVlc3Rpb25zKVxuXG4gICAgICAvLyBNYXJrIGFzIGltcG9ydGVkXG4gICAgICB0aGlzLnNhZmVTZXRJdGVtKCdxdWl6X3F1ZXN0aW9uc19pbXBvcnRlZCcsICd0cnVlJylcblxuICAgICAgcmV0dXJuIGFsbFF1ZXN0aW9uc1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBpbXBvcnRpbmcgZXhpc3RpbmcgcXVlc3Rpb25zOicsIGVycm9yKVxuICAgICAgcmV0dXJuIFtdXG4gICAgfVxuICB9XG5cbiAgLy8gSW1wb3J0IG1ldGhvZHMgZm9yIGV4aXN0aW5nIHF1ZXN0aW9uc1xuICBwcml2YXRlIGltcG9ydE9uYm9hcmRpbmdRdWVzdGlvbnMoKTogUXVpelF1ZXN0aW9uW10ge1xuICAgIGNvbnN0IG9uYm9hcmRpbmdRdWVzdGlvbnMgPSBbXG4gICAgICB7XG4gICAgICAgIGlkOiAnb25ib2FyZC0xJyxcbiAgICAgICAgcXVlc3Rpb246IFwiV2hpY2ggdGVjaCBjb21wYW55IGNyZWF0ZWQgdGhlIGlQaG9uZT9cIixcbiAgICAgICAgb3B0aW9uczogW1wiQXBwbGUg8J+NjlwiLCBcIkdvb2dsZSDwn5SNXCIsIFwiU2Ftc3VuZyDwn5OxXCIsIFwiTWljcm9zb2Z0IPCfkrtcIl0sXG4gICAgICAgIGNvcnJlY3RBbnN3ZXI6IDAsXG4gICAgICAgIGNhdGVnb3J5OiAndGVjaG5vbG9neScsXG4gICAgICAgIGRpZmZpY3VsdHk6ICdiZWdpbm5lcicgYXMgY29uc3QsXG4gICAgICAgIHR5cGU6ICdyZWd1bGFyJyBhcyBjb25zdCxcbiAgICAgICAgc2VjdGlvbjogJ29uYm9hcmRpbmcnIGFzIGNvbnN0LFxuICAgICAgICByZXdhcmRDb2luczogMTUwLFxuICAgICAgICBmdW5GYWN0OiBcIlRoZSBmaXJzdCBpUGhvbmUgd2FzIHJlbGVhc2VkIG9uIEp1bmUgMjksIDIwMDcsIHJldm9sdXRpb25pemluZyB0aGUgc21hcnRwaG9uZSBpbmR1c3RyeS5cIixcbiAgICAgICAgdGFnczogWyd0ZWNobm9sb2d5JywgJ2FwcGxlJywgJ3NtYXJ0cGhvbmUnXSxcbiAgICAgICAgY3JlYXRlZEF0OiBEYXRlLm5vdygpLFxuICAgICAgICB1cGRhdGVkQXQ6IERhdGUubm93KClcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGlkOiAnb25ib2FyZC0yJyxcbiAgICAgICAgcXVlc3Rpb246IFwiV2hhdCBkb2VzICdXV1cnIHN0YW5kIGZvcj9cIixcbiAgICAgICAgb3B0aW9uczogW1wiV29ybGQgV2lkZSBXZWIg8J+MkFwiLCBcIldvcmxkIFdlYiBXb3JrcyDwn5SnXCIsIFwiV2ViIFdvcmxkIFdpZGUg8J+MjVwiLCBcIldpZGUgV29ybGQgV2ViIPCfk6FcIl0sXG4gICAgICAgIGNvcnJlY3RBbnN3ZXI6IDAsXG4gICAgICAgIGNhdGVnb3J5OiAndGVjaG5vbG9neScsXG4gICAgICAgIGRpZmZpY3VsdHk6ICdiZWdpbm5lcicgYXMgY29uc3QsXG4gICAgICAgIHR5cGU6ICdyZWd1bGFyJyBhcyBjb25zdCxcbiAgICAgICAgc2VjdGlvbjogJ29uYm9hcmRpbmcnIGFzIGNvbnN0LFxuICAgICAgICByZXdhcmRDb2luczogMTUwLFxuICAgICAgICBmdW5GYWN0OiBcIlRoZSBXb3JsZCBXaWRlIFdlYiB3YXMgaW52ZW50ZWQgYnkgVGltIEJlcm5lcnMtTGVlIGluIDE5ODkgd2hpbGUgd29ya2luZyBhdCBDRVJOLlwiLFxuICAgICAgICB0YWdzOiBbJ3RlY2hub2xvZ3knLCAnaW50ZXJuZXQnLCAnd2ViJ10sXG4gICAgICAgIGNyZWF0ZWRBdDogRGF0ZS5ub3coKSxcbiAgICAgICAgdXBkYXRlZEF0OiBEYXRlLm5vdygpXG4gICAgICB9XG4gICAgXVxuXG4gICAgcmV0dXJuIG9uYm9hcmRpbmdRdWVzdGlvbnNcbiAgfVxuXG4gIHByaXZhdGUgaW1wb3J0SG9tZXBhZ2VRdWVzdGlvbnMoKTogUXVpelF1ZXN0aW9uW10ge1xuICAgIGNvbnN0IGhvbWVwYWdlUXVlc3Rpb25zID0gW1xuICAgICAge1xuICAgICAgICBpZDogJ2hvbWVwYWdlLTEnLFxuICAgICAgICBxdWVzdGlvbjogXCJXaGljaCBzb2NpYWwgbWVkaWEgcGxhdGZvcm0gaXMga25vd24gZm9yIHNob3J0LWZvcm0gdmlkZW9zP1wiLFxuICAgICAgICBvcHRpb25zOiBbXCJJbnN0YWdyYW1cIiwgXCJUaWtUb2tcIiwgXCJUd2l0dGVyXCIsIFwiU25hcGNoYXRcIl0sXG4gICAgICAgIGNvcnJlY3RBbnN3ZXI6IDEsXG4gICAgICAgIGNhdGVnb3J5OiAnc29jaWFsLW1lZGlhJyxcbiAgICAgICAgZGlmZmljdWx0eTogJ2JlZ2lubmVyJyBhcyBjb25zdCxcbiAgICAgICAgdHlwZTogJ3JlZ3VsYXInIGFzIGNvbnN0LFxuICAgICAgICBzZWN0aW9uOiAnaG9tZXBhZ2UnIGFzIGNvbnN0LFxuICAgICAgICBmdW5GYWN0OiBcIlRpa1RvayB3YXMgb3JpZ2luYWxseSBjYWxsZWQgTXVzaWNhbC5seSFcIixcbiAgICAgICAgdGFnczogWydzb2NpYWwtbWVkaWEnLCAndmlkZW8nLCAnYXBwcyddLFxuICAgICAgICBjcmVhdGVkQXQ6IERhdGUubm93KCksXG4gICAgICAgIHVwZGF0ZWRBdDogRGF0ZS5ub3coKVxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgaWQ6ICdob21lcGFnZS0yJyxcbiAgICAgICAgcXVlc3Rpb246IFwiV2hhdCBkb2VzICdBSScgc3RhbmQgZm9yP1wiLFxuICAgICAgICBvcHRpb25zOiBbXCJBcnRpZmljaWFsIEludGVsbGlnZW5jZVwiLCBcIkF1dG9tYXRlZCBJbnRlcm5ldFwiLCBcIkFkdmFuY2VkIEludGVyZmFjZVwiLCBcIkFsZ29yaXRobWljIEludGVncmF0aW9uXCJdLFxuICAgICAgICBjb3JyZWN0QW5zd2VyOiAwLFxuICAgICAgICBjYXRlZ29yeTogJ3RlY2hub2xvZ3knLFxuICAgICAgICBkaWZmaWN1bHR5OiAnYmVnaW5uZXInIGFzIGNvbnN0LFxuICAgICAgICB0eXBlOiAncmVndWxhcicgYXMgY29uc3QsXG4gICAgICAgIHNlY3Rpb246ICdob21lcGFnZScgYXMgY29uc3QsXG4gICAgICAgIGZ1bkZhY3Q6IFwiVGhlIHRlcm0gJ0FydGlmaWNpYWwgSW50ZWxsaWdlbmNlJyB3YXMgZmlyc3QgY29pbmVkIGluIDE5NTYhXCIsXG4gICAgICAgIHRhZ3M6IFsndGVjaG5vbG9neScsICdhaScsICdjb21wdXRpbmcnXSxcbiAgICAgICAgY3JlYXRlZEF0OiBEYXRlLm5vdygpLFxuICAgICAgICB1cGRhdGVkQXQ6IERhdGUubm93KClcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGlkOiAnaG9tZXBhZ2UtMycsXG4gICAgICAgIHF1ZXN0aW9uOiBcIldoaWNoIGNvbXBhbnkgY3JlYXRlZCB0aGUgaVBob25lP1wiLFxuICAgICAgICBvcHRpb25zOiBbXCJHb29nbGVcIiwgXCJTYW1zdW5nXCIsIFwiQXBwbGVcIiwgXCJNaWNyb3NvZnRcIl0sXG4gICAgICAgIGNvcnJlY3RBbnN3ZXI6IDIsXG4gICAgICAgIGNhdGVnb3J5OiAndGVjaG5vbG9neScsXG4gICAgICAgIGRpZmZpY3VsdHk6ICdiZWdpbm5lcicgYXMgY29uc3QsXG4gICAgICAgIHR5cGU6ICdyZWd1bGFyJyBhcyBjb25zdCxcbiAgICAgICAgc2VjdGlvbjogJ2hvbWVwYWdlJyBhcyBjb25zdCxcbiAgICAgICAgZnVuRmFjdDogXCJUaGUgZmlyc3QgaVBob25lIHdhcyByZWxlYXNlZCBpbiAyMDA3IVwiLFxuICAgICAgICB0YWdzOiBbJ3RlY2hub2xvZ3knLCAnYXBwbGUnLCAnc21hcnRwaG9uZSddLFxuICAgICAgICBjcmVhdGVkQXQ6IERhdGUubm93KCksXG4gICAgICAgIHVwZGF0ZWRBdDogRGF0ZS5ub3coKVxuICAgICAgfVxuICAgIF1cblxuICAgIHJldHVybiBob21lcGFnZVF1ZXN0aW9uc1xuICB9XG5cbiAgcHJpdmF0ZSBpbXBvcnRDYXRlZ29yeVF1ZXN0aW9ucygpOiBRdWl6UXVlc3Rpb25bXSB7XG4gICAgLy8gSW1wb3J0IGEgc3Vic2V0IG9mIHF1ZXN0aW9ucyBmcm9tIHRoZSBxdWl6IGRhdGFiYXNlXG4gICAgY29uc3QgY2F0ZWdvcnlRdWVzdGlvbnM6IFF1aXpRdWVzdGlvbltdID0gW11cblxuICAgIHRyeSB7XG4gICAgICAvLyBTYW1wbGUgY2F0ZWdvcnkgcXVlc3Rpb25zIC0gaW4gYSByZWFsIGltcGxlbWVudGF0aW9uLCB0aGlzIHdvdWxkIGltcG9ydCBmcm9tIHRoZSBhY3R1YWwgcXVpeiBkYXRhYmFzZVxuICAgICAgY29uc3Qgc2FtcGxlQ2F0ZWdvcnlRdWVzdGlvbnMgPSBbXG4gICAgICAgIHtcbiAgICAgICAgICBpZDogJ2NhdC10ZWNoLTEnLFxuICAgICAgICAgIHF1ZXN0aW9uOiBcIldoaWNoIHByb2dyYW1taW5nIGxhbmd1YWdlIGlzIGtub3duIGZvciBpdHMgdXNlIGluIHdlYiBkZXZlbG9wbWVudCBhbmQgaGFzIGEgY29mZmVlLXJlbGF0ZWQgbmFtZT9cIixcbiAgICAgICAgICBvcHRpb25zOiBbXCJQeXRob25cIiwgXCJKYXZhXCIsIFwiSmF2YVNjcmlwdFwiLCBcIkMrK1wiXSxcbiAgICAgICAgICBjb3JyZWN0QW5zd2VyOiAxLFxuICAgICAgICAgIGNhdGVnb3J5OiAndGVjaG5vbG9neScsXG4gICAgICAgICAgZGlmZmljdWx0eTogJ2ludGVybWVkaWF0ZScgYXMgY29uc3QsXG4gICAgICAgICAgdHlwZTogJ3JlZ3VsYXInIGFzIGNvbnN0LFxuICAgICAgICAgIHNlY3Rpb246ICdjYXRlZ29yeScgYXMgY29uc3QsXG4gICAgICAgICAgc3ViY2F0ZWdvcnk6ICdwcm9ncmFtbWluZycsXG4gICAgICAgICAgZnVuRmFjdDogXCJKYXZhIHdhcyBvcmlnaW5hbGx5IGNhbGxlZCBPYWsgYW5kIHdhcyBkZXZlbG9wZWQgYnkgSmFtZXMgR29zbGluZyBhdCBTdW4gTWljcm9zeXN0ZW1zLlwiLFxuICAgICAgICAgIHRhZ3M6IFsncHJvZ3JhbW1pbmcnLCAnamF2YScsICdkZXZlbG9wbWVudCddLFxuICAgICAgICAgIGNyZWF0ZWRBdDogRGF0ZS5ub3coKSxcbiAgICAgICAgICB1cGRhdGVkQXQ6IERhdGUubm93KClcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIGlkOiAnY2F0LXNvY2lhbC0xJyxcbiAgICAgICAgICBxdWVzdGlvbjogXCJXaGljaCBzb2NpYWwgbWVkaWEgcGxhdGZvcm0gd2FzIG9yaWdpbmFsbHkgY2FsbGVkICdUaGUgRmFjZWJvb2snP1wiLFxuICAgICAgICAgIG9wdGlvbnM6IFtcIkluc3RhZ3JhbVwiLCBcIlR3aXR0ZXJcIiwgXCJGYWNlYm9va1wiLCBcIkxpbmtlZEluXCJdLFxuICAgICAgICAgIGNvcnJlY3RBbnN3ZXI6IDIsXG4gICAgICAgICAgY2F0ZWdvcnk6ICdzb2NpYWwtbWVkaWEnLFxuICAgICAgICAgIGRpZmZpY3VsdHk6ICdiZWdpbm5lcicgYXMgY29uc3QsXG4gICAgICAgICAgdHlwZTogJ3JlZ3VsYXInIGFzIGNvbnN0LFxuICAgICAgICAgIHNlY3Rpb246ICdjYXRlZ29yeScgYXMgY29uc3QsXG4gICAgICAgICAgc3ViY2F0ZWdvcnk6ICdoaXN0b3J5JyxcbiAgICAgICAgICBmdW5GYWN0OiBcIkZhY2Vib29rIHdhcyBmb3VuZGVkIGJ5IE1hcmsgWnVja2VyYmVyZyBpbiAyMDA0IHdoaWxlIGhlIHdhcyBhIHN0dWRlbnQgYXQgSGFydmFyZCBVbml2ZXJzaXR5LlwiLFxuICAgICAgICAgIHRhZ3M6IFsnc29jaWFsLW1lZGlhJywgJ2ZhY2Vib29rJywgJ2hpc3RvcnknXSxcbiAgICAgICAgICBjcmVhdGVkQXQ6IERhdGUubm93KCksXG4gICAgICAgICAgdXBkYXRlZEF0OiBEYXRlLm5vdygpXG4gICAgICAgIH1cbiAgICAgIF1cblxuICAgICAgY2F0ZWdvcnlRdWVzdGlvbnMucHVzaCguLi5zYW1wbGVDYXRlZ29yeVF1ZXN0aW9ucylcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgaW1wb3J0aW5nIGNhdGVnb3J5IHF1ZXN0aW9uczonLCBlcnJvcilcbiAgICB9XG5cbiAgICByZXR1cm4gY2F0ZWdvcnlRdWVzdGlvbnNcbiAgfVxuXG4gIC8vIEZvcmNlIHJlaW1wb3J0IG9mIGFsbCBxdWVzdGlvbnMgKGZvciBhZG1pbiB1c2UpXG4gIGZvcmNlUmVpbXBvcnRRdWVzdGlvbnMoKTogQnVsa09wZXJhdGlvblJlc3VsdCB7XG4gICAgdHJ5IHtcbiAgICAgIC8vIENsZWFyIHRoZSBpbXBvcnQgZmxhZ1xuICAgICAgdGhpcy5zYWZlU2V0SXRlbSgncXVpel9xdWVzdGlvbnNfaW1wb3J0ZWQnLCAnJylcblxuICAgICAgLy8gQ2xlYXIgZXhpc3RpbmcgcXVlc3Rpb25zXG4gICAgICB0aGlzLnNhZmVTZXRJdGVtKFFVSVpfU1RPUkFHRV9LRVlTLlFVRVNUSU9OUywgJycpXG5cbiAgICAgIC8vIEltcG9ydCBhbGwgcXVlc3Rpb25zXG4gICAgICBjb25zdCBpbXBvcnRlZFF1ZXN0aW9ucyA9IHRoaXMuaW1wb3J0QWxsRXhpc3RpbmdRdWVzdGlvbnMoKVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBzdWNjZXNzOiB0cnVlLFxuICAgICAgICBwcm9jZXNzZWRDb3VudDogaW1wb3J0ZWRRdWVzdGlvbnMubGVuZ3RoLFxuICAgICAgICBlcnJvckNvdW50OiAwLFxuICAgICAgICBlcnJvcnM6IFtdXG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICBwcm9jZXNzZWRDb3VudDogMCxcbiAgICAgICAgZXJyb3JDb3VudDogMSxcbiAgICAgICAgZXJyb3JzOiBbZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiAnSW1wb3J0IGZhaWxlZCddXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gQmFja3VwIGFuZCByZXN0b3JlIGZ1bmN0aW9uYWxpdHlcbiAgY3JlYXRlQmFja3VwKCk6IHN0cmluZyB7XG4gICAgY29uc3QgYmFja3VwID0ge1xuICAgICAgcXVlc3Rpb25zOiB0aGlzLmdldFF1ZXN0aW9ucygpLFxuICAgICAgc2V0dGluZ3M6IHRoaXMuZ2V0U2V0dGluZ3MoKSxcbiAgICAgIGRyYWZ0czogdGhpcy5nZXREcmFmdHMoKSxcbiAgICAgIHRpbWVzdGFtcDogRGF0ZS5ub3coKSxcbiAgICAgIHZlcnNpb246ICcxLjAnXG4gICAgfVxuXG4gICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KGJhY2t1cCwgbnVsbCwgMilcbiAgfVxuXG4gIHJlc3RvcmVGcm9tQmFja3VwKGJhY2t1cERhdGE6IHN0cmluZyk6IEJ1bGtPcGVyYXRpb25SZXN1bHQge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBiYWNrdXAgPSBKU09OLnBhcnNlKGJhY2t1cERhdGEpXG5cbiAgICAgIGlmICghYmFja3VwLnF1ZXN0aW9ucyB8fCAhQXJyYXkuaXNBcnJheShiYWNrdXAucXVlc3Rpb25zKSkge1xuICAgICAgICB0aHJvdyBuZXcgUXVpekRhdGFFcnJvcignSW52YWxpZCBiYWNrdXAgZm9ybWF0OiBtaXNzaW5nIHF1ZXN0aW9ucyBhcnJheScsICdJTlZBTElEX0JBQ0tVUCcpXG4gICAgICB9XG5cbiAgICAgIC8vIFZhbGlkYXRlIGFsbCBxdWVzdGlvbnMgaW4gYmFja3VwXG4gICAgICBiYWNrdXAucXVlc3Rpb25zLmZvckVhY2goKHE6IGFueSwgaW5kZXg6IG51bWJlcikgPT4ge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHRoaXMudmFsaWRhdGVRdWVzdGlvbihxKVxuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgIHRocm93IG5ldyBRdWl6RGF0YUVycm9yKFxuICAgICAgICAgICAgYEludmFsaWQgcXVlc3Rpb24gYXQgaW5kZXggJHtpbmRleH06ICR7ZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiAnVW5rbm93biBlcnJvcid9YCxcbiAgICAgICAgICAgICdJTlZBTElEX0JBQ0tVUF9RVUVTVElPTidcbiAgICAgICAgICApXG4gICAgICAgIH1cbiAgICAgIH0pXG5cbiAgICAgIC8vIENyZWF0ZSBjdXJyZW50IGJhY2t1cCBiZWZvcmUgcmVzdG9yZVxuICAgICAgY29uc3QgY3VycmVudEJhY2t1cCA9IHRoaXMuY3JlYXRlQmFja3VwKClcbiAgICAgIHRoaXMuc2FmZVNldEl0ZW0oUVVJWl9TVE9SQUdFX0tFWVMuQkFDS1VQLCBjdXJyZW50QmFja3VwKVxuXG4gICAgICAvLyBSZXN0b3JlIGRhdGFcbiAgICAgIHRoaXMuc2F2ZVF1ZXN0aW9ucyhiYWNrdXAucXVlc3Rpb25zKVxuICAgICAgaWYgKGJhY2t1cC5zZXR0aW5ncykge1xuICAgICAgICB0aGlzLnNhZmVTZXRJdGVtKFFVSVpfU1RPUkFHRV9LRVlTLlNFVFRJTkdTLCBKU09OLnN0cmluZ2lmeShiYWNrdXAuc2V0dGluZ3MpKVxuICAgICAgfVxuICAgICAgaWYgKGJhY2t1cC5kcmFmdHMpIHtcbiAgICAgICAgdGhpcy5zYWZlU2V0SXRlbShRVUlaX1NUT1JBR0VfS0VZUy5EUkFGVFMsIEpTT04uc3RyaW5naWZ5KGJhY2t1cC5kcmFmdHMpKVxuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBzdWNjZXNzOiB0cnVlLFxuICAgICAgICBwcm9jZXNzZWRDb3VudDogYmFja3VwLnF1ZXN0aW9ucy5sZW5ndGgsXG4gICAgICAgIGVycm9yQ291bnQ6IDAsXG4gICAgICAgIGVycm9yczogW11cbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgdGhyb3cgbmV3IFF1aXpEYXRhRXJyb3IoXG4gICAgICAgIGBGYWlsZWQgdG8gcmVzdG9yZSBiYWNrdXA6ICR7ZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiAnVW5rbm93biBlcnJvcid9YCxcbiAgICAgICAgJ1JFU1RPUkVfRkFJTEVEJ1xuICAgICAgKVxuICAgIH1cbiAgfVxuXG4gIC8vIEF1dG8tc2F2ZSBmdW5jdGlvbmFsaXR5IGZvciBkcmFmdHNcbiAgc3RhcnRBdXRvU2F2ZShkcmFmdElkOiBzdHJpbmcsIGdldERyYWZ0RGF0YTogKCkgPT4gUGFydGlhbDxRdWVzdGlvbkRyYWZ0Pik6IHZvaWQge1xuICAgIHRoaXMuc3RvcEF1dG9TYXZlKClcblxuICAgIHRoaXMuYXV0b1NhdmVUaW1lciA9IHNldEludGVydmFsKCgpID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IGRyYWZ0RGF0YSA9IGdldERyYWZ0RGF0YSgpXG4gICAgICAgIGlmIChkcmFmdERhdGEucXVlc3Rpb24gJiYgZHJhZnREYXRhLnF1ZXN0aW9uLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBjb25zdCBkcmFmdDogUXVlc3Rpb25EcmFmdCA9IHtcbiAgICAgICAgICAgIGlkOiBkcmFmdElkLFxuICAgICAgICAgICAgcXVlc3Rpb246IGRyYWZ0RGF0YS5xdWVzdGlvbiB8fCAnJyxcbiAgICAgICAgICAgIG9wdGlvbnM6IGRyYWZ0RGF0YS5vcHRpb25zIHx8IFsnJywgJycsICcnLCAnJ10sXG4gICAgICAgICAgICBjb3JyZWN0QW5zd2VyOiBkcmFmdERhdGEuY29ycmVjdEFuc3dlciB8fCAwLFxuICAgICAgICAgICAgY2F0ZWdvcnk6IGRyYWZ0RGF0YS5jYXRlZ29yeSB8fCAnZmFjdHMnLFxuICAgICAgICAgICAgZGlmZmljdWx0eTogZHJhZnREYXRhLmRpZmZpY3VsdHkgfHwgJ2JlZ2lubmVyJyxcbiAgICAgICAgICAgIHR5cGU6IGRyYWZ0RGF0YS50eXBlIHx8ICdyZWd1bGFyJyxcbiAgICAgICAgICAgIGZ1bkZhY3Q6IGRyYWZ0RGF0YS5mdW5GYWN0LFxuICAgICAgICAgICAgdGFnczogZHJhZnREYXRhLnRhZ3MsXG4gICAgICAgICAgICBsYXN0U2F2ZWQ6IERhdGUubm93KClcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aGlzLnNhdmVEcmFmdChkcmFmdClcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignQXV0by1zYXZlIGZhaWxlZDonLCBlcnJvcilcbiAgICAgIH1cbiAgICB9LCBWQUxJREFUSU9OX1JVTEVTLkFVVE9fU0FWRV9JTlRFUlZBTClcbiAgfVxuXG4gIHN0b3BBdXRvU2F2ZSgpOiB2b2lkIHtcbiAgICBpZiAodGhpcy5hdXRvU2F2ZVRpbWVyKSB7XG4gICAgICBjbGVhckludGVydmFsKHRoaXMuYXV0b1NhdmVUaW1lcilcbiAgICAgIHRoaXMuYXV0b1NhdmVUaW1lciA9IG51bGxcbiAgICB9XG4gIH1cblxuICAvLyBDU1YgRXhwb3J0IGZ1bmN0aW9uYWxpdHlcbiAgZXhwb3J0VG9DU1YocXVlc3Rpb25zVG9FeHBvcnQ/OiBRdWl6UXVlc3Rpb25bXSk6IHN0cmluZyB7XG4gICAgY29uc3QgcXVlc3Rpb25zID0gcXVlc3Rpb25zVG9FeHBvcnQgfHwgdGhpcy5nZXRRdWVzdGlvbnMoKVxuICAgIGNvbnN0IGhlYWRlcnMgPSBbXG4gICAgICAnSUQnLFxuICAgICAgJ1F1ZXN0aW9uJyxcbiAgICAgICdPcHRpb24gMScsXG4gICAgICAnT3B0aW9uIDInLFxuICAgICAgJ09wdGlvbiAzJyxcbiAgICAgICdPcHRpb24gNCcsXG4gICAgICAnQ29ycmVjdCBBbnN3ZXIgKDEtNCknLFxuICAgICAgJ0NhdGVnb3J5JyxcbiAgICAgICdEaWZmaWN1bHR5JyxcbiAgICAgICdUeXBlJyxcbiAgICAgICdGdW4gRmFjdCcsXG4gICAgICAnVGFncycsXG4gICAgICAnQ3JlYXRlZCBBdCcsXG4gICAgICAnVXBkYXRlZCBBdCdcbiAgICBdXG5cbiAgICBjb25zdCBjc3ZSb3dzID0gW2hlYWRlcnMuam9pbignLCcpXVxuXG4gICAgcXVlc3Rpb25zLmZvckVhY2gocXVlc3Rpb24gPT4ge1xuICAgICAgY29uc3Qgcm93ID0gW1xuICAgICAgICBxdWVzdGlvbi5pZCxcbiAgICAgICAgYFwiJHtxdWVzdGlvbi5xdWVzdGlvbi5yZXBsYWNlKC9cIi9nLCAnXCJcIicpfVwiYCwgLy8gRXNjYXBlIHF1b3Rlc1xuICAgICAgICBgXCIke3F1ZXN0aW9uLm9wdGlvbnNbMF0/LnJlcGxhY2UoL1wiL2csICdcIlwiJykgfHwgJyd9XCJgLFxuICAgICAgICBgXCIke3F1ZXN0aW9uLm9wdGlvbnNbMV0/LnJlcGxhY2UoL1wiL2csICdcIlwiJykgfHwgJyd9XCJgLFxuICAgICAgICBgXCIke3F1ZXN0aW9uLm9wdGlvbnNbMl0/LnJlcGxhY2UoL1wiL2csICdcIlwiJykgfHwgJyd9XCJgLFxuICAgICAgICBgXCIke3F1ZXN0aW9uLm9wdGlvbnNbM10/LnJlcGxhY2UoL1wiL2csICdcIlwiJykgfHwgJyd9XCJgLFxuICAgICAgICBxdWVzdGlvbi5jb3JyZWN0QW5zd2VyICsgMSwgLy8gQ29udmVydCAwLWJhc2VkIHRvIDEtYmFzZWRcbiAgICAgICAgcXVlc3Rpb24uY2F0ZWdvcnksXG4gICAgICAgIHF1ZXN0aW9uLmRpZmZpY3VsdHksXG4gICAgICAgIHF1ZXN0aW9uLnR5cGUsXG4gICAgICAgIGBcIiR7KHF1ZXN0aW9uLmZ1bkZhY3QgfHwgJycpLnJlcGxhY2UoL1wiL2csICdcIlwiJyl9XCJgLFxuICAgICAgICBgXCIkeyhxdWVzdGlvbi50YWdzIHx8IFtdKS5qb2luKCc7Jyl9XCJgLFxuICAgICAgICBuZXcgRGF0ZShxdWVzdGlvbi5jcmVhdGVkQXQpLnRvSVNPU3RyaW5nKCksXG4gICAgICAgIG5ldyBEYXRlKHF1ZXN0aW9uLnVwZGF0ZWRBdCkudG9JU09TdHJpbmcoKVxuICAgICAgXVxuICAgICAgY3N2Um93cy5wdXNoKHJvdy5qb2luKCcsJykpXG4gICAgfSlcblxuICAgIHJldHVybiBjc3ZSb3dzLmpvaW4oJ1xcbicpXG4gIH1cblxuICAvLyBEb3dubG9hZCBDU1YgZmlsZVxuICBkb3dubG9hZENTVigpOiB2b2lkIHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgY3N2Q29udGVudCA9IHRoaXMuZXhwb3J0VG9DU1YoKVxuICAgICAgY29uc3QgYmxvYiA9IG5ldyBCbG9iKFtjc3ZDb250ZW50XSwgeyB0eXBlOiAndGV4dC9jc3Y7Y2hhcnNldD11dGYtODsnIH0pXG4gICAgICBjb25zdCBsaW5rID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYScpXG5cbiAgICAgIGlmIChsaW5rLmRvd25sb2FkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY29uc3QgdXJsID0gVVJMLmNyZWF0ZU9iamVjdFVSTChibG9iKVxuICAgICAgICBsaW5rLnNldEF0dHJpYnV0ZSgnaHJlZicsIHVybClcbiAgICAgICAgbGluay5zZXRBdHRyaWJ1dGUoJ2Rvd25sb2FkJywgYHRlY2hrd2l6LXF1ZXN0aW9ucy0ke25ldyBEYXRlKCkudG9JU09TdHJpbmcoKS5zcGxpdCgnVCcpWzBdfS5jc3ZgKVxuICAgICAgICBsaW5rLnN0eWxlLnZpc2liaWxpdHkgPSAnaGlkZGVuJ1xuICAgICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGxpbmspXG4gICAgICAgIGxpbmsuY2xpY2soKVxuICAgICAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKGxpbmspXG4gICAgICAgIFVSTC5yZXZva2VPYmplY3RVUkwodXJsKVxuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICB0aHJvdyBuZXcgUXVpekRhdGFFcnJvcignRmFpbGVkIHRvIGRvd25sb2FkIENTViBmaWxlJywgJ0VYUE9SVF9FUlJPUicpXG4gICAgfVxuICB9XG5cbiAgLy8gUGFyc2UgQ1NWIGNvbnRlbnRcbiAgcGFyc2VDU1YoY3N2Q29udGVudDogc3RyaW5nKTogeyBxdWVzdGlvbnM6IFBhcnRpYWw8UXVpelF1ZXN0aW9uPltdOyBlcnJvcnM6IHN0cmluZ1tdIH0ge1xuICAgIGNvbnN0IGxpbmVzID0gY3N2Q29udGVudC5zcGxpdCgnXFxuJykuZmlsdGVyKGxpbmUgPT4gbGluZS50cmltKCkpXG4gICAgY29uc3QgZXJyb3JzOiBzdHJpbmdbXSA9IFtdXG4gICAgY29uc3QgcXVlc3Rpb25zOiBQYXJ0aWFsPFF1aXpRdWVzdGlvbj5bXSA9IFtdXG5cbiAgICBpZiAobGluZXMubGVuZ3RoIDwgMikge1xuICAgICAgZXJyb3JzLnB1c2goJ0NTViBmaWxlIG11c3QgY29udGFpbiBhdCBsZWFzdCBhIGhlYWRlciByb3cgYW5kIG9uZSBkYXRhIHJvdycpXG4gICAgICByZXR1cm4geyBxdWVzdGlvbnMsIGVycm9ycyB9XG4gICAgfVxuXG4gICAgLy8gU2tpcCBoZWFkZXIgcm93XG4gICAgY29uc3QgZGF0YUxpbmVzID0gbGluZXMuc2xpY2UoMSlcblxuICAgIGRhdGFMaW5lcy5mb3JFYWNoKChsaW5lLCBpbmRleCkgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgdmFsdWVzID0gdGhpcy5wYXJzZUNTVkxpbmUobGluZSlcblxuICAgICAgICBpZiAodmFsdWVzLmxlbmd0aCA8IDgpIHtcbiAgICAgICAgICBlcnJvcnMucHVzaChgUm93ICR7aW5kZXggKyAyfTogSW5zdWZmaWNpZW50IGNvbHVtbnMgKG1pbmltdW0gOCByZXF1aXJlZClgKVxuICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgW2lkLCBxdWVzdGlvbiwgb3B0MSwgb3B0Miwgb3B0Mywgb3B0NCwgY29ycmVjdEFuc3dlciwgY2F0ZWdvcnksIGRpZmZpY3VsdHksIHR5cGUsIGZ1bkZhY3QsIHRhZ3MsIGNyZWF0ZWRBdCwgdXBkYXRlZEF0XSA9IHZhbHVlc1xuXG4gICAgICAgIC8vIFZhbGlkYXRlIHJlcXVpcmVkIGZpZWxkc1xuICAgICAgICBpZiAoIXF1ZXN0aW9uPy50cmltKCkpIHtcbiAgICAgICAgICBlcnJvcnMucHVzaChgUm93ICR7aW5kZXggKyAyfTogUXVlc3Rpb24gaXMgcmVxdWlyZWRgKVxuICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFvcHQxPy50cmltKCkgfHwgIW9wdDI/LnRyaW0oKSB8fCAhb3B0Mz8udHJpbSgpIHx8ICFvcHQ0Py50cmltKCkpIHtcbiAgICAgICAgICBlcnJvcnMucHVzaChgUm93ICR7aW5kZXggKyAyfTogQWxsIDQgb3B0aW9ucyBhcmUgcmVxdWlyZWRgKVxuICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgY29ycmVjdEFuc3dlck51bSA9IHBhcnNlSW50KGNvcnJlY3RBbnN3ZXIpIC0gMSAvLyBDb252ZXJ0IDEtYmFzZWQgdG8gMC1iYXNlZFxuICAgICAgICBpZiAoaXNOYU4oY29ycmVjdEFuc3dlck51bSkgfHwgY29ycmVjdEFuc3dlck51bSA8IDAgfHwgY29ycmVjdEFuc3dlck51bSA+IDMpIHtcbiAgICAgICAgICBlcnJvcnMucHVzaChgUm93ICR7aW5kZXggKyAyfTogQ29ycmVjdCBhbnN3ZXIgbXVzdCBiZSAxLCAyLCAzLCBvciA0YClcbiAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghY2F0ZWdvcnk/LnRyaW0oKSkge1xuICAgICAgICAgIGVycm9ycy5wdXNoKGBSb3cgJHtpbmRleCArIDJ9OiBDYXRlZ29yeSBpcyByZXF1aXJlZGApXG4gICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIVsnYmVnaW5uZXInLCAnaW50ZXJtZWRpYXRlJywgJ2FkdmFuY2VkJ10uaW5jbHVkZXMoZGlmZmljdWx0eSkpIHtcbiAgICAgICAgICBlcnJvcnMucHVzaChgUm93ICR7aW5kZXggKyAyfTogRGlmZmljdWx0eSBtdXN0IGJlICdiZWdpbm5lcicsICdpbnRlcm1lZGlhdGUnLCBvciAnYWR2YW5jZWQnYClcbiAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghWydyZWd1bGFyJywgJ2JvbnVzJ10uaW5jbHVkZXModHlwZSkpIHtcbiAgICAgICAgICBlcnJvcnMucHVzaChgUm93ICR7aW5kZXggKyAyfTogVHlwZSBtdXN0IGJlICdyZWd1bGFyJyBvciAnYm9udXMnYClcbiAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHF1ZXN0aW9uRGF0YTogUGFydGlhbDxRdWl6UXVlc3Rpb24+ID0ge1xuICAgICAgICAgIGlkOiBpZCB8fCBgaW1wb3J0ZWRfJHtEYXRlLm5vdygpfV8ke2luZGV4fWAsXG4gICAgICAgICAgcXVlc3Rpb246IHF1ZXN0aW9uLnRyaW0oKSxcbiAgICAgICAgICBvcHRpb25zOiBbb3B0MS50cmltKCksIG9wdDIudHJpbSgpLCBvcHQzLnRyaW0oKSwgb3B0NC50cmltKCldLFxuICAgICAgICAgIGNvcnJlY3RBbnN3ZXI6IGNvcnJlY3RBbnN3ZXJOdW0sXG4gICAgICAgICAgY2F0ZWdvcnk6IGNhdGVnb3J5LnRyaW0oKSxcbiAgICAgICAgICBkaWZmaWN1bHR5OiBkaWZmaWN1bHR5IGFzICdiZWdpbm5lcicgfCAnaW50ZXJtZWRpYXRlJyB8ICdhZHZhbmNlZCcsXG4gICAgICAgICAgdHlwZTogdHlwZSBhcyAncmVndWxhcicgfCAnYm9udXMnLFxuICAgICAgICAgIGZ1bkZhY3Q6IGZ1bkZhY3Q/LnRyaW0oKSB8fCB1bmRlZmluZWQsXG4gICAgICAgICAgdGFnczogdGFncyA/IHRhZ3Muc3BsaXQoJzsnKS5tYXAodGFnID0+IHRhZy50cmltKCkpLmZpbHRlcihCb29sZWFuKSA6IFtdLFxuICAgICAgICAgIGNyZWF0ZWRBdDogY3JlYXRlZEF0ID8gbmV3IERhdGUoY3JlYXRlZEF0KS5nZXRUaW1lKCkgOiBEYXRlLm5vdygpLFxuICAgICAgICAgIHVwZGF0ZWRBdDogdXBkYXRlZEF0ID8gbmV3IERhdGUodXBkYXRlZEF0KS5nZXRUaW1lKCkgOiBEYXRlLm5vdygpXG4gICAgICAgIH1cblxuICAgICAgICBxdWVzdGlvbnMucHVzaChxdWVzdGlvbkRhdGEpXG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBlcnJvcnMucHVzaChgUm93ICR7aW5kZXggKyAyfTogJHtlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6ICdQYXJzZSBlcnJvcid9YClcbiAgICAgIH1cbiAgICB9KVxuXG4gICAgcmV0dXJuIHsgcXVlc3Rpb25zLCBlcnJvcnMgfVxuICB9XG5cbiAgLy8gSGVscGVyIHRvIHBhcnNlIENTViBsaW5lIHdpdGggcHJvcGVyIHF1b3RlIGhhbmRsaW5nXG4gIHByaXZhdGUgcGFyc2VDU1ZMaW5lKGxpbmU6IHN0cmluZyk6IHN0cmluZ1tdIHtcbiAgICBjb25zdCByZXN1bHQ6IHN0cmluZ1tdID0gW11cbiAgICBsZXQgY3VycmVudCA9ICcnXG4gICAgbGV0IGluUXVvdGVzID0gZmFsc2VcbiAgICBsZXQgaSA9IDBcblxuICAgIHdoaWxlIChpIDwgbGluZS5sZW5ndGgpIHtcbiAgICAgIGNvbnN0IGNoYXIgPSBsaW5lW2ldXG5cbiAgICAgIGlmIChjaGFyID09PSAnXCInKSB7XG4gICAgICAgIGlmIChpblF1b3RlcyAmJiBsaW5lW2kgKyAxXSA9PT0gJ1wiJykge1xuICAgICAgICAgIC8vIEVzY2FwZWQgcXVvdGVcbiAgICAgICAgICBjdXJyZW50ICs9ICdcIidcbiAgICAgICAgICBpICs9IDJcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBUb2dnbGUgcXVvdGUgc3RhdGVcbiAgICAgICAgICBpblF1b3RlcyA9ICFpblF1b3Rlc1xuICAgICAgICAgIGkrK1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGNoYXIgPT09ICcsJyAmJiAhaW5RdW90ZXMpIHtcbiAgICAgICAgLy8gRW5kIG9mIGZpZWxkXG4gICAgICAgIHJlc3VsdC5wdXNoKGN1cnJlbnQpXG4gICAgICAgIGN1cnJlbnQgPSAnJ1xuICAgICAgICBpKytcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGN1cnJlbnQgKz0gY2hhclxuICAgICAgICBpKytcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXN1bHQucHVzaChjdXJyZW50KSAvLyBBZGQgbGFzdCBmaWVsZFxuICAgIHJldHVybiByZXN1bHRcbiAgfVxuXG4gIC8vIEltcG9ydCBmcm9tIENTVlxuICBpbXBvcnRGcm9tQ1NWKGNzdkNvbnRlbnQ6IHN0cmluZyk6IEJ1bGtPcGVyYXRpb25SZXN1bHQge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCB7IHF1ZXN0aW9ucywgZXJyb3JzIH0gPSB0aGlzLnBhcnNlQ1NWKGNzdkNvbnRlbnQpXG5cbiAgICAgIGlmIChlcnJvcnMubGVuZ3RoID4gMCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICAgIHByb2Nlc3NlZENvdW50OiAwLFxuICAgICAgICAgIGVycm9yQ291bnQ6IGVycm9ycy5sZW5ndGgsXG4gICAgICAgICAgZXJyb3JzXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgbGV0IHN1Y2Nlc3NDb3VudCA9IDBcbiAgICAgIGNvbnN0IGltcG9ydEVycm9yczogc3RyaW5nW10gPSBbXVxuXG4gICAgICBxdWVzdGlvbnMuZm9yRWFjaCgocXVlc3Rpb25EYXRhLCBpbmRleCkgPT4ge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGNvbnN0IGZ1bGxRdWVzdGlvbjogUXVpelF1ZXN0aW9uID0ge1xuICAgICAgICAgICAgaWQ6IHF1ZXN0aW9uRGF0YS5pZCEsXG4gICAgICAgICAgICBxdWVzdGlvbjogcXVlc3Rpb25EYXRhLnF1ZXN0aW9uISxcbiAgICAgICAgICAgIG9wdGlvbnM6IHF1ZXN0aW9uRGF0YS5vcHRpb25zISxcbiAgICAgICAgICAgIGNvcnJlY3RBbnN3ZXI6IHF1ZXN0aW9uRGF0YS5jb3JyZWN0QW5zd2VyISxcbiAgICAgICAgICAgIGNhdGVnb3J5OiBxdWVzdGlvbkRhdGEuY2F0ZWdvcnkhLFxuICAgICAgICAgICAgZGlmZmljdWx0eTogcXVlc3Rpb25EYXRhLmRpZmZpY3VsdHkhLFxuICAgICAgICAgICAgdHlwZTogcXVlc3Rpb25EYXRhLnR5cGUhLFxuICAgICAgICAgICAgZnVuRmFjdDogcXVlc3Rpb25EYXRhLmZ1bkZhY3QsXG4gICAgICAgICAgICB0YWdzOiBxdWVzdGlvbkRhdGEudGFncyB8fCBbXSxcbiAgICAgICAgICAgIGNyZWF0ZWRBdDogcXVlc3Rpb25EYXRhLmNyZWF0ZWRBdCEsXG4gICAgICAgICAgICB1cGRhdGVkQXQ6IHF1ZXN0aW9uRGF0YS51cGRhdGVkQXQhXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gVmFsaWRhdGUgdGhlIGNvbXBsZXRlIHF1ZXN0aW9uXG4gICAgICAgICAgY29uc3QgdmFsaWRhdGlvbiA9IHRoaXMudmFsaWRhdGVRdWVzdGlvbihmdWxsUXVlc3Rpb24pXG4gICAgICAgICAgaWYgKCF2YWxpZGF0aW9uLmlzVmFsaWQpIHtcbiAgICAgICAgICAgIGltcG9ydEVycm9ycy5wdXNoKGBRdWVzdGlvbiAke2luZGV4ICsgMX06ICR7dmFsaWRhdGlvbi5lcnJvcnMuam9pbignLCAnKX1gKVxuICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGhpcy5zYXZlUXVlc3Rpb24oZnVsbFF1ZXN0aW9uKVxuICAgICAgICAgIHN1Y2Nlc3NDb3VudCsrXG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgaW1wb3J0RXJyb3JzLnB1c2goYFF1ZXN0aW9uICR7aW5kZXggKyAxfTogJHtlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6ICdTYXZlIGVycm9yJ31gKVxuICAgICAgICB9XG4gICAgICB9KVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBzdWNjZXNzOiBpbXBvcnRFcnJvcnMubGVuZ3RoID09PSAwLFxuICAgICAgICBwcm9jZXNzZWRDb3VudDogc3VjY2Vzc0NvdW50LFxuICAgICAgICBlcnJvckNvdW50OiBpbXBvcnRFcnJvcnMubGVuZ3RoLFxuICAgICAgICBlcnJvcnM6IGltcG9ydEVycm9yc1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgcHJvY2Vzc2VkQ291bnQ6IDAsXG4gICAgICAgIGVycm9yQ291bnQ6IDEsXG4gICAgICAgIGVycm9yczogW2Vycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogJ0ltcG9ydCBmYWlsZWQnXVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG4vLyBFeHBvcnQgc2luZ2xldG9uIGluc3RhbmNlXG5leHBvcnQgY29uc3QgcXVpekRhdGFNYW5hZ2VyID0gUXVpekRhdGFNYW5hZ2VyLmdldEluc3RhbmNlKClcbiJdLCJuYW1lcyI6WyJRVUlaX1NUT1JBR0VfS0VZUyIsIkRFRkFVTFRfQ0FURUdPUklFUyIsIlZBTElEQVRJT05fUlVMRVMiLCJRVUVTVElPTl9NSU5fTEVOR1RIIiwiUVVFU1RJT05fTUFYX0xFTkdUSCIsIk9QVElPTl9NSU5fTEVOR1RIIiwiT1BUSU9OX01BWF9MRU5HVEgiLCJNSU5fT1BUSU9OUyIsIk1BWF9PUFRJT05TIiwiTUFYX0JVTEtfT1BFUkFUSU9OUyIsIk1BWF9GSUxFX1NJWkUiLCJBVVRPX1NBVkVfSU5URVJWQUwiLCJRdWl6RGF0YUVycm9yIiwiRXJyb3IiLCJtZXNzYWdlIiwiY29kZSIsIm5hbWUiLCJRdWl6RGF0YU1hbmFnZXIiLCJnZXRJbnN0YW5jZSIsImluc3RhbmNlIiwic2FmZUdldEl0ZW0iLCJrZXkiLCJsb2NhbFN0b3JhZ2UiLCJnZXRJdGVtIiwiZXJyb3IiLCJjb25zb2xlIiwic2FmZVNldEl0ZW0iLCJ2YWx1ZSIsInNldEl0ZW0iLCJET01FeGNlcHRpb24iLCJnZXRRdWVzdGlvbnMiLCJkYXRhIiwiUVVFU1RJT05TIiwiaW5pdGlhbGl6ZVdpdGhTYW1wbGVEYXRhIiwicXVlc3Rpb25zIiwiSlNPTiIsInBhcnNlIiwiQXJyYXkiLCJpc0FycmF5IiwiZ2V0RmlsdGVyZWRRdWVzdGlvbnMiLCJmaWx0ZXJzIiwiZmlsdGVyIiwicXVlc3Rpb24iLCJjYXRlZ29yeSIsImRpZmZpY3VsdHkiLCJ0eXBlIiwic2VjdGlvbiIsInN1YmNhdGVnb3J5IiwidGFncyIsInNvbWUiLCJ0YWciLCJpbmNsdWRlcyIsImdldFF1ZXN0aW9uc0J5U2VjdGlvbiIsImdldFF1ZXN0aW9uc0J5Q2F0ZWdvcnlBbmRTZWN0aW9uIiwic2F2ZVF1ZXN0aW9uIiwidmFsaWRhdGVRdWVzdGlvbiIsIm5vdyIsIkRhdGUiLCJuZXdRdWVzdGlvbiIsImlkIiwiZ2VuZXJhdGVJZCIsImNyZWF0ZWRBdCIsInVwZGF0ZWRBdCIsInB1c2giLCJzYXZlUXVlc3Rpb25zIiwidXBkYXRlUXVlc3Rpb24iLCJ1cGRhdGVzIiwiaW5kZXgiLCJmaW5kSW5kZXgiLCJxIiwidXBkYXRlZFF1ZXN0aW9uIiwiZGVsZXRlUXVlc3Rpb24iLCJmaWx0ZXJlZFF1ZXN0aW9ucyIsImxlbmd0aCIsImJ1bGtEZWxldGUiLCJpZHMiLCJpbml0aWFsQ291bnQiLCJkZWxldGVkQ291bnQiLCJzdWNjZXNzIiwicHJvY2Vzc2VkQ291bnQiLCJlcnJvckNvdW50IiwiZXJyb3JzIiwic2VhcmNoUXVlc3Rpb25zIiwic2VhcmNoVGV4dCIsInNlYXJjaExvd2VyIiwidG9Mb3dlckNhc2UiLCJnZXRDYXRlZ29yaWVzIiwiY2F0ZWdvcnlDb3VudHMiLCJyZWR1Y2UiLCJhY2MiLCJtYXAiLCJxdWVzdGlvbkNvdW50Iiwic2F2ZURyYWZ0IiwiZHJhZnQiLCJkcmFmdHMiLCJnZXREcmFmdHMiLCJleGlzdGluZ0luZGV4IiwiZCIsImxhc3RTYXZlZCIsIkRSQUZUUyIsInN0cmluZ2lmeSIsImRlbGV0ZURyYWZ0IiwiZ2V0U2V0dGluZ3MiLCJTRVRUSU5HUyIsImdldERlZmF1bHRTZXR0aW5ncyIsInNhdmVTZXR0aW5ncyIsInNldHRpbmdzIiwiY3VycmVudFNldHRpbmdzIiwidXBkYXRlZFNldHRpbmdzIiwicGFnZVNpemUiLCJzb3J0QnkiLCJzb3J0T3JkZXIiLCJzZWxlY3RlZFF1ZXN0aW9ucyIsIm9wdGlvbnMiLCJmb3JFYWNoIiwib3B0aW9uIiwidW5pcXVlT3B0aW9ucyIsIlNldCIsIm9wdCIsInRyaW0iLCJzaXplIiwiY29ycmVjdEFuc3dlciIsInZhbGlkQ2F0ZWdvcmllcyIsImMiLCJNYXRoIiwicmFuZG9tIiwidG9TdHJpbmciLCJzdWJzdHIiLCJleHBvcnRUb0NTViIsInF1ZXN0aW9uc1RvRXhwb3J0IiwiaGVhZGVycyIsImNzdlJvd3MiLCJqb2luIiwicmVwbGFjZSIsImZ1bkZhY3QiLCJ0b0lTT1N0cmluZyIsImltcG9ydEZyb21DU1YiLCJjc3ZDb250ZW50IiwibGluZXMiLCJzcGxpdCIsImxpbmUiLCJoIiwiZGF0YUxpbmVzIiwic2xpY2UiLCJyZXN1bHRzIiwidmFsaWRRdWVzdGlvbnMiLCJleGlzdGluZ1F1ZXN0aW9ucyIsImkiLCJ2YWx1ZXMiLCJwYXJzZUNTVkxpbmUiLCJwYXJzZUludCIsInVuZGVmaW5lZCIsInQiLCJnZXRUaW1lIiwiYWxsUXVlc3Rpb25zIiwicmVzdWx0IiwiY3VycmVudCIsImluUXVvdGVzIiwiY2hhciIsInNob3VsZEltcG9ydEV4aXN0aW5nUXVlc3Rpb25zIiwiaW1wb3J0QWxsRXhpc3RpbmdRdWVzdGlvbnMiLCJzYW1wbGVRdWVzdGlvbnMiLCJoYXNJbXBvcnRlZCIsIm9uYm9hcmRpbmdRdWVzdGlvbnMiLCJpbXBvcnRPbmJvYXJkaW5nUXVlc3Rpb25zIiwiaG9tZXBhZ2VRdWVzdGlvbnMiLCJpbXBvcnRIb21lcGFnZVF1ZXN0aW9ucyIsImNhdGVnb3J5UXVlc3Rpb25zIiwiaW1wb3J0Q2F0ZWdvcnlRdWVzdGlvbnMiLCJsb2ciLCJyZXdhcmRDb2lucyIsInNhbXBsZUNhdGVnb3J5UXVlc3Rpb25zIiwiZm9yY2VSZWltcG9ydFF1ZXN0aW9ucyIsImltcG9ydGVkUXVlc3Rpb25zIiwiY3JlYXRlQmFja3VwIiwiYmFja3VwIiwidGltZXN0YW1wIiwidmVyc2lvbiIsInJlc3RvcmVGcm9tQmFja3VwIiwiYmFja3VwRGF0YSIsImN1cnJlbnRCYWNrdXAiLCJCQUNLVVAiLCJzdGFydEF1dG9TYXZlIiwiZHJhZnRJZCIsImdldERyYWZ0RGF0YSIsInN0b3BBdXRvU2F2ZSIsImF1dG9TYXZlVGltZXIiLCJzZXRJbnRlcnZhbCIsImRyYWZ0RGF0YSIsImNsZWFySW50ZXJ2YWwiLCJyb3ciLCJkb3dubG9hZENTViIsImJsb2IiLCJCbG9iIiwibGluayIsImRvY3VtZW50IiwiY3JlYXRlRWxlbWVudCIsImRvd25sb2FkIiwidXJsIiwiVVJMIiwiY3JlYXRlT2JqZWN0VVJMIiwic2V0QXR0cmlidXRlIiwic3R5bGUiLCJ2aXNpYmlsaXR5IiwiYm9keSIsImFwcGVuZENoaWxkIiwiY2xpY2siLCJyZW1vdmVDaGlsZCIsInJldm9rZU9iamVjdFVSTCIsInBhcnNlQ1NWIiwib3B0MSIsIm9wdDIiLCJvcHQzIiwib3B0NCIsImNvcnJlY3RBbnN3ZXJOdW0iLCJpc05hTiIsInF1ZXN0aW9uRGF0YSIsIkJvb2xlYW4iLCJzdWNjZXNzQ291bnQiLCJpbXBvcnRFcnJvcnMiLCJmdWxsUXVlc3Rpb24iLCJ2YWxpZGF0aW9uIiwiaXNWYWxpZCIsInF1aXpEYXRhTWFuYWdlciJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/utils/quizDataManager.ts\n"));

/***/ })

});