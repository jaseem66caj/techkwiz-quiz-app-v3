"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./src/utils/quizDataManager.ts":
/*!**************************************!*\
  !*** ./src/utils/quizDataManager.ts ***!
  \**************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   QuizDataError: () => (/* binding */ QuizDataError),\n/* harmony export */   VALIDATION_RULES: () => (/* binding */ VALIDATION_RULES),\n/* harmony export */   quizDataManager: () => (/* binding */ quizDataManager)\n/* harmony export */ });\n/* harmony import */ var _types_admin__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/types/admin */ \"(app-pages-browser)/./src/types/admin.ts\");\n\n// Data validation schemas\nconst VALIDATION_RULES = {\n    QUESTION_MIN_LENGTH: 10,\n    QUESTION_MAX_LENGTH: 500,\n    OPTION_MIN_LENGTH: 1,\n    OPTION_MAX_LENGTH: 100,\n    MIN_OPTIONS: 4,\n    MAX_OPTIONS: 4,\n    MAX_BULK_OPERATIONS: 50,\n    MAX_FILE_SIZE: 5 * 1024 * 1024,\n    AUTO_SAVE_INTERVAL: 30000 // 30 seconds\n};\n// Error types\nclass QuizDataError extends Error {\n    constructor(message, code){\n        super(message), this.code = code;\n        this.name = 'QuizDataError';\n    }\n}\n// Utility functions for localStorage operations\nclass QuizDataManager {\n    static getInstance() {\n        if (!QuizDataManager.instance) {\n            QuizDataManager.instance = new QuizDataManager();\n        }\n        return QuizDataManager.instance;\n    }\n    // Safe localStorage operations with error handling\n    safeGetItem(key) {\n        // Return null if not on client side\n        if (false) {}\n        try {\n            return localStorage.getItem(key);\n        } catch (error) {\n            console.error(\"Error reading from localStorage key \".concat(key, \":\"), error);\n            return null;\n        }\n    }\n    safeSetItem(key, value) {\n        // Return false if not on client side\n        if (false) {}\n        try {\n            localStorage.setItem(key, value);\n            return true;\n        } catch (error) {\n            console.error(\"Error writing to localStorage key \".concat(key, \":\"), error);\n            if (error instanceof DOMException && error.code === 22) {\n                throw new QuizDataError('Storage quota exceeded. Please clear some data.', 'QUOTA_EXCEEDED');\n            }\n            return false;\n        }\n    }\n    // Question CRUD operations\n    getQuestions() {\n        const data = this.safeGetItem(_types_admin__WEBPACK_IMPORTED_MODULE_0__.QUIZ_STORAGE_KEYS.QUESTIONS);\n        if (!data) return this.initializeWithSampleData();\n        try {\n            const questions = JSON.parse(data);\n            return Array.isArray(questions) ? questions : [];\n        } catch (error) {\n            console.error('Error parsing questions data:', error);\n            return this.initializeWithSampleData();\n        }\n    }\n    // Get questions with filtering support\n    getFilteredQuestions(filters) {\n        const questions = this.getQuestions();\n        if (!filters) return questions;\n        return questions.filter((question)=>{\n            if (filters.category && question.category !== filters.category) return false;\n            if (filters.difficulty && question.difficulty !== filters.difficulty) return false;\n            if (filters.type && question.type !== filters.type) return false;\n            if (filters.section && question.section !== filters.section) return false;\n            if (filters.subcategory && question.subcategory !== filters.subcategory) return false;\n            if (filters.tags && !filters.tags.some((tag)=>{\n                var _question_tags;\n                return (_question_tags = question.tags) === null || _question_tags === void 0 ? void 0 : _question_tags.includes(tag);\n            })) return false;\n            return true;\n        });\n    }\n    // Get questions by section\n    getQuestionsBySection(section) {\n        return this.getFilteredQuestions({\n            section\n        });\n    }\n    // Get questions by category and section\n    getQuestionsByCategoryAndSection(category, section) {\n        return this.getFilteredQuestions({\n            category,\n            section\n        });\n    }\n    saveQuestion(question) {\n        this.validateQuestion(question);\n        const questions = this.getQuestions();\n        const now = Date.now();\n        const newQuestion = {\n            ...question,\n            id: this.generateId(),\n            createdAt: now,\n            updatedAt: now\n        };\n        questions.push(newQuestion);\n        this.saveQuestions(questions);\n        return newQuestion;\n    }\n    updateQuestion(id, updates) {\n        const questions = this.getQuestions();\n        const index = questions.findIndex((q)=>q.id === id);\n        if (index === -1) {\n            throw new QuizDataError(\"Question with id \".concat(id, \" not found\"), 'NOT_FOUND');\n        }\n        const updatedQuestion = {\n            ...questions[index],\n            ...updates,\n            updatedAt: Date.now()\n        };\n        this.validateQuestion(updatedQuestion);\n        questions[index] = updatedQuestion;\n        this.saveQuestions(questions);\n        return updatedQuestion;\n    }\n    deleteQuestion(id) {\n        const questions = this.getQuestions();\n        const filteredQuestions = questions.filter((q)=>q.id !== id);\n        if (filteredQuestions.length === questions.length) {\n            throw new QuizDataError(\"Question with id \".concat(id, \" not found\"), 'NOT_FOUND');\n        }\n        this.saveQuestions(filteredQuestions);\n        return true;\n    }\n    bulkDelete(ids) {\n        if (ids.length > VALIDATION_RULES.MAX_BULK_OPERATIONS) {\n            throw new QuizDataError(\"Cannot delete more than \".concat(VALIDATION_RULES.MAX_BULK_OPERATIONS, \" questions at once\"), 'BULK_LIMIT_EXCEEDED');\n        }\n        const questions = this.getQuestions();\n        const initialCount = questions.length;\n        const filteredQuestions = questions.filter((q)=>!ids.includes(q.id));\n        const deletedCount = initialCount - filteredQuestions.length;\n        this.saveQuestions(filteredQuestions);\n        return {\n            success: true,\n            processedCount: deletedCount,\n            errorCount: ids.length - deletedCount,\n            errors: ids.length > deletedCount ? [\n                'Some questions were not found'\n            ] : []\n        };\n    }\n    // Search and filter operations\n    searchQuestions(filters) {\n        const questions = this.getQuestions();\n        return questions.filter((question)=>{\n            // Text search\n            if (filters.searchText) {\n                const searchLower = filters.searchText.toLowerCase();\n                if (!question.question.toLowerCase().includes(searchLower)) {\n                    return false;\n                }\n            }\n            // Category filter\n            if (filters.category !== 'all' && question.category !== filters.category) {\n                return false;\n            }\n            // Difficulty filter\n            if (filters.difficulty !== 'all' && question.difficulty !== filters.difficulty) {\n                return false;\n            }\n            // Type filter\n            if (filters.type !== 'all' && question.type !== filters.type) {\n                return false;\n            }\n            // Section filter\n            if (filters.section !== 'all' && question.section !== filters.section) {\n                return false;\n            }\n            // Subcategory filter\n            if (filters.subcategory !== 'all' && question.subcategory !== filters.subcategory) {\n                return false;\n            }\n            return true;\n        });\n    }\n    // Categories management\n    getCategories() {\n        const questions = this.getQuestions();\n        const categoryCounts = questions.reduce((acc, question)=>{\n            acc[question.category] = (acc[question.category] || 0) + 1;\n            return acc;\n        }, {});\n        return _types_admin__WEBPACK_IMPORTED_MODULE_0__.DEFAULT_CATEGORIES.map((category)=>({\n                ...category,\n                questionCount: categoryCounts[category.id] || 0\n            }));\n    }\n    // Draft management\n    saveDraft(draft) {\n        const drafts = this.getDrafts();\n        const existingIndex = drafts.findIndex((d)=>d.id === draft.id);\n        if (existingIndex >= 0) {\n            drafts[existingIndex] = {\n                ...draft,\n                lastSaved: Date.now()\n            };\n        } else {\n            drafts.push({\n                ...draft,\n                lastSaved: Date.now()\n            });\n        }\n        this.safeSetItem(_types_admin__WEBPACK_IMPORTED_MODULE_0__.QUIZ_STORAGE_KEYS.DRAFTS, JSON.stringify(drafts));\n    }\n    getDrafts() {\n        const data = this.safeGetItem(_types_admin__WEBPACK_IMPORTED_MODULE_0__.QUIZ_STORAGE_KEYS.DRAFTS);\n        if (!data) return [];\n        try {\n            return JSON.parse(data);\n        } catch (error) {\n            console.error('Error parsing drafts data:', error);\n            return [];\n        }\n    }\n    deleteDraft(id) {\n        const drafts = this.getDrafts().filter((d)=>d.id !== id);\n        this.safeSetItem(_types_admin__WEBPACK_IMPORTED_MODULE_0__.QUIZ_STORAGE_KEYS.DRAFTS, JSON.stringify(drafts));\n    }\n    // Settings management\n    getSettings() {\n        const data = this.safeGetItem(_types_admin__WEBPACK_IMPORTED_MODULE_0__.QUIZ_STORAGE_KEYS.SETTINGS);\n        if (!data) return this.getDefaultSettings();\n        try {\n            return {\n                ...this.getDefaultSettings(),\n                ...JSON.parse(data)\n            };\n        } catch (error) {\n            console.error('Error parsing settings data:', error);\n            return this.getDefaultSettings();\n        }\n    }\n    saveSettings(settings) {\n        const currentSettings = this.getSettings();\n        const updatedSettings = {\n            ...currentSettings,\n            ...settings\n        };\n        this.safeSetItem(_types_admin__WEBPACK_IMPORTED_MODULE_0__.QUIZ_STORAGE_KEYS.SETTINGS, JSON.stringify(updatedSettings));\n    }\n    getDefaultSettings() {\n        return {\n            pageSize: 10,\n            sortBy: 'updatedAt',\n            sortOrder: 'desc',\n            filters: {\n                searchText: '',\n                category: 'all',\n                difficulty: 'all',\n                type: 'all'\n            },\n            selectedQuestions: []\n        };\n    }\n    // Validation\n    validateQuestion(question) {\n        if (!question.question || question.question.length < VALIDATION_RULES.QUESTION_MIN_LENGTH) {\n            throw new QuizDataError(\"Question must be at least \".concat(VALIDATION_RULES.QUESTION_MIN_LENGTH, \" characters long\"), 'INVALID_QUESTION_LENGTH');\n        }\n        if (question.question.length > VALIDATION_RULES.QUESTION_MAX_LENGTH) {\n            throw new QuizDataError(\"Question must be no more than \".concat(VALIDATION_RULES.QUESTION_MAX_LENGTH, \" characters long\"), 'INVALID_QUESTION_LENGTH');\n        }\n        if (!question.options || question.options.length !== VALIDATION_RULES.MIN_OPTIONS) {\n            throw new QuizDataError(\"Question must have exactly \".concat(VALIDATION_RULES.MIN_OPTIONS, \" options\"), 'INVALID_OPTIONS_COUNT');\n        }\n        // Validate each option\n        question.options.forEach((option, index)=>{\n            if (!option || option.length < VALIDATION_RULES.OPTION_MIN_LENGTH) {\n                throw new QuizDataError(\"Option \".concat(index + 1, \" must be at least \").concat(VALIDATION_RULES.OPTION_MIN_LENGTH, \" character long\"), 'INVALID_OPTION_LENGTH');\n            }\n            if (option.length > VALIDATION_RULES.OPTION_MAX_LENGTH) {\n                throw new QuizDataError(\"Option \".concat(index + 1, \" must be no more than \").concat(VALIDATION_RULES.OPTION_MAX_LENGTH, \" characters long\"), 'INVALID_OPTION_LENGTH');\n            }\n        });\n        // Check for duplicate options\n        const uniqueOptions = new Set(question.options.map((opt)=>opt.toLowerCase().trim()));\n        if (uniqueOptions.size !== question.options.length) {\n            throw new QuizDataError('All options must be unique', 'DUPLICATE_OPTIONS');\n        }\n        // Validate correct answer\n        if (typeof question.correctAnswer !== 'number' || question.correctAnswer < 0 || question.correctAnswer >= question.options.length) {\n            throw new QuizDataError('Invalid correct answer selection', 'INVALID_CORRECT_ANSWER');\n        }\n        // Validate category\n        const validCategories = _types_admin__WEBPACK_IMPORTED_MODULE_0__.DEFAULT_CATEGORIES.map((c)=>c.id);\n        if (!question.category || !validCategories.includes(question.category)) {\n            throw new QuizDataError('Invalid category selection', 'INVALID_CATEGORY');\n        }\n    }\n    // Utility methods\n    saveQuestions(questions) {\n        this.safeSetItem(_types_admin__WEBPACK_IMPORTED_MODULE_0__.QUIZ_STORAGE_KEYS.QUESTIONS, JSON.stringify(questions));\n    }\n    generateId() {\n        return \"q_\".concat(Date.now(), \"_\").concat(Math.random().toString(36).substr(2, 9));\n    }\n    // CSV Export/Import functionality\n    exportToCSV(questions) {\n        const questionsToExport = questions || this.getQuestions();\n        const headers = [\n            'ID',\n            'Question',\n            'Option 1',\n            'Option 2',\n            'Option 3',\n            'Option 4',\n            'Correct Answer',\n            'Category',\n            'Difficulty',\n            'Type',\n            'Fun Fact',\n            'Tags',\n            'Created At',\n            'Updated At'\n        ];\n        const csvRows = [\n            headers.join(','),\n            ...questionsToExport.map((q)=>[\n                    q.id,\n                    '\"'.concat(q.question.replace(/\"/g, '\"\"'), '\"'),\n                    '\"'.concat(q.options[0].replace(/\"/g, '\"\"'), '\"'),\n                    '\"'.concat(q.options[1].replace(/\"/g, '\"\"'), '\"'),\n                    '\"'.concat(q.options[2].replace(/\"/g, '\"\"'), '\"'),\n                    '\"'.concat(q.options[3].replace(/\"/g, '\"\"'), '\"'),\n                    q.correctAnswer + 1,\n                    q.category,\n                    q.difficulty,\n                    q.type,\n                    '\"'.concat((q.funFact || '').replace(/\"/g, '\"\"'), '\"'),\n                    '\"'.concat((q.tags || []).join(';'), '\"'),\n                    new Date(q.createdAt).toISOString(),\n                    new Date(q.updatedAt).toISOString()\n                ].join(','))\n        ];\n        // Add UTF-8 BOM for Excel compatibility\n        return '\\uFEFF' + csvRows.join('\\n');\n    }\n    async importFromCSV(csvContent) {\n        const lines = csvContent.split('\\n').filter((line)=>line.trim());\n        if (lines.length < 2) {\n            throw new QuizDataError('CSV file must contain at least a header and one data row', 'INVALID_CSV_FORMAT');\n        }\n        const headers = lines[0].split(',').map((h)=>h.trim().replace(/\"/g, ''));\n        const dataLines = lines.slice(1);\n        const results = {\n            success: true,\n            processedCount: 0,\n            errorCount: 0,\n            errors: []\n        };\n        const validQuestions = [];\n        const existingQuestions = this.getQuestions();\n        for(let i = 0; i < dataLines.length; i++){\n            try {\n                const values = this.parseCSVLine(dataLines[i]);\n                if (values.length < 8) {\n                    results.errors.push(\"Line \".concat(i + 2, \": Insufficient data columns\"));\n                    results.errorCount++;\n                    continue;\n                }\n                const question = {\n                    id: values[0] || this.generateId(),\n                    question: values[1],\n                    options: [\n                        values[2],\n                        values[3],\n                        values[4],\n                        values[5]\n                    ],\n                    correctAnswer: parseInt(values[6]) - 1,\n                    category: values[7],\n                    difficulty: values[8],\n                    type: values[9] || 'regular',\n                    funFact: values[10] || undefined,\n                    tags: values[11] ? values[11].split(';').filter((t)=>t.trim()) : undefined,\n                    createdAt: values[12] ? new Date(values[12]).getTime() : Date.now(),\n                    updatedAt: values[13] ? new Date(values[13]).getTime() : Date.now()\n                };\n                // Validate the question\n                this.validateQuestion(question);\n                // Check for duplicates\n                const existingIndex = existingQuestions.findIndex((q)=>q.id === question.id);\n                if (existingIndex >= 0) {\n                    // Update existing question\n                    existingQuestions[existingIndex] = question;\n                } else {\n                    validQuestions.push(question);\n                }\n                results.processedCount++;\n            } catch (error) {\n                results.errors.push(\"Line \".concat(i + 2, \": \").concat(error instanceof Error ? error.message : 'Unknown error'));\n                results.errorCount++;\n            }\n        }\n        // Save all valid questions\n        if (validQuestions.length > 0) {\n            const allQuestions = [\n                ...existingQuestions,\n                ...validQuestions\n            ];\n            this.saveQuestions(allQuestions);\n        }\n        results.success = results.errorCount === 0;\n        return results;\n    }\n    parseCSVLine(line) {\n        const result = [];\n        let current = '';\n        let inQuotes = false;\n        for(let i = 0; i < line.length; i++){\n            const char = line[i];\n            if (char === '\"') {\n                if (inQuotes && line[i + 1] === '\"') {\n                    current += '\"';\n                    i++; // Skip next quote\n                } else {\n                    inQuotes = !inQuotes;\n                }\n            } else if (char === ',' && !inQuotes) {\n                result.push(current.trim());\n                current = '';\n            } else {\n                current += char;\n            }\n        }\n        result.push(current.trim());\n        return result;\n    }\n    initializeWithSampleData() {\n        // Check if we should import existing questions\n        if (this.shouldImportExistingQuestions()) {\n            return this.importAllExistingQuestions();\n        }\n        // Initialize with a few sample questions for demonstration\n        const sampleQuestions = [\n            {\n                id: 'sample_1',\n                question: 'Which social media platform is known for its short-form video content and viral dances?',\n                options: [\n                    'Instagram',\n                    'TikTok',\n                    'Twitter',\n                    'Snapchat'\n                ],\n                correctAnswer: 1,\n                category: 'social-media',\n                difficulty: 'beginner',\n                type: 'regular',\n                section: 'homepage',\n                funFact: 'TikTok was originally called Musical.ly before being acquired by ByteDance.',\n                tags: [\n                    'social-media',\n                    'video',\n                    'viral'\n                ],\n                createdAt: Date.now() - 86400000,\n                updatedAt: Date.now() - 86400000\n            }\n        ];\n        this.saveQuestions(sampleQuestions);\n        return sampleQuestions;\n    }\n    // Check if we should import existing questions\n    shouldImportExistingQuestions() {\n        // Only import if localStorage is empty and we're on client side\n        if (false) {}\n        const hasImported = this.safeGetItem('quiz_questions_imported');\n        return !hasImported;\n    }\n    // Import all existing questions from different sources\n    importAllExistingQuestions() {\n        const allQuestions = [];\n        try {\n            // Import onboarding questions\n            const onboardingQuestions = this.importOnboardingQuestions();\n            allQuestions.push(...onboardingQuestions);\n            // Import homepage fallback questions\n            const homepageQuestions = this.importHomepageQuestions();\n            allQuestions.push(...homepageQuestions);\n            // Import category questions from quiz database\n            const categoryQuestions = this.importCategoryQuestions();\n            allQuestions.push(...categoryQuestions);\n            console.log(\"\\uD83D\\uDCCA Imported \".concat(allQuestions.length, \" questions from existing sources\"));\n            // Save all imported questions\n            this.saveQuestions(allQuestions);\n            // Mark as imported\n            this.safeSetItem('quiz_questions_imported', 'true');\n            return allQuestions;\n        } catch (error) {\n            console.error('Error importing existing questions:', error);\n            return [];\n        }\n    }\n    // Import methods for existing questions\n    importOnboardingQuestions() {\n        const onboardingQuestions = [\n            {\n                id: 'onboard-1',\n                question: \"Which tech company created the iPhone?\",\n                options: [\n                    \"Apple ðŸŽ\",\n                    \"Google ðŸ”\",\n                    \"Samsung ðŸ“±\",\n                    \"Microsoft ðŸ’»\"\n                ],\n                correctAnswer: 0,\n                category: 'technology',\n                difficulty: 'beginner',\n                type: 'regular',\n                section: 'onboarding',\n                rewardCoins: 150,\n                funFact: \"The first iPhone was released on June 29, 2007, revolutionizing the smartphone industry.\",\n                tags: [\n                    'technology',\n                    'apple',\n                    'smartphone'\n                ],\n                createdAt: Date.now(),\n                updatedAt: Date.now()\n            },\n            {\n                id: 'onboard-2',\n                question: \"What does 'WWW' stand for?\",\n                options: [\n                    \"World Wide Web ðŸŒ\",\n                    \"World Web Works ðŸ”§\",\n                    \"Web World Wide ðŸŒ\",\n                    \"Wide World Web ðŸ“¡\"\n                ],\n                correctAnswer: 0,\n                category: 'technology',\n                difficulty: 'beginner',\n                type: 'regular',\n                section: 'onboarding',\n                rewardCoins: 150,\n                funFact: \"The World Wide Web was invented by Tim Berners-Lee in 1989 while working at CERN.\",\n                tags: [\n                    'technology',\n                    'internet',\n                    'web'\n                ],\n                createdAt: Date.now(),\n                updatedAt: Date.now()\n            }\n        ];\n        return onboardingQuestions;\n    }\n    importHomepageQuestions() {\n        const homepageQuestions = [\n            {\n                id: 'homepage-1',\n                question: \"Which social media platform is known for short-form videos?\",\n                options: [\n                    \"Instagram\",\n                    \"TikTok\",\n                    \"Twitter\",\n                    \"Snapchat\"\n                ],\n                correctAnswer: 1,\n                category: 'social-media',\n                difficulty: 'beginner',\n                type: 'regular',\n                section: 'homepage',\n                funFact: \"TikTok was originally called Musical.ly!\",\n                tags: [\n                    'social-media',\n                    'video',\n                    'apps'\n                ],\n                createdAt: Date.now(),\n                updatedAt: Date.now()\n            },\n            {\n                id: 'homepage-2',\n                question: \"What does 'AI' stand for?\",\n                options: [\n                    \"Artificial Intelligence\",\n                    \"Automated Internet\",\n                    \"Advanced Interface\",\n                    \"Algorithmic Integration\"\n                ],\n                correctAnswer: 0,\n                category: 'technology',\n                difficulty: 'beginner',\n                type: 'regular',\n                section: 'homepage',\n                funFact: \"The term 'Artificial Intelligence' was first coined in 1956!\",\n                tags: [\n                    'technology',\n                    'ai',\n                    'computing'\n                ],\n                createdAt: Date.now(),\n                updatedAt: Date.now()\n            },\n            {\n                id: 'homepage-3',\n                question: \"Which company created the iPhone?\",\n                options: [\n                    \"Google\",\n                    \"Samsung\",\n                    \"Apple\",\n                    \"Microsoft\"\n                ],\n                correctAnswer: 2,\n                category: 'technology',\n                difficulty: 'beginner',\n                type: 'regular',\n                section: 'homepage',\n                funFact: \"The first iPhone was released in 2007!\",\n                tags: [\n                    'technology',\n                    'apple',\n                    'smartphone'\n                ],\n                createdAt: Date.now(),\n                updatedAt: Date.now()\n            }\n        ];\n        return homepageQuestions;\n    }\n    importCategoryQuestions() {\n        // Import a subset of questions from the quiz database\n        const categoryQuestions = [];\n        try {\n            // Sample category questions - in a real implementation, this would import from the actual quiz database\n            const sampleCategoryQuestions = [\n                {\n                    id: 'cat-tech-1',\n                    question: \"Which programming language is known for its use in web development and has a coffee-related name?\",\n                    options: [\n                        \"Python\",\n                        \"Java\",\n                        \"JavaScript\",\n                        \"C++\"\n                    ],\n                    correctAnswer: 1,\n                    category: 'technology',\n                    difficulty: 'intermediate',\n                    type: 'regular',\n                    section: 'category',\n                    subcategory: 'programming',\n                    funFact: \"Java was originally called Oak and was developed by James Gosling at Sun Microsystems.\",\n                    tags: [\n                        'programming',\n                        'java',\n                        'development'\n                    ],\n                    createdAt: Date.now(),\n                    updatedAt: Date.now()\n                },\n                {\n                    id: 'cat-social-1',\n                    question: \"Which social media platform was originally called 'The Facebook'?\",\n                    options: [\n                        \"Instagram\",\n                        \"Twitter\",\n                        \"Facebook\",\n                        \"LinkedIn\"\n                    ],\n                    correctAnswer: 2,\n                    category: 'social-media',\n                    difficulty: 'beginner',\n                    type: 'regular',\n                    section: 'category',\n                    subcategory: 'history',\n                    funFact: \"Facebook was founded by Mark Zuckerberg in 2004 while he was a student at Harvard University.\",\n                    tags: [\n                        'social-media',\n                        'facebook',\n                        'history'\n                    ],\n                    createdAt: Date.now(),\n                    updatedAt: Date.now()\n                }\n            ];\n            categoryQuestions.push(...sampleCategoryQuestions);\n        } catch (error) {\n            console.error('Error importing category questions:', error);\n        }\n        return categoryQuestions;\n    }\n    // Force reimport of all questions (for admin use)\n    forceReimportQuestions() {\n        try {\n            // Clear the import flag\n            this.safeSetItem('quiz_questions_imported', '');\n            // Clear existing questions\n            this.safeSetItem(_types_admin__WEBPACK_IMPORTED_MODULE_0__.QUIZ_STORAGE_KEYS.QUESTIONS, '');\n            // Import all questions\n            const importedQuestions = this.importAllExistingQuestions();\n            return {\n                success: true,\n                processedCount: importedQuestions.length,\n                errorCount: 0,\n                errors: []\n            };\n        } catch (error) {\n            return {\n                success: false,\n                processedCount: 0,\n                errorCount: 1,\n                errors: [\n                    error instanceof Error ? error.message : 'Import failed'\n                ]\n            };\n        }\n    }\n    // Backup and restore functionality\n    createBackup() {\n        const backup = {\n            questions: this.getQuestions(),\n            settings: this.getSettings(),\n            drafts: this.getDrafts(),\n            timestamp: Date.now(),\n            version: '1.0'\n        };\n        return JSON.stringify(backup, null, 2);\n    }\n    restoreFromBackup(backupData) {\n        try {\n            const backup = JSON.parse(backupData);\n            if (!backup.questions || !Array.isArray(backup.questions)) {\n                throw new QuizDataError('Invalid backup format: missing questions array', 'INVALID_BACKUP');\n            }\n            // Validate all questions in backup\n            backup.questions.forEach((q, index)=>{\n                try {\n                    this.validateQuestion(q);\n                } catch (error) {\n                    throw new QuizDataError(\"Invalid question at index \".concat(index, \": \").concat(error instanceof Error ? error.message : 'Unknown error'), 'INVALID_BACKUP_QUESTION');\n                }\n            });\n            // Create current backup before restore\n            const currentBackup = this.createBackup();\n            this.safeSetItem(_types_admin__WEBPACK_IMPORTED_MODULE_0__.QUIZ_STORAGE_KEYS.BACKUP, currentBackup);\n            // Restore data\n            this.saveQuestions(backup.questions);\n            if (backup.settings) {\n                this.safeSetItem(_types_admin__WEBPACK_IMPORTED_MODULE_0__.QUIZ_STORAGE_KEYS.SETTINGS, JSON.stringify(backup.settings));\n            }\n            if (backup.drafts) {\n                this.safeSetItem(_types_admin__WEBPACK_IMPORTED_MODULE_0__.QUIZ_STORAGE_KEYS.DRAFTS, JSON.stringify(backup.drafts));\n            }\n            return {\n                success: true,\n                processedCount: backup.questions.length,\n                errorCount: 0,\n                errors: []\n            };\n        } catch (error) {\n            throw new QuizDataError(\"Failed to restore backup: \".concat(error instanceof Error ? error.message : 'Unknown error'), 'RESTORE_FAILED');\n        }\n    }\n    // Auto-save functionality for drafts\n    startAutoSave(draftId, getDraftData) {\n        this.stopAutoSave();\n        this.autoSaveTimer = setInterval(()=>{\n            try {\n                const draftData = getDraftData();\n                if (draftData.question && draftData.question.length > 0) {\n                    const draft = {\n                        id: draftId,\n                        question: draftData.question || '',\n                        options: draftData.options || [\n                            '',\n                            '',\n                            '',\n                            ''\n                        ],\n                        correctAnswer: draftData.correctAnswer || 0,\n                        category: draftData.category || 'facts',\n                        difficulty: draftData.difficulty || 'beginner',\n                        type: draftData.type || 'regular',\n                        funFact: draftData.funFact,\n                        tags: draftData.tags,\n                        lastSaved: Date.now()\n                    };\n                    this.saveDraft(draft);\n                }\n            } catch (error) {\n                console.error('Auto-save failed:', error);\n            }\n        }, VALIDATION_RULES.AUTO_SAVE_INTERVAL);\n    }\n    stopAutoSave() {\n        if (this.autoSaveTimer) {\n            clearInterval(this.autoSaveTimer);\n            this.autoSaveTimer = null;\n        }\n    }\n    // CSV Export functionality\n    exportToCSV(questionsToExport) {\n        const questions = questionsToExport || this.getQuestions();\n        const headers = [\n            'ID',\n            'Question',\n            'Option 1',\n            'Option 2',\n            'Option 3',\n            'Option 4',\n            'Correct Answer (1-4)',\n            'Category',\n            'Difficulty',\n            'Type',\n            'Fun Fact',\n            'Tags',\n            'Created At',\n            'Updated At'\n        ];\n        const csvRows = [\n            headers.join(',')\n        ];\n        questions.forEach((question)=>{\n            var _question_options_, _question_options_1, _question_options_2, _question_options_3;\n            const row = [\n                question.id,\n                '\"'.concat(question.question.replace(/\"/g, '\"\"'), '\"'),\n                '\"'.concat(((_question_options_ = question.options[0]) === null || _question_options_ === void 0 ? void 0 : _question_options_.replace(/\"/g, '\"\"')) || '', '\"'),\n                '\"'.concat(((_question_options_1 = question.options[1]) === null || _question_options_1 === void 0 ? void 0 : _question_options_1.replace(/\"/g, '\"\"')) || '', '\"'),\n                '\"'.concat(((_question_options_2 = question.options[2]) === null || _question_options_2 === void 0 ? void 0 : _question_options_2.replace(/\"/g, '\"\"')) || '', '\"'),\n                '\"'.concat(((_question_options_3 = question.options[3]) === null || _question_options_3 === void 0 ? void 0 : _question_options_3.replace(/\"/g, '\"\"')) || '', '\"'),\n                question.correctAnswer + 1,\n                question.category,\n                question.difficulty,\n                question.type,\n                '\"'.concat((question.funFact || '').replace(/\"/g, '\"\"'), '\"'),\n                '\"'.concat((question.tags || []).join(';'), '\"'),\n                new Date(question.createdAt).toISOString(),\n                new Date(question.updatedAt).toISOString()\n            ];\n            csvRows.push(row.join(','));\n        });\n        return csvRows.join('\\n');\n    }\n    // Download CSV file\n    downloadCSV() {\n        try {\n            const csvContent = this.exportToCSV();\n            const blob = new Blob([\n                csvContent\n            ], {\n                type: 'text/csv;charset=utf-8;'\n            });\n            const link = document.createElement('a');\n            if (link.download !== undefined) {\n                const url = URL.createObjectURL(blob);\n                link.setAttribute('href', url);\n                link.setAttribute('download', \"techkwiz-questions-\".concat(new Date().toISOString().split('T')[0], \".csv\"));\n                link.style.visibility = 'hidden';\n                document.body.appendChild(link);\n                link.click();\n                document.body.removeChild(link);\n                URL.revokeObjectURL(url);\n            }\n        } catch (error) {\n            throw new QuizDataError('Failed to download CSV file', 'EXPORT_ERROR');\n        }\n    }\n    // Parse CSV content\n    parseCSV(csvContent) {\n        const lines = csvContent.split('\\n').filter((line)=>line.trim());\n        const errors = [];\n        const questions = [];\n        if (lines.length < 2) {\n            errors.push('CSV file must contain at least a header row and one data row');\n            return {\n                questions,\n                errors\n            };\n        }\n        // Skip header row\n        const dataLines = lines.slice(1);\n        dataLines.forEach((line, index)=>{\n            try {\n                const values = this.parseCSVLine(line);\n                if (values.length < 8) {\n                    errors.push(\"Row \".concat(index + 2, \": Insufficient columns (minimum 8 required)\"));\n                    return;\n                }\n                const [id, question, opt1, opt2, opt3, opt4, correctAnswer, category, difficulty, type, funFact, tags, createdAt, updatedAt] = values;\n                // Validate required fields\n                if (!(question === null || question === void 0 ? void 0 : question.trim())) {\n                    errors.push(\"Row \".concat(index + 2, \": Question is required\"));\n                    return;\n                }\n                if (!(opt1 === null || opt1 === void 0 ? void 0 : opt1.trim()) || !(opt2 === null || opt2 === void 0 ? void 0 : opt2.trim()) || !(opt3 === null || opt3 === void 0 ? void 0 : opt3.trim()) || !(opt4 === null || opt4 === void 0 ? void 0 : opt4.trim())) {\n                    errors.push(\"Row \".concat(index + 2, \": All 4 options are required\"));\n                    return;\n                }\n                const correctAnswerNum = parseInt(correctAnswer) - 1 // Convert 1-based to 0-based\n                ;\n                if (isNaN(correctAnswerNum) || correctAnswerNum < 0 || correctAnswerNum > 3) {\n                    errors.push(\"Row \".concat(index + 2, \": Correct answer must be 1, 2, 3, or 4\"));\n                    return;\n                }\n                if (!(category === null || category === void 0 ? void 0 : category.trim())) {\n                    errors.push(\"Row \".concat(index + 2, \": Category is required\"));\n                    return;\n                }\n                if (![\n                    'beginner',\n                    'intermediate',\n                    'advanced'\n                ].includes(difficulty)) {\n                    errors.push(\"Row \".concat(index + 2, \": Difficulty must be 'beginner', 'intermediate', or 'advanced'\"));\n                    return;\n                }\n                if (![\n                    'regular',\n                    'bonus'\n                ].includes(type)) {\n                    errors.push(\"Row \".concat(index + 2, \": Type must be 'regular' or 'bonus'\"));\n                    return;\n                }\n                const questionData = {\n                    id: id || \"imported_\".concat(Date.now(), \"_\").concat(index),\n                    question: question.trim(),\n                    options: [\n                        opt1.trim(),\n                        opt2.trim(),\n                        opt3.trim(),\n                        opt4.trim()\n                    ],\n                    correctAnswer: correctAnswerNum,\n                    category: category.trim(),\n                    difficulty: difficulty,\n                    type: type,\n                    funFact: (funFact === null || funFact === void 0 ? void 0 : funFact.trim()) || undefined,\n                    tags: tags ? tags.split(';').map((tag)=>tag.trim()).filter(Boolean) : [],\n                    createdAt: createdAt ? new Date(createdAt).getTime() : Date.now(),\n                    updatedAt: updatedAt ? new Date(updatedAt).getTime() : Date.now()\n                };\n                questions.push(questionData);\n            } catch (error) {\n                errors.push(\"Row \".concat(index + 2, \": \").concat(error instanceof Error ? error.message : 'Parse error'));\n            }\n        });\n        return {\n            questions,\n            errors\n        };\n    }\n    // Helper to parse CSV line with proper quote handling\n    parseCSVLine(line) {\n        const result = [];\n        let current = '';\n        let inQuotes = false;\n        let i = 0;\n        while(i < line.length){\n            const char = line[i];\n            if (char === '\"') {\n                if (inQuotes && line[i + 1] === '\"') {\n                    // Escaped quote\n                    current += '\"';\n                    i += 2;\n                } else {\n                    // Toggle quote state\n                    inQuotes = !inQuotes;\n                    i++;\n                }\n            } else if (char === ',' && !inQuotes) {\n                // End of field\n                result.push(current);\n                current = '';\n                i++;\n            } else {\n                current += char;\n                i++;\n            }\n        }\n        result.push(current); // Add last field\n        return result;\n    }\n    // Import from CSV\n    importFromCSV(csvContent) {\n        try {\n            const { questions, errors } = this.parseCSV(csvContent);\n            if (errors.length > 0) {\n                return {\n                    success: false,\n                    processedCount: 0,\n                    errorCount: errors.length,\n                    errors\n                };\n            }\n            let successCount = 0;\n            const importErrors = [];\n            questions.forEach((questionData, index)=>{\n                try {\n                    const fullQuestion = {\n                        id: questionData.id,\n                        question: questionData.question,\n                        options: questionData.options,\n                        correctAnswer: questionData.correctAnswer,\n                        category: questionData.category,\n                        difficulty: questionData.difficulty,\n                        type: questionData.type,\n                        funFact: questionData.funFact,\n                        tags: questionData.tags || [],\n                        createdAt: questionData.createdAt,\n                        updatedAt: questionData.updatedAt\n                    };\n                    // Validate the complete question\n                    const validation = this.validateQuestion(fullQuestion);\n                    if (!validation.isValid) {\n                        importErrors.push(\"Question \".concat(index + 1, \": \").concat(validation.errors.join(', ')));\n                        return;\n                    }\n                    this.saveQuestion(fullQuestion);\n                    successCount++;\n                } catch (error) {\n                    importErrors.push(\"Question \".concat(index + 1, \": \").concat(error instanceof Error ? error.message : 'Save error'));\n                }\n            });\n            return {\n                success: importErrors.length === 0,\n                processedCount: successCount,\n                errorCount: importErrors.length,\n                errors: importErrors\n            };\n        } catch (error) {\n            return {\n                success: false,\n                processedCount: 0,\n                errorCount: 1,\n                errors: [\n                    error instanceof Error ? error.message : 'Import failed'\n                ]\n            };\n        }\n    }\n    constructor(){\n        this.autoSaveTimer = null;\n    }\n}\n// Export singleton instance\nconst quizDataManager = QuizDataManager.getInstance();\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy91dGlscy9xdWl6RGF0YU1hbmFnZXIudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQVNzQjtBQUV0QiwwQkFBMEI7QUFDbkIsTUFBTUUsbUJBQW1CO0lBQzlCQyxxQkFBcUI7SUFDckJDLHFCQUFxQjtJQUNyQkMsbUJBQW1CO0lBQ25CQyxtQkFBbUI7SUFDbkJDLGFBQWE7SUFDYkMsYUFBYTtJQUNiQyxxQkFBcUI7SUFDckJDLGVBQWUsSUFBSSxPQUFPO0lBQzFCQyxvQkFBb0IsTUFBTSxhQUFhO0FBQ3pDLEVBQVU7QUFFVixjQUFjO0FBQ1AsTUFBTUMsc0JBQXNCQztJQUNqQyxZQUFZQyxPQUFlLEVBQUUsSUFBbUIsQ0FBRTtRQUNoRCxLQUFLLENBQUNBLGVBRDRCQyxPQUFBQTtRQUVsQyxJQUFJLENBQUNDLElBQUksR0FBRztJQUNkO0FBQ0Y7QUFFQSxnREFBZ0Q7QUFDaEQsTUFBTUM7SUFJSixPQUFPQyxjQUErQjtRQUNwQyxJQUFJLENBQUNELGdCQUFnQkUsUUFBUSxFQUFFO1lBQzdCRixnQkFBZ0JFLFFBQVEsR0FBRyxJQUFJRjtRQUNqQztRQUNBLE9BQU9BLGdCQUFnQkUsUUFBUTtJQUNqQztJQUVBLG1EQUFtRDtJQUMzQ0MsWUFBWUMsR0FBVyxFQUFpQjtRQUM5QyxvQ0FBb0M7UUFDcEMsSUFBSSxLQUE2QixFQUFFLEVBRWxDO1FBRUQsSUFBSTtZQUNGLE9BQU9DLGFBQWFDLE9BQU8sQ0FBQ0Y7UUFDOUIsRUFBRSxPQUFPRyxPQUFPO1lBQ2RDLFFBQVFELEtBQUssQ0FBQyx1Q0FBMkMsT0FBSkgsS0FBSSxNQUFJRztZQUM3RCxPQUFPO1FBQ1Q7SUFDRjtJQUVRRSxZQUFZTCxHQUFXLEVBQUVNLEtBQWEsRUFBVztRQUN2RCxxQ0FBcUM7UUFDckMsSUFBSSxLQUE2QixFQUFFLEVBRWxDO1FBRUQsSUFBSTtZQUNGTCxhQUFhTSxPQUFPLENBQUNQLEtBQUtNO1lBQzFCLE9BQU87UUFDVCxFQUFFLE9BQU9ILE9BQU87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QUNGO29CQUVBLElBQUksQ0FBQzlFLFlBQVksQ0FBQ3NLO29CQUNsQkY7Z0JBQ0YsRUFBRSxPQUFPbE0sT0FBTztvQkFDZG1NLGFBQWE1SixJQUFJLENBQUMsWUFBMEJ2QyxPQUFkMkMsUUFBUSxHQUFFLE1BQTBELE9BQXREM0MsaUJBQWlCWCxRQUFRVyxNQUFNVixPQUFPLEdBQUc7Z0JBQ3ZGO1lBQ0Y7WUFFQSxPQUFPO2dCQUNMZ0UsU0FBUzZJLGFBQWFsSixNQUFNLEtBQUs7Z0JBQ2pDTSxnQkFBZ0IySTtnQkFDaEIxSSxZQUFZMkksYUFBYWxKLE1BQU07Z0JBQy9CUSxRQUFRMEk7WUFDVjtRQUNGLEVBQUUsT0FBT25NLE9BQU87WUFDZCxPQUFPO2dCQUNMc0QsU0FBUztnQkFDVEMsZ0JBQWdCO2dCQUNoQkMsWUFBWTtnQkFDWkMsUUFBUTtvQkFBQ3pELGlCQUFpQlgsUUFBUVcsTUFBTVYsT0FBTyxHQUFHO2lCQUFnQjtZQUNwRTtRQUNGO0lBQ0Y7O2FBL2hDUTRLLGdCQUF1Qzs7QUFnaUNqRDtBQUVBLDRCQUE0QjtBQUNyQixNQUFNcUMsa0JBQWtCOU0sZ0JBQWdCQyxXQUFXLEdBQUUiLCJzb3VyY2VzIjpbIi9Vc2Vycy9qYXNlZW0vRG9jdW1lbnRzL0dpdEh1Yi9UZWNoa3dpei12Ny9mcm9udGVuZC9zcmMvdXRpbHMvcXVpekRhdGFNYW5hZ2VyLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFxuICBRdWl6UXVlc3Rpb24sIFxuICBRdWl6Q2F0ZWdvcnksIFxuICBTZWFyY2hGaWx0ZXJzLCBcbiAgQnVsa09wZXJhdGlvblJlc3VsdCwgXG4gIFF1ZXN0aW9uRHJhZnQsXG4gIFF1aXpNYW5hZ2VtZW50U2V0dGluZ3MsXG4gIFFVSVpfU1RPUkFHRV9LRVlTLFxuICBERUZBVUxUX0NBVEVHT1JJRVMgXG59IGZyb20gJ0AvdHlwZXMvYWRtaW4nXG5cbi8vIERhdGEgdmFsaWRhdGlvbiBzY2hlbWFzXG5leHBvcnQgY29uc3QgVkFMSURBVElPTl9SVUxFUyA9IHtcbiAgUVVFU1RJT05fTUlOX0xFTkdUSDogMTAsXG4gIFFVRVNUSU9OX01BWF9MRU5HVEg6IDUwMCxcbiAgT1BUSU9OX01JTl9MRU5HVEg6IDEsXG4gIE9QVElPTl9NQVhfTEVOR1RIOiAxMDAsXG4gIE1JTl9PUFRJT05TOiA0LFxuICBNQVhfT1BUSU9OUzogNCxcbiAgTUFYX0JVTEtfT1BFUkFUSU9OUzogNTAsXG4gIE1BWF9GSUxFX1NJWkU6IDUgKiAxMDI0ICogMTAyNCwgLy8gNU1CXG4gIEFVVE9fU0FWRV9JTlRFUlZBTDogMzAwMDAgLy8gMzAgc2Vjb25kc1xufSBhcyBjb25zdFxuXG4vLyBFcnJvciB0eXBlc1xuZXhwb3J0IGNsYXNzIFF1aXpEYXRhRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yKG1lc3NhZ2U6IHN0cmluZywgcHVibGljIGNvZGU6IHN0cmluZykge1xuICAgIHN1cGVyKG1lc3NhZ2UpXG4gICAgdGhpcy5uYW1lID0gJ1F1aXpEYXRhRXJyb3InXG4gIH1cbn1cblxuLy8gVXRpbGl0eSBmdW5jdGlvbnMgZm9yIGxvY2FsU3RvcmFnZSBvcGVyYXRpb25zXG5jbGFzcyBRdWl6RGF0YU1hbmFnZXIge1xuICBwcml2YXRlIHN0YXRpYyBpbnN0YW5jZTogUXVpekRhdGFNYW5hZ2VyXG4gIHByaXZhdGUgYXV0b1NhdmVUaW1lcjogTm9kZUpTLlRpbWVvdXQgfCBudWxsID0gbnVsbFxuXG4gIHN0YXRpYyBnZXRJbnN0YW5jZSgpOiBRdWl6RGF0YU1hbmFnZXIge1xuICAgIGlmICghUXVpekRhdGFNYW5hZ2VyLmluc3RhbmNlKSB7XG4gICAgICBRdWl6RGF0YU1hbmFnZXIuaW5zdGFuY2UgPSBuZXcgUXVpekRhdGFNYW5hZ2VyKClcbiAgICB9XG4gICAgcmV0dXJuIFF1aXpEYXRhTWFuYWdlci5pbnN0YW5jZVxuICB9XG5cbiAgLy8gU2FmZSBsb2NhbFN0b3JhZ2Ugb3BlcmF0aW9ucyB3aXRoIGVycm9yIGhhbmRsaW5nXG4gIHByaXZhdGUgc2FmZUdldEl0ZW0oa2V5OiBzdHJpbmcpOiBzdHJpbmcgfCBudWxsIHtcbiAgICAvLyBSZXR1cm4gbnVsbCBpZiBub3Qgb24gY2xpZW50IHNpZGVcbiAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHJldHVybiBudWxsXG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBsb2NhbFN0b3JhZ2UuZ2V0SXRlbShrZXkpXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yIHJlYWRpbmcgZnJvbSBsb2NhbFN0b3JhZ2Uga2V5ICR7a2V5fTpgLCBlcnJvcilcbiAgICAgIHJldHVybiBudWxsXG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBzYWZlU2V0SXRlbShrZXk6IHN0cmluZywgdmFsdWU6IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgIC8vIFJldHVybiBmYWxzZSBpZiBub3Qgb24gY2xpZW50IHNpZGVcbiAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbShrZXksIHZhbHVlKVxuICAgICAgcmV0dXJuIHRydWVcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcihgRXJyb3Igd3JpdGluZyB0byBsb2NhbFN0b3JhZ2Uga2V5ICR7a2V5fTpgLCBlcnJvcilcbiAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIERPTUV4Y2VwdGlvbiAmJiBlcnJvci5jb2RlID09PSAyMikge1xuICAgICAgICB0aHJvdyBuZXcgUXVpekRhdGFFcnJvcignU3RvcmFnZSBxdW90YSBleGNlZWRlZC4gUGxlYXNlIGNsZWFyIHNvbWUgZGF0YS4nLCAnUVVPVEFfRVhDRUVERUQnKVxuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuICB9XG5cbiAgLy8gUXVlc3Rpb24gQ1JVRCBvcGVyYXRpb25zXG4gIGdldFF1ZXN0aW9ucygpOiBRdWl6UXVlc3Rpb25bXSB7XG4gICAgY29uc3QgZGF0YSA9IHRoaXMuc2FmZUdldEl0ZW0oUVVJWl9TVE9SQUdFX0tFWVMuUVVFU1RJT05TKVxuICAgIGlmICghZGF0YSkgcmV0dXJuIHRoaXMuaW5pdGlhbGl6ZVdpdGhTYW1wbGVEYXRhKClcblxuICAgIHRyeSB7XG4gICAgICBjb25zdCBxdWVzdGlvbnMgPSBKU09OLnBhcnNlKGRhdGEpXG4gICAgICByZXR1cm4gQXJyYXkuaXNBcnJheShxdWVzdGlvbnMpID8gcXVlc3Rpb25zIDogW11cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgcGFyc2luZyBxdWVzdGlvbnMgZGF0YTonLCBlcnJvcilcbiAgICAgIHJldHVybiB0aGlzLmluaXRpYWxpemVXaXRoU2FtcGxlRGF0YSgpXG4gICAgfVxuICB9XG5cbiAgLy8gR2V0IHF1ZXN0aW9ucyB3aXRoIGZpbHRlcmluZyBzdXBwb3J0XG4gIGdldEZpbHRlcmVkUXVlc3Rpb25zKGZpbHRlcnM/OiB7XG4gICAgY2F0ZWdvcnk/OiBzdHJpbmdcbiAgICBkaWZmaWN1bHR5PzogJ2JlZ2lubmVyJyB8ICdpbnRlcm1lZGlhdGUnIHwgJ2FkdmFuY2VkJ1xuICAgIHR5cGU/OiAncmVndWxhcicgfCAnYm9udXMnXG4gICAgc2VjdGlvbj86ICdvbmJvYXJkaW5nJyB8ICdob21lcGFnZScgfCAnY2F0ZWdvcnknIHwgJ2dlbmVyYWwnXG4gICAgc3ViY2F0ZWdvcnk/OiBzdHJpbmdcbiAgICB0YWdzPzogc3RyaW5nW11cbiAgfSk6IFF1aXpRdWVzdGlvbltdIHtcbiAgICBjb25zdCBxdWVzdGlvbnMgPSB0aGlzLmdldFF1ZXN0aW9ucygpXG5cbiAgICBpZiAoIWZpbHRlcnMpIHJldHVybiBxdWVzdGlvbnNcblxuICAgIHJldHVybiBxdWVzdGlvbnMuZmlsdGVyKHF1ZXN0aW9uID0+IHtcbiAgICAgIGlmIChmaWx0ZXJzLmNhdGVnb3J5ICYmIHF1ZXN0aW9uLmNhdGVnb3J5ICE9PSBmaWx0ZXJzLmNhdGVnb3J5KSByZXR1cm4gZmFsc2VcbiAgICAgIGlmIChmaWx0ZXJzLmRpZmZpY3VsdHkgJiYgcXVlc3Rpb24uZGlmZmljdWx0eSAhPT0gZmlsdGVycy5kaWZmaWN1bHR5KSByZXR1cm4gZmFsc2VcbiAgICAgIGlmIChmaWx0ZXJzLnR5cGUgJiYgcXVlc3Rpb24udHlwZSAhPT0gZmlsdGVycy50eXBlKSByZXR1cm4gZmFsc2VcbiAgICAgIGlmIChmaWx0ZXJzLnNlY3Rpb24gJiYgcXVlc3Rpb24uc2VjdGlvbiAhPT0gZmlsdGVycy5zZWN0aW9uKSByZXR1cm4gZmFsc2VcbiAgICAgIGlmIChmaWx0ZXJzLnN1YmNhdGVnb3J5ICYmIHF1ZXN0aW9uLnN1YmNhdGVnb3J5ICE9PSBmaWx0ZXJzLnN1YmNhdGVnb3J5KSByZXR1cm4gZmFsc2VcbiAgICAgIGlmIChmaWx0ZXJzLnRhZ3MgJiYgIWZpbHRlcnMudGFncy5zb21lKHRhZyA9PiBxdWVzdGlvbi50YWdzPy5pbmNsdWRlcyh0YWcpKSkgcmV0dXJuIGZhbHNlXG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH0pXG4gIH1cblxuICAvLyBHZXQgcXVlc3Rpb25zIGJ5IHNlY3Rpb25cbiAgZ2V0UXVlc3Rpb25zQnlTZWN0aW9uKHNlY3Rpb246ICdvbmJvYXJkaW5nJyB8ICdob21lcGFnZScgfCAnY2F0ZWdvcnknIHwgJ2dlbmVyYWwnKTogUXVpelF1ZXN0aW9uW10ge1xuICAgIHJldHVybiB0aGlzLmdldEZpbHRlcmVkUXVlc3Rpb25zKHsgc2VjdGlvbiB9KVxuICB9XG5cbiAgLy8gR2V0IHF1ZXN0aW9ucyBieSBjYXRlZ29yeSBhbmQgc2VjdGlvblxuICBnZXRRdWVzdGlvbnNCeUNhdGVnb3J5QW5kU2VjdGlvbihjYXRlZ29yeTogc3RyaW5nLCBzZWN0aW9uPzogJ29uYm9hcmRpbmcnIHwgJ2hvbWVwYWdlJyB8ICdjYXRlZ29yeScgfCAnZ2VuZXJhbCcpOiBRdWl6UXVlc3Rpb25bXSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0RmlsdGVyZWRRdWVzdGlvbnMoeyBjYXRlZ29yeSwgc2VjdGlvbiB9KVxuICB9XG5cbiAgc2F2ZVF1ZXN0aW9uKHF1ZXN0aW9uOiBPbWl0PFF1aXpRdWVzdGlvbiwgJ2lkJyB8ICdjcmVhdGVkQXQnIHwgJ3VwZGF0ZWRBdCc+KTogUXVpelF1ZXN0aW9uIHtcbiAgICB0aGlzLnZhbGlkYXRlUXVlc3Rpb24ocXVlc3Rpb24pXG4gICAgXG4gICAgY29uc3QgcXVlc3Rpb25zID0gdGhpcy5nZXRRdWVzdGlvbnMoKVxuICAgIGNvbnN0IG5vdyA9IERhdGUubm93KClcbiAgICBjb25zdCBuZXdRdWVzdGlvbjogUXVpelF1ZXN0aW9uID0ge1xuICAgICAgLi4ucXVlc3Rpb24sXG4gICAgICBpZDogdGhpcy5nZW5lcmF0ZUlkKCksXG4gICAgICBjcmVhdGVkQXQ6IG5vdyxcbiAgICAgIHVwZGF0ZWRBdDogbm93XG4gICAgfVxuICAgIFxuICAgIHF1ZXN0aW9ucy5wdXNoKG5ld1F1ZXN0aW9uKVxuICAgIHRoaXMuc2F2ZVF1ZXN0aW9ucyhxdWVzdGlvbnMpXG4gICAgcmV0dXJuIG5ld1F1ZXN0aW9uXG4gIH1cblxuICB1cGRhdGVRdWVzdGlvbihpZDogc3RyaW5nLCB1cGRhdGVzOiBQYXJ0aWFsPE9taXQ8UXVpelF1ZXN0aW9uLCAnaWQnIHwgJ2NyZWF0ZWRBdCc+Pik6IFF1aXpRdWVzdGlvbiB7XG4gICAgY29uc3QgcXVlc3Rpb25zID0gdGhpcy5nZXRRdWVzdGlvbnMoKVxuICAgIGNvbnN0IGluZGV4ID0gcXVlc3Rpb25zLmZpbmRJbmRleChxID0+IHEuaWQgPT09IGlkKVxuICAgIFxuICAgIGlmIChpbmRleCA9PT0gLTEpIHtcbiAgICAgIHRocm93IG5ldyBRdWl6RGF0YUVycm9yKGBRdWVzdGlvbiB3aXRoIGlkICR7aWR9IG5vdCBmb3VuZGAsICdOT1RfRk9VTkQnKVxuICAgIH1cbiAgICBcbiAgICBjb25zdCB1cGRhdGVkUXVlc3Rpb24gPSB7XG4gICAgICAuLi5xdWVzdGlvbnNbaW5kZXhdLFxuICAgICAgLi4udXBkYXRlcyxcbiAgICAgIHVwZGF0ZWRBdDogRGF0ZS5ub3coKVxuICAgIH1cbiAgICBcbiAgICB0aGlzLnZhbGlkYXRlUXVlc3Rpb24odXBkYXRlZFF1ZXN0aW9uKVxuICAgIHF1ZXN0aW9uc1tpbmRleF0gPSB1cGRhdGVkUXVlc3Rpb25cbiAgICB0aGlzLnNhdmVRdWVzdGlvbnMocXVlc3Rpb25zKVxuICAgIHJldHVybiB1cGRhdGVkUXVlc3Rpb25cbiAgfVxuXG4gIGRlbGV0ZVF1ZXN0aW9uKGlkOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgICBjb25zdCBxdWVzdGlvbnMgPSB0aGlzLmdldFF1ZXN0aW9ucygpXG4gICAgY29uc3QgZmlsdGVyZWRRdWVzdGlvbnMgPSBxdWVzdGlvbnMuZmlsdGVyKHEgPT4gcS5pZCAhPT0gaWQpXG4gICAgXG4gICAgaWYgKGZpbHRlcmVkUXVlc3Rpb25zLmxlbmd0aCA9PT0gcXVlc3Rpb25zLmxlbmd0aCkge1xuICAgICAgdGhyb3cgbmV3IFF1aXpEYXRhRXJyb3IoYFF1ZXN0aW9uIHdpdGggaWQgJHtpZH0gbm90IGZvdW5kYCwgJ05PVF9GT1VORCcpXG4gICAgfVxuICAgIFxuICAgIHRoaXMuc2F2ZVF1ZXN0aW9ucyhmaWx0ZXJlZFF1ZXN0aW9ucylcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgYnVsa0RlbGV0ZShpZHM6IHN0cmluZ1tdKTogQnVsa09wZXJhdGlvblJlc3VsdCB7XG4gICAgaWYgKGlkcy5sZW5ndGggPiBWQUxJREFUSU9OX1JVTEVTLk1BWF9CVUxLX09QRVJBVElPTlMpIHtcbiAgICAgIHRocm93IG5ldyBRdWl6RGF0YUVycm9yKFxuICAgICAgICBgQ2Fubm90IGRlbGV0ZSBtb3JlIHRoYW4gJHtWQUxJREFUSU9OX1JVTEVTLk1BWF9CVUxLX09QRVJBVElPTlN9IHF1ZXN0aW9ucyBhdCBvbmNlYCxcbiAgICAgICAgJ0JVTEtfTElNSVRfRVhDRUVERUQnXG4gICAgICApXG4gICAgfVxuXG4gICAgY29uc3QgcXVlc3Rpb25zID0gdGhpcy5nZXRRdWVzdGlvbnMoKVxuICAgIGNvbnN0IGluaXRpYWxDb3VudCA9IHF1ZXN0aW9ucy5sZW5ndGhcbiAgICBjb25zdCBmaWx0ZXJlZFF1ZXN0aW9ucyA9IHF1ZXN0aW9ucy5maWx0ZXIocSA9PiAhaWRzLmluY2x1ZGVzKHEuaWQpKVxuICAgIGNvbnN0IGRlbGV0ZWRDb3VudCA9IGluaXRpYWxDb3VudCAtIGZpbHRlcmVkUXVlc3Rpb25zLmxlbmd0aFxuICAgIFxuICAgIHRoaXMuc2F2ZVF1ZXN0aW9ucyhmaWx0ZXJlZFF1ZXN0aW9ucylcbiAgICBcbiAgICByZXR1cm4ge1xuICAgICAgc3VjY2VzczogdHJ1ZSxcbiAgICAgIHByb2Nlc3NlZENvdW50OiBkZWxldGVkQ291bnQsXG4gICAgICBlcnJvckNvdW50OiBpZHMubGVuZ3RoIC0gZGVsZXRlZENvdW50LFxuICAgICAgZXJyb3JzOiBpZHMubGVuZ3RoID4gZGVsZXRlZENvdW50ID8gWydTb21lIHF1ZXN0aW9ucyB3ZXJlIG5vdCBmb3VuZCddIDogW11cbiAgICB9XG4gIH1cblxuICAvLyBTZWFyY2ggYW5kIGZpbHRlciBvcGVyYXRpb25zXG4gIHNlYXJjaFF1ZXN0aW9ucyhmaWx0ZXJzOiBTZWFyY2hGaWx0ZXJzKTogUXVpelF1ZXN0aW9uW10ge1xuICAgIGNvbnN0IHF1ZXN0aW9ucyA9IHRoaXMuZ2V0UXVlc3Rpb25zKClcbiAgICBcbiAgICByZXR1cm4gcXVlc3Rpb25zLmZpbHRlcihxdWVzdGlvbiA9PiB7XG4gICAgICAvLyBUZXh0IHNlYXJjaFxuICAgICAgaWYgKGZpbHRlcnMuc2VhcmNoVGV4dCkge1xuICAgICAgICBjb25zdCBzZWFyY2hMb3dlciA9IGZpbHRlcnMuc2VhcmNoVGV4dC50b0xvd2VyQ2FzZSgpXG4gICAgICAgIGlmICghcXVlc3Rpb24ucXVlc3Rpb24udG9Mb3dlckNhc2UoKS5pbmNsdWRlcyhzZWFyY2hMb3dlcikpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBDYXRlZ29yeSBmaWx0ZXJcbiAgICAgIGlmIChmaWx0ZXJzLmNhdGVnb3J5ICE9PSAnYWxsJyAmJiBxdWVzdGlvbi5jYXRlZ29yeSAhPT0gZmlsdGVycy5jYXRlZ29yeSkge1xuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gRGlmZmljdWx0eSBmaWx0ZXJcbiAgICAgIGlmIChmaWx0ZXJzLmRpZmZpY3VsdHkgIT09ICdhbGwnICYmIHF1ZXN0aW9uLmRpZmZpY3VsdHkgIT09IGZpbHRlcnMuZGlmZmljdWx0eSkge1xuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gVHlwZSBmaWx0ZXJcbiAgICAgIGlmIChmaWx0ZXJzLnR5cGUgIT09ICdhbGwnICYmIHF1ZXN0aW9uLnR5cGUgIT09IGZpbHRlcnMudHlwZSkge1xuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cblxuICAgICAgLy8gU2VjdGlvbiBmaWx0ZXJcbiAgICAgIGlmIChmaWx0ZXJzLnNlY3Rpb24gIT09ICdhbGwnICYmIHF1ZXN0aW9uLnNlY3Rpb24gIT09IGZpbHRlcnMuc2VjdGlvbikge1xuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cblxuICAgICAgLy8gU3ViY2F0ZWdvcnkgZmlsdGVyXG4gICAgICBpZiAoZmlsdGVycy5zdWJjYXRlZ29yeSAhPT0gJ2FsbCcgJiYgcXVlc3Rpb24uc3ViY2F0ZWdvcnkgIT09IGZpbHRlcnMuc3ViY2F0ZWdvcnkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0cnVlXG4gICAgfSlcbiAgfVxuXG4gIC8vIENhdGVnb3JpZXMgbWFuYWdlbWVudFxuICBnZXRDYXRlZ29yaWVzKCk6IFF1aXpDYXRlZ29yeVtdIHtcbiAgICBjb25zdCBxdWVzdGlvbnMgPSB0aGlzLmdldFF1ZXN0aW9ucygpXG4gICAgY29uc3QgY2F0ZWdvcnlDb3VudHMgPSBxdWVzdGlvbnMucmVkdWNlKChhY2MsIHF1ZXN0aW9uKSA9PiB7XG4gICAgICBhY2NbcXVlc3Rpb24uY2F0ZWdvcnldID0gKGFjY1txdWVzdGlvbi5jYXRlZ29yeV0gfHwgMCkgKyAxXG4gICAgICByZXR1cm4gYWNjXG4gICAgfSwge30gYXMgUmVjb3JkPHN0cmluZywgbnVtYmVyPilcbiAgICBcbiAgICByZXR1cm4gREVGQVVMVF9DQVRFR09SSUVTLm1hcChjYXRlZ29yeSA9PiAoe1xuICAgICAgLi4uY2F0ZWdvcnksXG4gICAgICBxdWVzdGlvbkNvdW50OiBjYXRlZ29yeUNvdW50c1tjYXRlZ29yeS5pZF0gfHwgMFxuICAgIH0pKVxuICB9XG5cbiAgLy8gRHJhZnQgbWFuYWdlbWVudFxuICBzYXZlRHJhZnQoZHJhZnQ6IFF1ZXN0aW9uRHJhZnQpOiB2b2lkIHtcbiAgICBjb25zdCBkcmFmdHMgPSB0aGlzLmdldERyYWZ0cygpXG4gICAgY29uc3QgZXhpc3RpbmdJbmRleCA9IGRyYWZ0cy5maW5kSW5kZXgoZCA9PiBkLmlkID09PSBkcmFmdC5pZClcbiAgICBcbiAgICBpZiAoZXhpc3RpbmdJbmRleCA+PSAwKSB7XG4gICAgICBkcmFmdHNbZXhpc3RpbmdJbmRleF0gPSB7IC4uLmRyYWZ0LCBsYXN0U2F2ZWQ6IERhdGUubm93KCkgfVxuICAgIH0gZWxzZSB7XG4gICAgICBkcmFmdHMucHVzaCh7IC4uLmRyYWZ0LCBsYXN0U2F2ZWQ6IERhdGUubm93KCkgfSlcbiAgICB9XG4gICAgXG4gICAgdGhpcy5zYWZlU2V0SXRlbShRVUlaX1NUT1JBR0VfS0VZUy5EUkFGVFMsIEpTT04uc3RyaW5naWZ5KGRyYWZ0cykpXG4gIH1cblxuICBnZXREcmFmdHMoKTogUXVlc3Rpb25EcmFmdFtdIHtcbiAgICBjb25zdCBkYXRhID0gdGhpcy5zYWZlR2V0SXRlbShRVUlaX1NUT1JBR0VfS0VZUy5EUkFGVFMpXG4gICAgaWYgKCFkYXRhKSByZXR1cm4gW11cbiAgICBcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIEpTT04ucGFyc2UoZGF0YSlcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgcGFyc2luZyBkcmFmdHMgZGF0YTonLCBlcnJvcilcbiAgICAgIHJldHVybiBbXVxuICAgIH1cbiAgfVxuXG4gIGRlbGV0ZURyYWZ0KGlkOiBzdHJpbmcpOiB2b2lkIHtcbiAgICBjb25zdCBkcmFmdHMgPSB0aGlzLmdldERyYWZ0cygpLmZpbHRlcihkID0+IGQuaWQgIT09IGlkKVxuICAgIHRoaXMuc2FmZVNldEl0ZW0oUVVJWl9TVE9SQUdFX0tFWVMuRFJBRlRTLCBKU09OLnN0cmluZ2lmeShkcmFmdHMpKVxuICB9XG5cbiAgLy8gU2V0dGluZ3MgbWFuYWdlbWVudFxuICBnZXRTZXR0aW5ncygpOiBRdWl6TWFuYWdlbWVudFNldHRpbmdzIHtcbiAgICBjb25zdCBkYXRhID0gdGhpcy5zYWZlR2V0SXRlbShRVUlaX1NUT1JBR0VfS0VZUy5TRVRUSU5HUylcbiAgICBpZiAoIWRhdGEpIHJldHVybiB0aGlzLmdldERlZmF1bHRTZXR0aW5ncygpXG4gICAgXG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiB7IC4uLnRoaXMuZ2V0RGVmYXVsdFNldHRpbmdzKCksIC4uLkpTT04ucGFyc2UoZGF0YSkgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBwYXJzaW5nIHNldHRpbmdzIGRhdGE6JywgZXJyb3IpXG4gICAgICByZXR1cm4gdGhpcy5nZXREZWZhdWx0U2V0dGluZ3MoKVxuICAgIH1cbiAgfVxuXG4gIHNhdmVTZXR0aW5ncyhzZXR0aW5nczogUGFydGlhbDxRdWl6TWFuYWdlbWVudFNldHRpbmdzPik6IHZvaWQge1xuICAgIGNvbnN0IGN1cnJlbnRTZXR0aW5ncyA9IHRoaXMuZ2V0U2V0dGluZ3MoKVxuICAgIGNvbnN0IHVwZGF0ZWRTZXR0aW5ncyA9IHsgLi4uY3VycmVudFNldHRpbmdzLCAuLi5zZXR0aW5ncyB9XG4gICAgdGhpcy5zYWZlU2V0SXRlbShRVUlaX1NUT1JBR0VfS0VZUy5TRVRUSU5HUywgSlNPTi5zdHJpbmdpZnkodXBkYXRlZFNldHRpbmdzKSlcbiAgfVxuXG4gIHByaXZhdGUgZ2V0RGVmYXVsdFNldHRpbmdzKCk6IFF1aXpNYW5hZ2VtZW50U2V0dGluZ3Mge1xuICAgIHJldHVybiB7XG4gICAgICBwYWdlU2l6ZTogMTAsXG4gICAgICBzb3J0Qnk6ICd1cGRhdGVkQXQnLFxuICAgICAgc29ydE9yZGVyOiAnZGVzYycsXG4gICAgICBmaWx0ZXJzOiB7XG4gICAgICAgIHNlYXJjaFRleHQ6ICcnLFxuICAgICAgICBjYXRlZ29yeTogJ2FsbCcsXG4gICAgICAgIGRpZmZpY3VsdHk6ICdhbGwnLFxuICAgICAgICB0eXBlOiAnYWxsJ1xuICAgICAgfSxcbiAgICAgIHNlbGVjdGVkUXVlc3Rpb25zOiBbXVxuICAgIH1cbiAgfVxuXG4gIC8vIFZhbGlkYXRpb25cbiAgcHJpdmF0ZSB2YWxpZGF0ZVF1ZXN0aW9uKHF1ZXN0aW9uOiBQYXJ0aWFsPFF1aXpRdWVzdGlvbj4pOiB2b2lkIHtcbiAgICBpZiAoIXF1ZXN0aW9uLnF1ZXN0aW9uIHx8IHF1ZXN0aW9uLnF1ZXN0aW9uLmxlbmd0aCA8IFZBTElEQVRJT05fUlVMRVMuUVVFU1RJT05fTUlOX0xFTkdUSCkge1xuICAgICAgdGhyb3cgbmV3IFF1aXpEYXRhRXJyb3IoXG4gICAgICAgIGBRdWVzdGlvbiBtdXN0IGJlIGF0IGxlYXN0ICR7VkFMSURBVElPTl9SVUxFUy5RVUVTVElPTl9NSU5fTEVOR1RIfSBjaGFyYWN0ZXJzIGxvbmdgLFxuICAgICAgICAnSU5WQUxJRF9RVUVTVElPTl9MRU5HVEgnXG4gICAgICApXG4gICAgfVxuICAgIFxuICAgIGlmIChxdWVzdGlvbi5xdWVzdGlvbi5sZW5ndGggPiBWQUxJREFUSU9OX1JVTEVTLlFVRVNUSU9OX01BWF9MRU5HVEgpIHtcbiAgICAgIHRocm93IG5ldyBRdWl6RGF0YUVycm9yKFxuICAgICAgICBgUXVlc3Rpb24gbXVzdCBiZSBubyBtb3JlIHRoYW4gJHtWQUxJREFUSU9OX1JVTEVTLlFVRVNUSU9OX01BWF9MRU5HVEh9IGNoYXJhY3RlcnMgbG9uZ2AsXG4gICAgICAgICdJTlZBTElEX1FVRVNUSU9OX0xFTkdUSCdcbiAgICAgIClcbiAgICB9XG4gICAgXG4gICAgaWYgKCFxdWVzdGlvbi5vcHRpb25zIHx8IHF1ZXN0aW9uLm9wdGlvbnMubGVuZ3RoICE9PSBWQUxJREFUSU9OX1JVTEVTLk1JTl9PUFRJT05TKSB7XG4gICAgICB0aHJvdyBuZXcgUXVpekRhdGFFcnJvcihcbiAgICAgICAgYFF1ZXN0aW9uIG11c3QgaGF2ZSBleGFjdGx5ICR7VkFMSURBVElPTl9SVUxFUy5NSU5fT1BUSU9OU30gb3B0aW9uc2AsXG4gICAgICAgICdJTlZBTElEX09QVElPTlNfQ09VTlQnXG4gICAgICApXG4gICAgfVxuICAgIFxuICAgIC8vIFZhbGlkYXRlIGVhY2ggb3B0aW9uXG4gICAgcXVlc3Rpb24ub3B0aW9ucy5mb3JFYWNoKChvcHRpb24sIGluZGV4KSA9PiB7XG4gICAgICBpZiAoIW9wdGlvbiB8fCBvcHRpb24ubGVuZ3RoIDwgVkFMSURBVElPTl9SVUxFUy5PUFRJT05fTUlOX0xFTkdUSCkge1xuICAgICAgICB0aHJvdyBuZXcgUXVpekRhdGFFcnJvcihcbiAgICAgICAgICBgT3B0aW9uICR7aW5kZXggKyAxfSBtdXN0IGJlIGF0IGxlYXN0ICR7VkFMSURBVElPTl9SVUxFUy5PUFRJT05fTUlOX0xFTkdUSH0gY2hhcmFjdGVyIGxvbmdgLFxuICAgICAgICAgICdJTlZBTElEX09QVElPTl9MRU5HVEgnXG4gICAgICAgIClcbiAgICAgIH1cbiAgICAgIFxuICAgICAgaWYgKG9wdGlvbi5sZW5ndGggPiBWQUxJREFUSU9OX1JVTEVTLk9QVElPTl9NQVhfTEVOR1RIKSB7XG4gICAgICAgIHRocm93IG5ldyBRdWl6RGF0YUVycm9yKFxuICAgICAgICAgIGBPcHRpb24gJHtpbmRleCArIDF9IG11c3QgYmUgbm8gbW9yZSB0aGFuICR7VkFMSURBVElPTl9SVUxFUy5PUFRJT05fTUFYX0xFTkdUSH0gY2hhcmFjdGVycyBsb25nYCxcbiAgICAgICAgICAnSU5WQUxJRF9PUFRJT05fTEVOR1RIJ1xuICAgICAgICApXG4gICAgICB9XG4gICAgfSlcbiAgICBcbiAgICAvLyBDaGVjayBmb3IgZHVwbGljYXRlIG9wdGlvbnNcbiAgICBjb25zdCB1bmlxdWVPcHRpb25zID0gbmV3IFNldChxdWVzdGlvbi5vcHRpb25zLm1hcChvcHQgPT4gb3B0LnRvTG93ZXJDYXNlKCkudHJpbSgpKSlcbiAgICBpZiAodW5pcXVlT3B0aW9ucy5zaXplICE9PSBxdWVzdGlvbi5vcHRpb25zLmxlbmd0aCkge1xuICAgICAgdGhyb3cgbmV3IFF1aXpEYXRhRXJyb3IoJ0FsbCBvcHRpb25zIG11c3QgYmUgdW5pcXVlJywgJ0RVUExJQ0FURV9PUFRJT05TJylcbiAgICB9XG4gICAgXG4gICAgLy8gVmFsaWRhdGUgY29ycmVjdCBhbnN3ZXJcbiAgICBpZiAodHlwZW9mIHF1ZXN0aW9uLmNvcnJlY3RBbnN3ZXIgIT09ICdudW1iZXInIHx8IFxuICAgICAgICBxdWVzdGlvbi5jb3JyZWN0QW5zd2VyIDwgMCB8fCBcbiAgICAgICAgcXVlc3Rpb24uY29ycmVjdEFuc3dlciA+PSBxdWVzdGlvbi5vcHRpb25zLmxlbmd0aCkge1xuICAgICAgdGhyb3cgbmV3IFF1aXpEYXRhRXJyb3IoJ0ludmFsaWQgY29ycmVjdCBhbnN3ZXIgc2VsZWN0aW9uJywgJ0lOVkFMSURfQ09SUkVDVF9BTlNXRVInKVxuICAgIH1cbiAgICBcbiAgICAvLyBWYWxpZGF0ZSBjYXRlZ29yeVxuICAgIGNvbnN0IHZhbGlkQ2F0ZWdvcmllcyA9IERFRkFVTFRfQ0FURUdPUklFUy5tYXAoYyA9PiBjLmlkKVxuICAgIGlmICghcXVlc3Rpb24uY2F0ZWdvcnkgfHwgIXZhbGlkQ2F0ZWdvcmllcy5pbmNsdWRlcyhxdWVzdGlvbi5jYXRlZ29yeSkpIHtcbiAgICAgIHRocm93IG5ldyBRdWl6RGF0YUVycm9yKCdJbnZhbGlkIGNhdGVnb3J5IHNlbGVjdGlvbicsICdJTlZBTElEX0NBVEVHT1JZJylcbiAgICB9XG4gIH1cblxuICAvLyBVdGlsaXR5IG1ldGhvZHNcbiAgcHJpdmF0ZSBzYXZlUXVlc3Rpb25zKHF1ZXN0aW9uczogUXVpelF1ZXN0aW9uW10pOiB2b2lkIHtcbiAgICB0aGlzLnNhZmVTZXRJdGVtKFFVSVpfU1RPUkFHRV9LRVlTLlFVRVNUSU9OUywgSlNPTi5zdHJpbmdpZnkocXVlc3Rpb25zKSlcbiAgfVxuXG4gIHByaXZhdGUgZ2VuZXJhdGVJZCgpOiBzdHJpbmcge1xuICAgIHJldHVybiBgcV8ke0RhdGUubm93KCl9XyR7TWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc3Vic3RyKDIsIDkpfWBcbiAgfVxuXG4gIC8vIENTViBFeHBvcnQvSW1wb3J0IGZ1bmN0aW9uYWxpdHlcbiAgZXhwb3J0VG9DU1YocXVlc3Rpb25zPzogUXVpelF1ZXN0aW9uW10pOiBzdHJpbmcge1xuICAgIGNvbnN0IHF1ZXN0aW9uc1RvRXhwb3J0ID0gcXVlc3Rpb25zIHx8IHRoaXMuZ2V0UXVlc3Rpb25zKClcblxuICAgIGNvbnN0IGhlYWRlcnMgPSBbXG4gICAgICAnSUQnLCAnUXVlc3Rpb24nLCAnT3B0aW9uIDEnLCAnT3B0aW9uIDInLCAnT3B0aW9uIDMnLCAnT3B0aW9uIDQnLFxuICAgICAgJ0NvcnJlY3QgQW5zd2VyJywgJ0NhdGVnb3J5JywgJ0RpZmZpY3VsdHknLCAnVHlwZScsICdGdW4gRmFjdCcsICdUYWdzJyxcbiAgICAgICdDcmVhdGVkIEF0JywgJ1VwZGF0ZWQgQXQnXG4gICAgXVxuXG4gICAgY29uc3QgY3N2Um93cyA9IFtcbiAgICAgIGhlYWRlcnMuam9pbignLCcpLFxuICAgICAgLi4ucXVlc3Rpb25zVG9FeHBvcnQubWFwKHEgPT4gW1xuICAgICAgICBxLmlkLFxuICAgICAgICBgXCIke3EucXVlc3Rpb24ucmVwbGFjZSgvXCIvZywgJ1wiXCInKX1cImAsXG4gICAgICAgIGBcIiR7cS5vcHRpb25zWzBdLnJlcGxhY2UoL1wiL2csICdcIlwiJyl9XCJgLFxuICAgICAgICBgXCIke3Eub3B0aW9uc1sxXS5yZXBsYWNlKC9cIi9nLCAnXCJcIicpfVwiYCxcbiAgICAgICAgYFwiJHtxLm9wdGlvbnNbMl0ucmVwbGFjZSgvXCIvZywgJ1wiXCInKX1cImAsXG4gICAgICAgIGBcIiR7cS5vcHRpb25zWzNdLnJlcGxhY2UoL1wiL2csICdcIlwiJyl9XCJgLFxuICAgICAgICBxLmNvcnJlY3RBbnN3ZXIgKyAxLCAvLyAxLWJhc2VkIGZvciBodW1hbiByZWFkYWJpbGl0eVxuICAgICAgICBxLmNhdGVnb3J5LFxuICAgICAgICBxLmRpZmZpY3VsdHksXG4gICAgICAgIHEudHlwZSxcbiAgICAgICAgYFwiJHsocS5mdW5GYWN0IHx8ICcnKS5yZXBsYWNlKC9cIi9nLCAnXCJcIicpfVwiYCxcbiAgICAgICAgYFwiJHsocS50YWdzIHx8IFtdKS5qb2luKCc7Jyl9XCJgLFxuICAgICAgICBuZXcgRGF0ZShxLmNyZWF0ZWRBdCkudG9JU09TdHJpbmcoKSxcbiAgICAgICAgbmV3IERhdGUocS51cGRhdGVkQXQpLnRvSVNPU3RyaW5nKClcbiAgICAgIF0uam9pbignLCcpKVxuICAgIF1cblxuICAgIC8vIEFkZCBVVEYtOCBCT00gZm9yIEV4Y2VsIGNvbXBhdGliaWxpdHlcbiAgICByZXR1cm4gJ1xcdUZFRkYnICsgY3N2Um93cy5qb2luKCdcXG4nKVxuICB9XG5cbiAgYXN5bmMgaW1wb3J0RnJvbUNTVihjc3ZDb250ZW50OiBzdHJpbmcpOiBQcm9taXNlPEJ1bGtPcGVyYXRpb25SZXN1bHQ+IHtcbiAgICBjb25zdCBsaW5lcyA9IGNzdkNvbnRlbnQuc3BsaXQoJ1xcbicpLmZpbHRlcihsaW5lID0+IGxpbmUudHJpbSgpKVxuICAgIGlmIChsaW5lcy5sZW5ndGggPCAyKSB7XG4gICAgICB0aHJvdyBuZXcgUXVpekRhdGFFcnJvcignQ1NWIGZpbGUgbXVzdCBjb250YWluIGF0IGxlYXN0IGEgaGVhZGVyIGFuZCBvbmUgZGF0YSByb3cnLCAnSU5WQUxJRF9DU1ZfRk9STUFUJylcbiAgICB9XG5cbiAgICBjb25zdCBoZWFkZXJzID0gbGluZXNbMF0uc3BsaXQoJywnKS5tYXAoaCA9PiBoLnRyaW0oKS5yZXBsYWNlKC9cIi9nLCAnJykpXG4gICAgY29uc3QgZGF0YUxpbmVzID0gbGluZXMuc2xpY2UoMSlcblxuICAgIGNvbnN0IHJlc3VsdHM6IEJ1bGtPcGVyYXRpb25SZXN1bHQgPSB7XG4gICAgICBzdWNjZXNzOiB0cnVlLFxuICAgICAgcHJvY2Vzc2VkQ291bnQ6IDAsXG4gICAgICBlcnJvckNvdW50OiAwLFxuICAgICAgZXJyb3JzOiBbXVxuICAgIH1cblxuICAgIGNvbnN0IHZhbGlkUXVlc3Rpb25zOiBRdWl6UXVlc3Rpb25bXSA9IFtdXG4gICAgY29uc3QgZXhpc3RpbmdRdWVzdGlvbnMgPSB0aGlzLmdldFF1ZXN0aW9ucygpXG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRhdGFMaW5lcy5sZW5ndGg7IGkrKykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgdmFsdWVzID0gdGhpcy5wYXJzZUNTVkxpbmUoZGF0YUxpbmVzW2ldKVxuICAgICAgICBpZiAodmFsdWVzLmxlbmd0aCA8IDgpIHtcbiAgICAgICAgICByZXN1bHRzLmVycm9ycy5wdXNoKGBMaW5lICR7aSArIDJ9OiBJbnN1ZmZpY2llbnQgZGF0YSBjb2x1bW5zYClcbiAgICAgICAgICByZXN1bHRzLmVycm9yQ291bnQrK1xuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBxdWVzdGlvbjogUXVpelF1ZXN0aW9uID0ge1xuICAgICAgICAgIGlkOiB2YWx1ZXNbMF0gfHwgdGhpcy5nZW5lcmF0ZUlkKCksXG4gICAgICAgICAgcXVlc3Rpb246IHZhbHVlc1sxXSxcbiAgICAgICAgICBvcHRpb25zOiBbdmFsdWVzWzJdLCB2YWx1ZXNbM10sIHZhbHVlc1s0XSwgdmFsdWVzWzVdXSxcbiAgICAgICAgICBjb3JyZWN0QW5zd2VyOiBwYXJzZUludCh2YWx1ZXNbNl0pIC0gMSwgLy8gQ29udmVydCBiYWNrIHRvIDAtYmFzZWRcbiAgICAgICAgICBjYXRlZ29yeTogdmFsdWVzWzddLFxuICAgICAgICAgIGRpZmZpY3VsdHk6IHZhbHVlc1s4XSBhcyAnYmVnaW5uZXInIHwgJ2ludGVybWVkaWF0ZScgfCAnYWR2YW5jZWQnLFxuICAgICAgICAgIHR5cGU6ICh2YWx1ZXNbOV0gfHwgJ3JlZ3VsYXInKSBhcyAncmVndWxhcicgfCAnYm9udXMnLFxuICAgICAgICAgIGZ1bkZhY3Q6IHZhbHVlc1sxMF0gfHwgdW5kZWZpbmVkLFxuICAgICAgICAgIHRhZ3M6IHZhbHVlc1sxMV0gPyB2YWx1ZXNbMTFdLnNwbGl0KCc7JykuZmlsdGVyKHQgPT4gdC50cmltKCkpIDogdW5kZWZpbmVkLFxuICAgICAgICAgIGNyZWF0ZWRBdDogdmFsdWVzWzEyXSA/IG5ldyBEYXRlKHZhbHVlc1sxMl0pLmdldFRpbWUoKSA6IERhdGUubm93KCksXG4gICAgICAgICAgdXBkYXRlZEF0OiB2YWx1ZXNbMTNdID8gbmV3IERhdGUodmFsdWVzWzEzXSkuZ2V0VGltZSgpIDogRGF0ZS5ub3coKVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gVmFsaWRhdGUgdGhlIHF1ZXN0aW9uXG4gICAgICAgIHRoaXMudmFsaWRhdGVRdWVzdGlvbihxdWVzdGlvbilcblxuICAgICAgICAvLyBDaGVjayBmb3IgZHVwbGljYXRlc1xuICAgICAgICBjb25zdCBleGlzdGluZ0luZGV4ID0gZXhpc3RpbmdRdWVzdGlvbnMuZmluZEluZGV4KHEgPT4gcS5pZCA9PT0gcXVlc3Rpb24uaWQpXG4gICAgICAgIGlmIChleGlzdGluZ0luZGV4ID49IDApIHtcbiAgICAgICAgICAvLyBVcGRhdGUgZXhpc3RpbmcgcXVlc3Rpb25cbiAgICAgICAgICBleGlzdGluZ1F1ZXN0aW9uc1tleGlzdGluZ0luZGV4XSA9IHF1ZXN0aW9uXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFsaWRRdWVzdGlvbnMucHVzaChxdWVzdGlvbilcbiAgICAgICAgfVxuXG4gICAgICAgIHJlc3VsdHMucHJvY2Vzc2VkQ291bnQrK1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgcmVzdWx0cy5lcnJvcnMucHVzaChgTGluZSAke2kgKyAyfTogJHtlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6ICdVbmtub3duIGVycm9yJ31gKVxuICAgICAgICByZXN1bHRzLmVycm9yQ291bnQrK1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFNhdmUgYWxsIHZhbGlkIHF1ZXN0aW9uc1xuICAgIGlmICh2YWxpZFF1ZXN0aW9ucy5sZW5ndGggPiAwKSB7XG4gICAgICBjb25zdCBhbGxRdWVzdGlvbnMgPSBbLi4uZXhpc3RpbmdRdWVzdGlvbnMsIC4uLnZhbGlkUXVlc3Rpb25zXVxuICAgICAgdGhpcy5zYXZlUXVlc3Rpb25zKGFsbFF1ZXN0aW9ucylcbiAgICB9XG5cbiAgICByZXN1bHRzLnN1Y2Nlc3MgPSByZXN1bHRzLmVycm9yQ291bnQgPT09IDBcbiAgICByZXR1cm4gcmVzdWx0c1xuICB9XG5cbiAgcHJpdmF0ZSBwYXJzZUNTVkxpbmUobGluZTogc3RyaW5nKTogc3RyaW5nW10ge1xuICAgIGNvbnN0IHJlc3VsdDogc3RyaW5nW10gPSBbXVxuICAgIGxldCBjdXJyZW50ID0gJydcbiAgICBsZXQgaW5RdW90ZXMgPSBmYWxzZVxuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaW5lLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBjaGFyID0gbGluZVtpXVxuXG4gICAgICBpZiAoY2hhciA9PT0gJ1wiJykge1xuICAgICAgICBpZiAoaW5RdW90ZXMgJiYgbGluZVtpICsgMV0gPT09ICdcIicpIHtcbiAgICAgICAgICBjdXJyZW50ICs9ICdcIidcbiAgICAgICAgICBpKysgLy8gU2tpcCBuZXh0IHF1b3RlXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaW5RdW90ZXMgPSAhaW5RdW90ZXNcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChjaGFyID09PSAnLCcgJiYgIWluUXVvdGVzKSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKGN1cnJlbnQudHJpbSgpKVxuICAgICAgICBjdXJyZW50ID0gJydcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGN1cnJlbnQgKz0gY2hhclxuICAgICAgfVxuICAgIH1cblxuICAgIHJlc3VsdC5wdXNoKGN1cnJlbnQudHJpbSgpKVxuICAgIHJldHVybiByZXN1bHRcbiAgfVxuXG4gIHByaXZhdGUgaW5pdGlhbGl6ZVdpdGhTYW1wbGVEYXRhKCk6IFF1aXpRdWVzdGlvbltdIHtcbiAgICAvLyBDaGVjayBpZiB3ZSBzaG91bGQgaW1wb3J0IGV4aXN0aW5nIHF1ZXN0aW9uc1xuICAgIGlmICh0aGlzLnNob3VsZEltcG9ydEV4aXN0aW5nUXVlc3Rpb25zKCkpIHtcbiAgICAgIHJldHVybiB0aGlzLmltcG9ydEFsbEV4aXN0aW5nUXVlc3Rpb25zKClcbiAgICB9XG5cbiAgICAvLyBJbml0aWFsaXplIHdpdGggYSBmZXcgc2FtcGxlIHF1ZXN0aW9ucyBmb3IgZGVtb25zdHJhdGlvblxuICAgIGNvbnN0IHNhbXBsZVF1ZXN0aW9uczogUXVpelF1ZXN0aW9uW10gPSBbXG4gICAgICB7XG4gICAgICAgIGlkOiAnc2FtcGxlXzEnLFxuICAgICAgICBxdWVzdGlvbjogJ1doaWNoIHNvY2lhbCBtZWRpYSBwbGF0Zm9ybSBpcyBrbm93biBmb3IgaXRzIHNob3J0LWZvcm0gdmlkZW8gY29udGVudCBhbmQgdmlyYWwgZGFuY2VzPycsXG4gICAgICAgIG9wdGlvbnM6IFsnSW5zdGFncmFtJywgJ1Rpa1RvaycsICdUd2l0dGVyJywgJ1NuYXBjaGF0J10sXG4gICAgICAgIGNvcnJlY3RBbnN3ZXI6IDEsXG4gICAgICAgIGNhdGVnb3J5OiAnc29jaWFsLW1lZGlhJyxcbiAgICAgICAgZGlmZmljdWx0eTogJ2JlZ2lubmVyJyxcbiAgICAgICAgdHlwZTogJ3JlZ3VsYXInLFxuICAgICAgICBzZWN0aW9uOiAnaG9tZXBhZ2UnLFxuICAgICAgICBmdW5GYWN0OiAnVGlrVG9rIHdhcyBvcmlnaW5hbGx5IGNhbGxlZCBNdXNpY2FsLmx5IGJlZm9yZSBiZWluZyBhY3F1aXJlZCBieSBCeXRlRGFuY2UuJyxcbiAgICAgICAgdGFnczogWydzb2NpYWwtbWVkaWEnLCAndmlkZW8nLCAndmlyYWwnXSxcbiAgICAgICAgY3JlYXRlZEF0OiBEYXRlLm5vdygpIC0gODY0MDAwMDAsIC8vIDEgZGF5IGFnb1xuICAgICAgICB1cGRhdGVkQXQ6IERhdGUubm93KCkgLSA4NjQwMDAwMFxuICAgICAgfVxuICAgICAgLy8gQWRkIG1vcmUgc2FtcGxlIHF1ZXN0aW9ucyBhcyBuZWVkZWRcbiAgICBdXG5cbiAgICB0aGlzLnNhdmVRdWVzdGlvbnMoc2FtcGxlUXVlc3Rpb25zKVxuICAgIHJldHVybiBzYW1wbGVRdWVzdGlvbnNcbiAgfVxuXG4gIC8vIENoZWNrIGlmIHdlIHNob3VsZCBpbXBvcnQgZXhpc3RpbmcgcXVlc3Rpb25zXG4gIHByaXZhdGUgc2hvdWxkSW1wb3J0RXhpc3RpbmdRdWVzdGlvbnMoKTogYm9vbGVhbiB7XG4gICAgLy8gT25seSBpbXBvcnQgaWYgbG9jYWxTdG9yYWdlIGlzIGVtcHR5IGFuZCB3ZSdyZSBvbiBjbGllbnQgc2lkZVxuICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykgcmV0dXJuIGZhbHNlXG5cbiAgICBjb25zdCBoYXNJbXBvcnRlZCA9IHRoaXMuc2FmZUdldEl0ZW0oJ3F1aXpfcXVlc3Rpb25zX2ltcG9ydGVkJylcbiAgICByZXR1cm4gIWhhc0ltcG9ydGVkXG4gIH1cblxuICAvLyBJbXBvcnQgYWxsIGV4aXN0aW5nIHF1ZXN0aW9ucyBmcm9tIGRpZmZlcmVudCBzb3VyY2VzXG4gIHByaXZhdGUgaW1wb3J0QWxsRXhpc3RpbmdRdWVzdGlvbnMoKTogUXVpelF1ZXN0aW9uW10ge1xuICAgIGNvbnN0IGFsbFF1ZXN0aW9uczogUXVpelF1ZXN0aW9uW10gPSBbXVxuXG4gICAgdHJ5IHtcbiAgICAgIC8vIEltcG9ydCBvbmJvYXJkaW5nIHF1ZXN0aW9uc1xuICAgICAgY29uc3Qgb25ib2FyZGluZ1F1ZXN0aW9ucyA9IHRoaXMuaW1wb3J0T25ib2FyZGluZ1F1ZXN0aW9ucygpXG4gICAgICBhbGxRdWVzdGlvbnMucHVzaCguLi5vbmJvYXJkaW5nUXVlc3Rpb25zKVxuXG4gICAgICAvLyBJbXBvcnQgaG9tZXBhZ2UgZmFsbGJhY2sgcXVlc3Rpb25zXG4gICAgICBjb25zdCBob21lcGFnZVF1ZXN0aW9ucyA9IHRoaXMuaW1wb3J0SG9tZXBhZ2VRdWVzdGlvbnMoKVxuICAgICAgYWxsUXVlc3Rpb25zLnB1c2goLi4uaG9tZXBhZ2VRdWVzdGlvbnMpXG5cbiAgICAgIC8vIEltcG9ydCBjYXRlZ29yeSBxdWVzdGlvbnMgZnJvbSBxdWl6IGRhdGFiYXNlXG4gICAgICBjb25zdCBjYXRlZ29yeVF1ZXN0aW9ucyA9IHRoaXMuaW1wb3J0Q2F0ZWdvcnlRdWVzdGlvbnMoKVxuICAgICAgYWxsUXVlc3Rpb25zLnB1c2goLi4uY2F0ZWdvcnlRdWVzdGlvbnMpXG5cbiAgICAgIGNvbnNvbGUubG9nKGDwn5OKIEltcG9ydGVkICR7YWxsUXVlc3Rpb25zLmxlbmd0aH0gcXVlc3Rpb25zIGZyb20gZXhpc3Rpbmcgc291cmNlc2ApXG5cbiAgICAgIC8vIFNhdmUgYWxsIGltcG9ydGVkIHF1ZXN0aW9uc1xuICAgICAgdGhpcy5zYXZlUXVlc3Rpb25zKGFsbFF1ZXN0aW9ucylcblxuICAgICAgLy8gTWFyayBhcyBpbXBvcnRlZFxuICAgICAgdGhpcy5zYWZlU2V0SXRlbSgncXVpel9xdWVzdGlvbnNfaW1wb3J0ZWQnLCAndHJ1ZScpXG5cbiAgICAgIHJldHVybiBhbGxRdWVzdGlvbnNcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgaW1wb3J0aW5nIGV4aXN0aW5nIHF1ZXN0aW9uczonLCBlcnJvcilcbiAgICAgIHJldHVybiBbXVxuICAgIH1cbiAgfVxuXG4gIC8vIEltcG9ydCBtZXRob2RzIGZvciBleGlzdGluZyBxdWVzdGlvbnNcbiAgcHJpdmF0ZSBpbXBvcnRPbmJvYXJkaW5nUXVlc3Rpb25zKCk6IFF1aXpRdWVzdGlvbltdIHtcbiAgICBjb25zdCBvbmJvYXJkaW5nUXVlc3Rpb25zID0gW1xuICAgICAge1xuICAgICAgICBpZDogJ29uYm9hcmQtMScsXG4gICAgICAgIHF1ZXN0aW9uOiBcIldoaWNoIHRlY2ggY29tcGFueSBjcmVhdGVkIHRoZSBpUGhvbmU/XCIsXG4gICAgICAgIG9wdGlvbnM6IFtcIkFwcGxlIPCfjY5cIiwgXCJHb29nbGUg8J+UjVwiLCBcIlNhbXN1bmcg8J+TsVwiLCBcIk1pY3Jvc29mdCDwn5K7XCJdLFxuICAgICAgICBjb3JyZWN0QW5zd2VyOiAwLFxuICAgICAgICBjYXRlZ29yeTogJ3RlY2hub2xvZ3knLFxuICAgICAgICBkaWZmaWN1bHR5OiAnYmVnaW5uZXInIGFzIGNvbnN0LFxuICAgICAgICB0eXBlOiAncmVndWxhcicgYXMgY29uc3QsXG4gICAgICAgIHNlY3Rpb246ICdvbmJvYXJkaW5nJyBhcyBjb25zdCxcbiAgICAgICAgcmV3YXJkQ29pbnM6IDE1MCxcbiAgICAgICAgZnVuRmFjdDogXCJUaGUgZmlyc3QgaVBob25lIHdhcyByZWxlYXNlZCBvbiBKdW5lIDI5LCAyMDA3LCByZXZvbHV0aW9uaXppbmcgdGhlIHNtYXJ0cGhvbmUgaW5kdXN0cnkuXCIsXG4gICAgICAgIHRhZ3M6IFsndGVjaG5vbG9neScsICdhcHBsZScsICdzbWFydHBob25lJ10sXG4gICAgICAgIGNyZWF0ZWRBdDogRGF0ZS5ub3coKSxcbiAgICAgICAgdXBkYXRlZEF0OiBEYXRlLm5vdygpXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBpZDogJ29uYm9hcmQtMicsXG4gICAgICAgIHF1ZXN0aW9uOiBcIldoYXQgZG9lcyAnV1dXJyBzdGFuZCBmb3I/XCIsXG4gICAgICAgIG9wdGlvbnM6IFtcIldvcmxkIFdpZGUgV2ViIPCfjJBcIiwgXCJXb3JsZCBXZWIgV29ya3Mg8J+Up1wiLCBcIldlYiBXb3JsZCBXaWRlIPCfjI1cIiwgXCJXaWRlIFdvcmxkIFdlYiDwn5OhXCJdLFxuICAgICAgICBjb3JyZWN0QW5zd2VyOiAwLFxuICAgICAgICBjYXRlZ29yeTogJ3RlY2hub2xvZ3knLFxuICAgICAgICBkaWZmaWN1bHR5OiAnYmVnaW5uZXInIGFzIGNvbnN0LFxuICAgICAgICB0eXBlOiAncmVndWxhcicgYXMgY29uc3QsXG4gICAgICAgIHNlY3Rpb246ICdvbmJvYXJkaW5nJyBhcyBjb25zdCxcbiAgICAgICAgcmV3YXJkQ29pbnM6IDE1MCxcbiAgICAgICAgZnVuRmFjdDogXCJUaGUgV29ybGQgV2lkZSBXZWIgd2FzIGludmVudGVkIGJ5IFRpbSBCZXJuZXJzLUxlZSBpbiAxOTg5IHdoaWxlIHdvcmtpbmcgYXQgQ0VSTi5cIixcbiAgICAgICAgdGFnczogWyd0ZWNobm9sb2d5JywgJ2ludGVybmV0JywgJ3dlYiddLFxuICAgICAgICBjcmVhdGVkQXQ6IERhdGUubm93KCksXG4gICAgICAgIHVwZGF0ZWRBdDogRGF0ZS5ub3coKVxuICAgICAgfVxuICAgIF1cblxuICAgIHJldHVybiBvbmJvYXJkaW5nUXVlc3Rpb25zXG4gIH1cblxuICBwcml2YXRlIGltcG9ydEhvbWVwYWdlUXVlc3Rpb25zKCk6IFF1aXpRdWVzdGlvbltdIHtcbiAgICBjb25zdCBob21lcGFnZVF1ZXN0aW9ucyA9IFtcbiAgICAgIHtcbiAgICAgICAgaWQ6ICdob21lcGFnZS0xJyxcbiAgICAgICAgcXVlc3Rpb246IFwiV2hpY2ggc29jaWFsIG1lZGlhIHBsYXRmb3JtIGlzIGtub3duIGZvciBzaG9ydC1mb3JtIHZpZGVvcz9cIixcbiAgICAgICAgb3B0aW9uczogW1wiSW5zdGFncmFtXCIsIFwiVGlrVG9rXCIsIFwiVHdpdHRlclwiLCBcIlNuYXBjaGF0XCJdLFxuICAgICAgICBjb3JyZWN0QW5zd2VyOiAxLFxuICAgICAgICBjYXRlZ29yeTogJ3NvY2lhbC1tZWRpYScsXG4gICAgICAgIGRpZmZpY3VsdHk6ICdiZWdpbm5lcicgYXMgY29uc3QsXG4gICAgICAgIHR5cGU6ICdyZWd1bGFyJyBhcyBjb25zdCxcbiAgICAgICAgc2VjdGlvbjogJ2hvbWVwYWdlJyBhcyBjb25zdCxcbiAgICAgICAgZnVuRmFjdDogXCJUaWtUb2sgd2FzIG9yaWdpbmFsbHkgY2FsbGVkIE11c2ljYWwubHkhXCIsXG4gICAgICAgIHRhZ3M6IFsnc29jaWFsLW1lZGlhJywgJ3ZpZGVvJywgJ2FwcHMnXSxcbiAgICAgICAgY3JlYXRlZEF0OiBEYXRlLm5vdygpLFxuICAgICAgICB1cGRhdGVkQXQ6IERhdGUubm93KClcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGlkOiAnaG9tZXBhZ2UtMicsXG4gICAgICAgIHF1ZXN0aW9uOiBcIldoYXQgZG9lcyAnQUknIHN0YW5kIGZvcj9cIixcbiAgICAgICAgb3B0aW9uczogW1wiQXJ0aWZpY2lhbCBJbnRlbGxpZ2VuY2VcIiwgXCJBdXRvbWF0ZWQgSW50ZXJuZXRcIiwgXCJBZHZhbmNlZCBJbnRlcmZhY2VcIiwgXCJBbGdvcml0aG1pYyBJbnRlZ3JhdGlvblwiXSxcbiAgICAgICAgY29ycmVjdEFuc3dlcjogMCxcbiAgICAgICAgY2F0ZWdvcnk6ICd0ZWNobm9sb2d5JyxcbiAgICAgICAgZGlmZmljdWx0eTogJ2JlZ2lubmVyJyBhcyBjb25zdCxcbiAgICAgICAgdHlwZTogJ3JlZ3VsYXInIGFzIGNvbnN0LFxuICAgICAgICBzZWN0aW9uOiAnaG9tZXBhZ2UnIGFzIGNvbnN0LFxuICAgICAgICBmdW5GYWN0OiBcIlRoZSB0ZXJtICdBcnRpZmljaWFsIEludGVsbGlnZW5jZScgd2FzIGZpcnN0IGNvaW5lZCBpbiAxOTU2IVwiLFxuICAgICAgICB0YWdzOiBbJ3RlY2hub2xvZ3knLCAnYWknLCAnY29tcHV0aW5nJ10sXG4gICAgICAgIGNyZWF0ZWRBdDogRGF0ZS5ub3coKSxcbiAgICAgICAgdXBkYXRlZEF0OiBEYXRlLm5vdygpXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBpZDogJ2hvbWVwYWdlLTMnLFxuICAgICAgICBxdWVzdGlvbjogXCJXaGljaCBjb21wYW55IGNyZWF0ZWQgdGhlIGlQaG9uZT9cIixcbiAgICAgICAgb3B0aW9uczogW1wiR29vZ2xlXCIsIFwiU2Ftc3VuZ1wiLCBcIkFwcGxlXCIsIFwiTWljcm9zb2Z0XCJdLFxuICAgICAgICBjb3JyZWN0QW5zd2VyOiAyLFxuICAgICAgICBjYXRlZ29yeTogJ3RlY2hub2xvZ3knLFxuICAgICAgICBkaWZmaWN1bHR5OiAnYmVnaW5uZXInIGFzIGNvbnN0LFxuICAgICAgICB0eXBlOiAncmVndWxhcicgYXMgY29uc3QsXG4gICAgICAgIHNlY3Rpb246ICdob21lcGFnZScgYXMgY29uc3QsXG4gICAgICAgIGZ1bkZhY3Q6IFwiVGhlIGZpcnN0IGlQaG9uZSB3YXMgcmVsZWFzZWQgaW4gMjAwNyFcIixcbiAgICAgICAgdGFnczogWyd0ZWNobm9sb2d5JywgJ2FwcGxlJywgJ3NtYXJ0cGhvbmUnXSxcbiAgICAgICAgY3JlYXRlZEF0OiBEYXRlLm5vdygpLFxuICAgICAgICB1cGRhdGVkQXQ6IERhdGUubm93KClcbiAgICAgIH1cbiAgICBdXG5cbiAgICByZXR1cm4gaG9tZXBhZ2VRdWVzdGlvbnNcbiAgfVxuXG4gIHByaXZhdGUgaW1wb3J0Q2F0ZWdvcnlRdWVzdGlvbnMoKTogUXVpelF1ZXN0aW9uW10ge1xuICAgIC8vIEltcG9ydCBhIHN1YnNldCBvZiBxdWVzdGlvbnMgZnJvbSB0aGUgcXVpeiBkYXRhYmFzZVxuICAgIGNvbnN0IGNhdGVnb3J5UXVlc3Rpb25zOiBRdWl6UXVlc3Rpb25bXSA9IFtdXG5cbiAgICB0cnkge1xuICAgICAgLy8gU2FtcGxlIGNhdGVnb3J5IHF1ZXN0aW9ucyAtIGluIGEgcmVhbCBpbXBsZW1lbnRhdGlvbiwgdGhpcyB3b3VsZCBpbXBvcnQgZnJvbSB0aGUgYWN0dWFsIHF1aXogZGF0YWJhc2VcbiAgICAgIGNvbnN0IHNhbXBsZUNhdGVnb3J5UXVlc3Rpb25zID0gW1xuICAgICAgICB7XG4gICAgICAgICAgaWQ6ICdjYXQtdGVjaC0xJyxcbiAgICAgICAgICBxdWVzdGlvbjogXCJXaGljaCBwcm9ncmFtbWluZyBsYW5ndWFnZSBpcyBrbm93biBmb3IgaXRzIHVzZSBpbiB3ZWIgZGV2ZWxvcG1lbnQgYW5kIGhhcyBhIGNvZmZlZS1yZWxhdGVkIG5hbWU/XCIsXG4gICAgICAgICAgb3B0aW9uczogW1wiUHl0aG9uXCIsIFwiSmF2YVwiLCBcIkphdmFTY3JpcHRcIiwgXCJDKytcIl0sXG4gICAgICAgICAgY29ycmVjdEFuc3dlcjogMSxcbiAgICAgICAgICBjYXRlZ29yeTogJ3RlY2hub2xvZ3knLFxuICAgICAgICAgIGRpZmZpY3VsdHk6ICdpbnRlcm1lZGlhdGUnIGFzIGNvbnN0LFxuICAgICAgICAgIHR5cGU6ICdyZWd1bGFyJyBhcyBjb25zdCxcbiAgICAgICAgICBzZWN0aW9uOiAnY2F0ZWdvcnknIGFzIGNvbnN0LFxuICAgICAgICAgIHN1YmNhdGVnb3J5OiAncHJvZ3JhbW1pbmcnLFxuICAgICAgICAgIGZ1bkZhY3Q6IFwiSmF2YSB3YXMgb3JpZ2luYWxseSBjYWxsZWQgT2FrIGFuZCB3YXMgZGV2ZWxvcGVkIGJ5IEphbWVzIEdvc2xpbmcgYXQgU3VuIE1pY3Jvc3lzdGVtcy5cIixcbiAgICAgICAgICB0YWdzOiBbJ3Byb2dyYW1taW5nJywgJ2phdmEnLCAnZGV2ZWxvcG1lbnQnXSxcbiAgICAgICAgICBjcmVhdGVkQXQ6IERhdGUubm93KCksXG4gICAgICAgICAgdXBkYXRlZEF0OiBEYXRlLm5vdygpXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICBpZDogJ2NhdC1zb2NpYWwtMScsXG4gICAgICAgICAgcXVlc3Rpb246IFwiV2hpY2ggc29jaWFsIG1lZGlhIHBsYXRmb3JtIHdhcyBvcmlnaW5hbGx5IGNhbGxlZCAnVGhlIEZhY2Vib29rJz9cIixcbiAgICAgICAgICBvcHRpb25zOiBbXCJJbnN0YWdyYW1cIiwgXCJUd2l0dGVyXCIsIFwiRmFjZWJvb2tcIiwgXCJMaW5rZWRJblwiXSxcbiAgICAgICAgICBjb3JyZWN0QW5zd2VyOiAyLFxuICAgICAgICAgIGNhdGVnb3J5OiAnc29jaWFsLW1lZGlhJyxcbiAgICAgICAgICBkaWZmaWN1bHR5OiAnYmVnaW5uZXInIGFzIGNvbnN0LFxuICAgICAgICAgIHR5cGU6ICdyZWd1bGFyJyBhcyBjb25zdCxcbiAgICAgICAgICBzZWN0aW9uOiAnY2F0ZWdvcnknIGFzIGNvbnN0LFxuICAgICAgICAgIHN1YmNhdGVnb3J5OiAnaGlzdG9yeScsXG4gICAgICAgICAgZnVuRmFjdDogXCJGYWNlYm9vayB3YXMgZm91bmRlZCBieSBNYXJrIFp1Y2tlcmJlcmcgaW4gMjAwNCB3aGlsZSBoZSB3YXMgYSBzdHVkZW50IGF0IEhhcnZhcmQgVW5pdmVyc2l0eS5cIixcbiAgICAgICAgICB0YWdzOiBbJ3NvY2lhbC1tZWRpYScsICdmYWNlYm9vaycsICdoaXN0b3J5J10sXG4gICAgICAgICAgY3JlYXRlZEF0OiBEYXRlLm5vdygpLFxuICAgICAgICAgIHVwZGF0ZWRBdDogRGF0ZS5ub3coKVxuICAgICAgICB9XG4gICAgICBdXG5cbiAgICAgIGNhdGVnb3J5UXVlc3Rpb25zLnB1c2goLi4uc2FtcGxlQ2F0ZWdvcnlRdWVzdGlvbnMpXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGltcG9ydGluZyBjYXRlZ29yeSBxdWVzdGlvbnM6JywgZXJyb3IpXG4gICAgfVxuXG4gICAgcmV0dXJuIGNhdGVnb3J5UXVlc3Rpb25zXG4gIH1cblxuICAvLyBGb3JjZSByZWltcG9ydCBvZiBhbGwgcXVlc3Rpb25zIChmb3IgYWRtaW4gdXNlKVxuICBmb3JjZVJlaW1wb3J0UXVlc3Rpb25zKCk6IEJ1bGtPcGVyYXRpb25SZXN1bHQge1xuICAgIHRyeSB7XG4gICAgICAvLyBDbGVhciB0aGUgaW1wb3J0IGZsYWdcbiAgICAgIHRoaXMuc2FmZVNldEl0ZW0oJ3F1aXpfcXVlc3Rpb25zX2ltcG9ydGVkJywgJycpXG5cbiAgICAgIC8vIENsZWFyIGV4aXN0aW5nIHF1ZXN0aW9uc1xuICAgICAgdGhpcy5zYWZlU2V0SXRlbShRVUlaX1NUT1JBR0VfS0VZUy5RVUVTVElPTlMsICcnKVxuXG4gICAgICAvLyBJbXBvcnQgYWxsIHF1ZXN0aW9uc1xuICAgICAgY29uc3QgaW1wb3J0ZWRRdWVzdGlvbnMgPSB0aGlzLmltcG9ydEFsbEV4aXN0aW5nUXVlc3Rpb25zKClcblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc3VjY2VzczogdHJ1ZSxcbiAgICAgICAgcHJvY2Vzc2VkQ291bnQ6IGltcG9ydGVkUXVlc3Rpb25zLmxlbmd0aCxcbiAgICAgICAgZXJyb3JDb3VudDogMCxcbiAgICAgICAgZXJyb3JzOiBbXVxuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgcHJvY2Vzc2VkQ291bnQ6IDAsXG4gICAgICAgIGVycm9yQ291bnQ6IDEsXG4gICAgICAgIGVycm9yczogW2Vycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogJ0ltcG9ydCBmYWlsZWQnXVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIEJhY2t1cCBhbmQgcmVzdG9yZSBmdW5jdGlvbmFsaXR5XG4gIGNyZWF0ZUJhY2t1cCgpOiBzdHJpbmcge1xuICAgIGNvbnN0IGJhY2t1cCA9IHtcbiAgICAgIHF1ZXN0aW9uczogdGhpcy5nZXRRdWVzdGlvbnMoKSxcbiAgICAgIHNldHRpbmdzOiB0aGlzLmdldFNldHRpbmdzKCksXG4gICAgICBkcmFmdHM6IHRoaXMuZ2V0RHJhZnRzKCksXG4gICAgICB0aW1lc3RhbXA6IERhdGUubm93KCksXG4gICAgICB2ZXJzaW9uOiAnMS4wJ1xuICAgIH1cblxuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShiYWNrdXAsIG51bGwsIDIpXG4gIH1cblxuICByZXN0b3JlRnJvbUJhY2t1cChiYWNrdXBEYXRhOiBzdHJpbmcpOiBCdWxrT3BlcmF0aW9uUmVzdWx0IHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgYmFja3VwID0gSlNPTi5wYXJzZShiYWNrdXBEYXRhKVxuXG4gICAgICBpZiAoIWJhY2t1cC5xdWVzdGlvbnMgfHwgIUFycmF5LmlzQXJyYXkoYmFja3VwLnF1ZXN0aW9ucykpIHtcbiAgICAgICAgdGhyb3cgbmV3IFF1aXpEYXRhRXJyb3IoJ0ludmFsaWQgYmFja3VwIGZvcm1hdDogbWlzc2luZyBxdWVzdGlvbnMgYXJyYXknLCAnSU5WQUxJRF9CQUNLVVAnKVxuICAgICAgfVxuXG4gICAgICAvLyBWYWxpZGF0ZSBhbGwgcXVlc3Rpb25zIGluIGJhY2t1cFxuICAgICAgYmFja3VwLnF1ZXN0aW9ucy5mb3JFYWNoKChxOiBhbnksIGluZGV4OiBudW1iZXIpID0+IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB0aGlzLnZhbGlkYXRlUXVlc3Rpb24ocSlcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgUXVpekRhdGFFcnJvcihcbiAgICAgICAgICAgIGBJbnZhbGlkIHF1ZXN0aW9uIGF0IGluZGV4ICR7aW5kZXh9OiAke2Vycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogJ1Vua25vd24gZXJyb3InfWAsXG4gICAgICAgICAgICAnSU5WQUxJRF9CQUNLVVBfUVVFU1RJT04nXG4gICAgICAgICAgKVxuICAgICAgICB9XG4gICAgICB9KVxuXG4gICAgICAvLyBDcmVhdGUgY3VycmVudCBiYWNrdXAgYmVmb3JlIHJlc3RvcmVcbiAgICAgIGNvbnN0IGN1cnJlbnRCYWNrdXAgPSB0aGlzLmNyZWF0ZUJhY2t1cCgpXG4gICAgICB0aGlzLnNhZmVTZXRJdGVtKFFVSVpfU1RPUkFHRV9LRVlTLkJBQ0tVUCwgY3VycmVudEJhY2t1cClcblxuICAgICAgLy8gUmVzdG9yZSBkYXRhXG4gICAgICB0aGlzLnNhdmVRdWVzdGlvbnMoYmFja3VwLnF1ZXN0aW9ucylcbiAgICAgIGlmIChiYWNrdXAuc2V0dGluZ3MpIHtcbiAgICAgICAgdGhpcy5zYWZlU2V0SXRlbShRVUlaX1NUT1JBR0VfS0VZUy5TRVRUSU5HUywgSlNPTi5zdHJpbmdpZnkoYmFja3VwLnNldHRpbmdzKSlcbiAgICAgIH1cbiAgICAgIGlmIChiYWNrdXAuZHJhZnRzKSB7XG4gICAgICAgIHRoaXMuc2FmZVNldEl0ZW0oUVVJWl9TVE9SQUdFX0tFWVMuRFJBRlRTLCBKU09OLnN0cmluZ2lmeShiYWNrdXAuZHJhZnRzKSlcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc3VjY2VzczogdHJ1ZSxcbiAgICAgICAgcHJvY2Vzc2VkQ291bnQ6IGJhY2t1cC5xdWVzdGlvbnMubGVuZ3RoLFxuICAgICAgICBlcnJvckNvdW50OiAwLFxuICAgICAgICBlcnJvcnM6IFtdXG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHRocm93IG5ldyBRdWl6RGF0YUVycm9yKFxuICAgICAgICBgRmFpbGVkIHRvIHJlc3RvcmUgYmFja3VwOiAke2Vycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogJ1Vua25vd24gZXJyb3InfWAsXG4gICAgICAgICdSRVNUT1JFX0ZBSUxFRCdcbiAgICAgIClcbiAgICB9XG4gIH1cblxuICAvLyBBdXRvLXNhdmUgZnVuY3Rpb25hbGl0eSBmb3IgZHJhZnRzXG4gIHN0YXJ0QXV0b1NhdmUoZHJhZnRJZDogc3RyaW5nLCBnZXREcmFmdERhdGE6ICgpID0+IFBhcnRpYWw8UXVlc3Rpb25EcmFmdD4pOiB2b2lkIHtcbiAgICB0aGlzLnN0b3BBdXRvU2F2ZSgpXG5cbiAgICB0aGlzLmF1dG9TYXZlVGltZXIgPSBzZXRJbnRlcnZhbCgoKSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBkcmFmdERhdGEgPSBnZXREcmFmdERhdGEoKVxuICAgICAgICBpZiAoZHJhZnREYXRhLnF1ZXN0aW9uICYmIGRyYWZ0RGF0YS5xdWVzdGlvbi5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgY29uc3QgZHJhZnQ6IFF1ZXN0aW9uRHJhZnQgPSB7XG4gICAgICAgICAgICBpZDogZHJhZnRJZCxcbiAgICAgICAgICAgIHF1ZXN0aW9uOiBkcmFmdERhdGEucXVlc3Rpb24gfHwgJycsXG4gICAgICAgICAgICBvcHRpb25zOiBkcmFmdERhdGEub3B0aW9ucyB8fCBbJycsICcnLCAnJywgJyddLFxuICAgICAgICAgICAgY29ycmVjdEFuc3dlcjogZHJhZnREYXRhLmNvcnJlY3RBbnN3ZXIgfHwgMCxcbiAgICAgICAgICAgIGNhdGVnb3J5OiBkcmFmdERhdGEuY2F0ZWdvcnkgfHwgJ2ZhY3RzJyxcbiAgICAgICAgICAgIGRpZmZpY3VsdHk6IGRyYWZ0RGF0YS5kaWZmaWN1bHR5IHx8ICdiZWdpbm5lcicsXG4gICAgICAgICAgICB0eXBlOiBkcmFmdERhdGEudHlwZSB8fCAncmVndWxhcicsXG4gICAgICAgICAgICBmdW5GYWN0OiBkcmFmdERhdGEuZnVuRmFjdCxcbiAgICAgICAgICAgIHRhZ3M6IGRyYWZ0RGF0YS50YWdzLFxuICAgICAgICAgICAgbGFzdFNhdmVkOiBEYXRlLm5vdygpXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGhpcy5zYXZlRHJhZnQoZHJhZnQpXG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0F1dG8tc2F2ZSBmYWlsZWQ6JywgZXJyb3IpXG4gICAgICB9XG4gICAgfSwgVkFMSURBVElPTl9SVUxFUy5BVVRPX1NBVkVfSU5URVJWQUwpXG4gIH1cblxuICBzdG9wQXV0b1NhdmUoKTogdm9pZCB7XG4gICAgaWYgKHRoaXMuYXV0b1NhdmVUaW1lcikge1xuICAgICAgY2xlYXJJbnRlcnZhbCh0aGlzLmF1dG9TYXZlVGltZXIpXG4gICAgICB0aGlzLmF1dG9TYXZlVGltZXIgPSBudWxsXG4gICAgfVxuICB9XG5cbiAgLy8gQ1NWIEV4cG9ydCBmdW5jdGlvbmFsaXR5XG4gIGV4cG9ydFRvQ1NWKHF1ZXN0aW9uc1RvRXhwb3J0PzogUXVpelF1ZXN0aW9uW10pOiBzdHJpbmcge1xuICAgIGNvbnN0IHF1ZXN0aW9ucyA9IHF1ZXN0aW9uc1RvRXhwb3J0IHx8IHRoaXMuZ2V0UXVlc3Rpb25zKClcbiAgICBjb25zdCBoZWFkZXJzID0gW1xuICAgICAgJ0lEJyxcbiAgICAgICdRdWVzdGlvbicsXG4gICAgICAnT3B0aW9uIDEnLFxuICAgICAgJ09wdGlvbiAyJyxcbiAgICAgICdPcHRpb24gMycsXG4gICAgICAnT3B0aW9uIDQnLFxuICAgICAgJ0NvcnJlY3QgQW5zd2VyICgxLTQpJyxcbiAgICAgICdDYXRlZ29yeScsXG4gICAgICAnRGlmZmljdWx0eScsXG4gICAgICAnVHlwZScsXG4gICAgICAnRnVuIEZhY3QnLFxuICAgICAgJ1RhZ3MnLFxuICAgICAgJ0NyZWF0ZWQgQXQnLFxuICAgICAgJ1VwZGF0ZWQgQXQnXG4gICAgXVxuXG4gICAgY29uc3QgY3N2Um93cyA9IFtoZWFkZXJzLmpvaW4oJywnKV1cblxuICAgIHF1ZXN0aW9ucy5mb3JFYWNoKHF1ZXN0aW9uID0+IHtcbiAgICAgIGNvbnN0IHJvdyA9IFtcbiAgICAgICAgcXVlc3Rpb24uaWQsXG4gICAgICAgIGBcIiR7cXVlc3Rpb24ucXVlc3Rpb24ucmVwbGFjZSgvXCIvZywgJ1wiXCInKX1cImAsIC8vIEVzY2FwZSBxdW90ZXNcbiAgICAgICAgYFwiJHtxdWVzdGlvbi5vcHRpb25zWzBdPy5yZXBsYWNlKC9cIi9nLCAnXCJcIicpIHx8ICcnfVwiYCxcbiAgICAgICAgYFwiJHtxdWVzdGlvbi5vcHRpb25zWzFdPy5yZXBsYWNlKC9cIi9nLCAnXCJcIicpIHx8ICcnfVwiYCxcbiAgICAgICAgYFwiJHtxdWVzdGlvbi5vcHRpb25zWzJdPy5yZXBsYWNlKC9cIi9nLCAnXCJcIicpIHx8ICcnfVwiYCxcbiAgICAgICAgYFwiJHtxdWVzdGlvbi5vcHRpb25zWzNdPy5yZXBsYWNlKC9cIi9nLCAnXCJcIicpIHx8ICcnfVwiYCxcbiAgICAgICAgcXVlc3Rpb24uY29ycmVjdEFuc3dlciArIDEsIC8vIENvbnZlcnQgMC1iYXNlZCB0byAxLWJhc2VkXG4gICAgICAgIHF1ZXN0aW9uLmNhdGVnb3J5LFxuICAgICAgICBxdWVzdGlvbi5kaWZmaWN1bHR5LFxuICAgICAgICBxdWVzdGlvbi50eXBlLFxuICAgICAgICBgXCIkeyhxdWVzdGlvbi5mdW5GYWN0IHx8ICcnKS5yZXBsYWNlKC9cIi9nLCAnXCJcIicpfVwiYCxcbiAgICAgICAgYFwiJHsocXVlc3Rpb24udGFncyB8fCBbXSkuam9pbignOycpfVwiYCxcbiAgICAgICAgbmV3IERhdGUocXVlc3Rpb24uY3JlYXRlZEF0KS50b0lTT1N0cmluZygpLFxuICAgICAgICBuZXcgRGF0ZShxdWVzdGlvbi51cGRhdGVkQXQpLnRvSVNPU3RyaW5nKClcbiAgICAgIF1cbiAgICAgIGNzdlJvd3MucHVzaChyb3cuam9pbignLCcpKVxuICAgIH0pXG5cbiAgICByZXR1cm4gY3N2Um93cy5qb2luKCdcXG4nKVxuICB9XG5cbiAgLy8gRG93bmxvYWQgQ1NWIGZpbGVcbiAgZG93bmxvYWRDU1YoKTogdm9pZCB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGNzdkNvbnRlbnQgPSB0aGlzLmV4cG9ydFRvQ1NWKClcbiAgICAgIGNvbnN0IGJsb2IgPSBuZXcgQmxvYihbY3N2Q29udGVudF0sIHsgdHlwZTogJ3RleHQvY3N2O2NoYXJzZXQ9dXRmLTg7JyB9KVxuICAgICAgY29uc3QgbGluayA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2EnKVxuXG4gICAgICBpZiAobGluay5kb3dubG9hZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNvbnN0IHVybCA9IFVSTC5jcmVhdGVPYmplY3RVUkwoYmxvYilcbiAgICAgICAgbGluay5zZXRBdHRyaWJ1dGUoJ2hyZWYnLCB1cmwpXG4gICAgICAgIGxpbmsuc2V0QXR0cmlidXRlKCdkb3dubG9hZCcsIGB0ZWNoa3dpei1xdWVzdGlvbnMtJHtuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCkuc3BsaXQoJ1QnKVswXX0uY3N2YClcbiAgICAgICAgbGluay5zdHlsZS52aXNpYmlsaXR5ID0gJ2hpZGRlbidcbiAgICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChsaW5rKVxuICAgICAgICBsaW5rLmNsaWNrKClcbiAgICAgICAgZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZChsaW5rKVxuICAgICAgICBVUkwucmV2b2tlT2JqZWN0VVJMKHVybClcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgdGhyb3cgbmV3IFF1aXpEYXRhRXJyb3IoJ0ZhaWxlZCB0byBkb3dubG9hZCBDU1YgZmlsZScsICdFWFBPUlRfRVJST1InKVxuICAgIH1cbiAgfVxuXG4gIC8vIFBhcnNlIENTViBjb250ZW50XG4gIHBhcnNlQ1NWKGNzdkNvbnRlbnQ6IHN0cmluZyk6IHsgcXVlc3Rpb25zOiBQYXJ0aWFsPFF1aXpRdWVzdGlvbj5bXTsgZXJyb3JzOiBzdHJpbmdbXSB9IHtcbiAgICBjb25zdCBsaW5lcyA9IGNzdkNvbnRlbnQuc3BsaXQoJ1xcbicpLmZpbHRlcihsaW5lID0+IGxpbmUudHJpbSgpKVxuICAgIGNvbnN0IGVycm9yczogc3RyaW5nW10gPSBbXVxuICAgIGNvbnN0IHF1ZXN0aW9uczogUGFydGlhbDxRdWl6UXVlc3Rpb24+W10gPSBbXVxuXG4gICAgaWYgKGxpbmVzLmxlbmd0aCA8IDIpIHtcbiAgICAgIGVycm9ycy5wdXNoKCdDU1YgZmlsZSBtdXN0IGNvbnRhaW4gYXQgbGVhc3QgYSBoZWFkZXIgcm93IGFuZCBvbmUgZGF0YSByb3cnKVxuICAgICAgcmV0dXJuIHsgcXVlc3Rpb25zLCBlcnJvcnMgfVxuICAgIH1cblxuICAgIC8vIFNraXAgaGVhZGVyIHJvd1xuICAgIGNvbnN0IGRhdGFMaW5lcyA9IGxpbmVzLnNsaWNlKDEpXG5cbiAgICBkYXRhTGluZXMuZm9yRWFjaCgobGluZSwgaW5kZXgpID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHZhbHVlcyA9IHRoaXMucGFyc2VDU1ZMaW5lKGxpbmUpXG5cbiAgICAgICAgaWYgKHZhbHVlcy5sZW5ndGggPCA4KSB7XG4gICAgICAgICAgZXJyb3JzLnB1c2goYFJvdyAke2luZGV4ICsgMn06IEluc3VmZmljaWVudCBjb2x1bW5zIChtaW5pbXVtIDggcmVxdWlyZWQpYClcbiAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IFtpZCwgcXVlc3Rpb24sIG9wdDEsIG9wdDIsIG9wdDMsIG9wdDQsIGNvcnJlY3RBbnN3ZXIsIGNhdGVnb3J5LCBkaWZmaWN1bHR5LCB0eXBlLCBmdW5GYWN0LCB0YWdzLCBjcmVhdGVkQXQsIHVwZGF0ZWRBdF0gPSB2YWx1ZXNcblxuICAgICAgICAvLyBWYWxpZGF0ZSByZXF1aXJlZCBmaWVsZHNcbiAgICAgICAgaWYgKCFxdWVzdGlvbj8udHJpbSgpKSB7XG4gICAgICAgICAgZXJyb3JzLnB1c2goYFJvdyAke2luZGV4ICsgMn06IFF1ZXN0aW9uIGlzIHJlcXVpcmVkYClcbiAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghb3B0MT8udHJpbSgpIHx8ICFvcHQyPy50cmltKCkgfHwgIW9wdDM/LnRyaW0oKSB8fCAhb3B0ND8udHJpbSgpKSB7XG4gICAgICAgICAgZXJyb3JzLnB1c2goYFJvdyAke2luZGV4ICsgMn06IEFsbCA0IG9wdGlvbnMgYXJlIHJlcXVpcmVkYClcbiAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGNvcnJlY3RBbnN3ZXJOdW0gPSBwYXJzZUludChjb3JyZWN0QW5zd2VyKSAtIDEgLy8gQ29udmVydCAxLWJhc2VkIHRvIDAtYmFzZWRcbiAgICAgICAgaWYgKGlzTmFOKGNvcnJlY3RBbnN3ZXJOdW0pIHx8IGNvcnJlY3RBbnN3ZXJOdW0gPCAwIHx8IGNvcnJlY3RBbnN3ZXJOdW0gPiAzKSB7XG4gICAgICAgICAgZXJyb3JzLnB1c2goYFJvdyAke2luZGV4ICsgMn06IENvcnJlY3QgYW5zd2VyIG11c3QgYmUgMSwgMiwgMywgb3IgNGApXG4gICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWNhdGVnb3J5Py50cmltKCkpIHtcbiAgICAgICAgICBlcnJvcnMucHVzaChgUm93ICR7aW5kZXggKyAyfTogQ2F0ZWdvcnkgaXMgcmVxdWlyZWRgKVxuICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFbJ2JlZ2lubmVyJywgJ2ludGVybWVkaWF0ZScsICdhZHZhbmNlZCddLmluY2x1ZGVzKGRpZmZpY3VsdHkpKSB7XG4gICAgICAgICAgZXJyb3JzLnB1c2goYFJvdyAke2luZGV4ICsgMn06IERpZmZpY3VsdHkgbXVzdCBiZSAnYmVnaW5uZXInLCAnaW50ZXJtZWRpYXRlJywgb3IgJ2FkdmFuY2VkJ2ApXG4gICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIVsncmVndWxhcicsICdib251cyddLmluY2x1ZGVzKHR5cGUpKSB7XG4gICAgICAgICAgZXJyb3JzLnB1c2goYFJvdyAke2luZGV4ICsgMn06IFR5cGUgbXVzdCBiZSAncmVndWxhcicgb3IgJ2JvbnVzJ2ApXG4gICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBxdWVzdGlvbkRhdGE6IFBhcnRpYWw8UXVpelF1ZXN0aW9uPiA9IHtcbiAgICAgICAgICBpZDogaWQgfHwgYGltcG9ydGVkXyR7RGF0ZS5ub3coKX1fJHtpbmRleH1gLFxuICAgICAgICAgIHF1ZXN0aW9uOiBxdWVzdGlvbi50cmltKCksXG4gICAgICAgICAgb3B0aW9uczogW29wdDEudHJpbSgpLCBvcHQyLnRyaW0oKSwgb3B0My50cmltKCksIG9wdDQudHJpbSgpXSxcbiAgICAgICAgICBjb3JyZWN0QW5zd2VyOiBjb3JyZWN0QW5zd2VyTnVtLFxuICAgICAgICAgIGNhdGVnb3J5OiBjYXRlZ29yeS50cmltKCksXG4gICAgICAgICAgZGlmZmljdWx0eTogZGlmZmljdWx0eSBhcyAnYmVnaW5uZXInIHwgJ2ludGVybWVkaWF0ZScgfCAnYWR2YW5jZWQnLFxuICAgICAgICAgIHR5cGU6IHR5cGUgYXMgJ3JlZ3VsYXInIHwgJ2JvbnVzJyxcbiAgICAgICAgICBmdW5GYWN0OiBmdW5GYWN0Py50cmltKCkgfHwgdW5kZWZpbmVkLFxuICAgICAgICAgIHRhZ3M6IHRhZ3MgPyB0YWdzLnNwbGl0KCc7JykubWFwKHRhZyA9PiB0YWcudHJpbSgpKS5maWx0ZXIoQm9vbGVhbikgOiBbXSxcbiAgICAgICAgICBjcmVhdGVkQXQ6IGNyZWF0ZWRBdCA/IG5ldyBEYXRlKGNyZWF0ZWRBdCkuZ2V0VGltZSgpIDogRGF0ZS5ub3coKSxcbiAgICAgICAgICB1cGRhdGVkQXQ6IHVwZGF0ZWRBdCA/IG5ldyBEYXRlKHVwZGF0ZWRBdCkuZ2V0VGltZSgpIDogRGF0ZS5ub3coKVxuICAgICAgICB9XG5cbiAgICAgICAgcXVlc3Rpb25zLnB1c2gocXVlc3Rpb25EYXRhKVxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgZXJyb3JzLnB1c2goYFJvdyAke2luZGV4ICsgMn06ICR7ZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiAnUGFyc2UgZXJyb3InfWApXG4gICAgICB9XG4gICAgfSlcblxuICAgIHJldHVybiB7IHF1ZXN0aW9ucywgZXJyb3JzIH1cbiAgfVxuXG4gIC8vIEhlbHBlciB0byBwYXJzZSBDU1YgbGluZSB3aXRoIHByb3BlciBxdW90ZSBoYW5kbGluZ1xuICBwcml2YXRlIHBhcnNlQ1NWTGluZShsaW5lOiBzdHJpbmcpOiBzdHJpbmdbXSB7XG4gICAgY29uc3QgcmVzdWx0OiBzdHJpbmdbXSA9IFtdXG4gICAgbGV0IGN1cnJlbnQgPSAnJ1xuICAgIGxldCBpblF1b3RlcyA9IGZhbHNlXG4gICAgbGV0IGkgPSAwXG5cbiAgICB3aGlsZSAoaSA8IGxpbmUubGVuZ3RoKSB7XG4gICAgICBjb25zdCBjaGFyID0gbGluZVtpXVxuXG4gICAgICBpZiAoY2hhciA9PT0gJ1wiJykge1xuICAgICAgICBpZiAoaW5RdW90ZXMgJiYgbGluZVtpICsgMV0gPT09ICdcIicpIHtcbiAgICAgICAgICAvLyBFc2NhcGVkIHF1b3RlXG4gICAgICAgICAgY3VycmVudCArPSAnXCInXG4gICAgICAgICAgaSArPSAyXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gVG9nZ2xlIHF1b3RlIHN0YXRlXG4gICAgICAgICAgaW5RdW90ZXMgPSAhaW5RdW90ZXNcbiAgICAgICAgICBpKytcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChjaGFyID09PSAnLCcgJiYgIWluUXVvdGVzKSB7XG4gICAgICAgIC8vIEVuZCBvZiBmaWVsZFxuICAgICAgICByZXN1bHQucHVzaChjdXJyZW50KVxuICAgICAgICBjdXJyZW50ID0gJydcbiAgICAgICAgaSsrXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjdXJyZW50ICs9IGNoYXJcbiAgICAgICAgaSsrXG4gICAgICB9XG4gICAgfVxuXG4gICAgcmVzdWx0LnB1c2goY3VycmVudCkgLy8gQWRkIGxhc3QgZmllbGRcbiAgICByZXR1cm4gcmVzdWx0XG4gIH1cblxuICAvLyBJbXBvcnQgZnJvbSBDU1ZcbiAgaW1wb3J0RnJvbUNTVihjc3ZDb250ZW50OiBzdHJpbmcpOiBCdWxrT3BlcmF0aW9uUmVzdWx0IHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgeyBxdWVzdGlvbnMsIGVycm9ycyB9ID0gdGhpcy5wYXJzZUNTVihjc3ZDb250ZW50KVxuXG4gICAgICBpZiAoZXJyb3JzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgICBwcm9jZXNzZWRDb3VudDogMCxcbiAgICAgICAgICBlcnJvckNvdW50OiBlcnJvcnMubGVuZ3RoLFxuICAgICAgICAgIGVycm9yc1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGxldCBzdWNjZXNzQ291bnQgPSAwXG4gICAgICBjb25zdCBpbXBvcnRFcnJvcnM6IHN0cmluZ1tdID0gW11cblxuICAgICAgcXVlc3Rpb25zLmZvckVhY2goKHF1ZXN0aW9uRGF0YSwgaW5kZXgpID0+IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjb25zdCBmdWxsUXVlc3Rpb246IFF1aXpRdWVzdGlvbiA9IHtcbiAgICAgICAgICAgIGlkOiBxdWVzdGlvbkRhdGEuaWQhLFxuICAgICAgICAgICAgcXVlc3Rpb246IHF1ZXN0aW9uRGF0YS5xdWVzdGlvbiEsXG4gICAgICAgICAgICBvcHRpb25zOiBxdWVzdGlvbkRhdGEub3B0aW9ucyEsXG4gICAgICAgICAgICBjb3JyZWN0QW5zd2VyOiBxdWVzdGlvbkRhdGEuY29ycmVjdEFuc3dlciEsXG4gICAgICAgICAgICBjYXRlZ29yeTogcXVlc3Rpb25EYXRhLmNhdGVnb3J5ISxcbiAgICAgICAgICAgIGRpZmZpY3VsdHk6IHF1ZXN0aW9uRGF0YS5kaWZmaWN1bHR5ISxcbiAgICAgICAgICAgIHR5cGU6IHF1ZXN0aW9uRGF0YS50eXBlISxcbiAgICAgICAgICAgIGZ1bkZhY3Q6IHF1ZXN0aW9uRGF0YS5mdW5GYWN0LFxuICAgICAgICAgICAgdGFnczogcXVlc3Rpb25EYXRhLnRhZ3MgfHwgW10sXG4gICAgICAgICAgICBjcmVhdGVkQXQ6IHF1ZXN0aW9uRGF0YS5jcmVhdGVkQXQhLFxuICAgICAgICAgICAgdXBkYXRlZEF0OiBxdWVzdGlvbkRhdGEudXBkYXRlZEF0IVxuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIFZhbGlkYXRlIHRoZSBjb21wbGV0ZSBxdWVzdGlvblxuICAgICAgICAgIGNvbnN0IHZhbGlkYXRpb24gPSB0aGlzLnZhbGlkYXRlUXVlc3Rpb24oZnVsbFF1ZXN0aW9uKVxuICAgICAgICAgIGlmICghdmFsaWRhdGlvbi5pc1ZhbGlkKSB7XG4gICAgICAgICAgICBpbXBvcnRFcnJvcnMucHVzaChgUXVlc3Rpb24gJHtpbmRleCArIDF9OiAke3ZhbGlkYXRpb24uZXJyb3JzLmpvaW4oJywgJyl9YClcbiAgICAgICAgICAgIHJldHVyblxuICAgICAgICAgIH1cblxuICAgICAgICAgIHRoaXMuc2F2ZVF1ZXN0aW9uKGZ1bGxRdWVzdGlvbilcbiAgICAgICAgICBzdWNjZXNzQ291bnQrK1xuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgIGltcG9ydEVycm9ycy5wdXNoKGBRdWVzdGlvbiAke2luZGV4ICsgMX06ICR7ZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiAnU2F2ZSBlcnJvcid9YClcbiAgICAgICAgfVxuICAgICAgfSlcblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc3VjY2VzczogaW1wb3J0RXJyb3JzLmxlbmd0aCA9PT0gMCxcbiAgICAgICAgcHJvY2Vzc2VkQ291bnQ6IHN1Y2Nlc3NDb3VudCxcbiAgICAgICAgZXJyb3JDb3VudDogaW1wb3J0RXJyb3JzLmxlbmd0aCxcbiAgICAgICAgZXJyb3JzOiBpbXBvcnRFcnJvcnNcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICAgIHByb2Nlc3NlZENvdW50OiAwLFxuICAgICAgICBlcnJvckNvdW50OiAxLFxuICAgICAgICBlcnJvcnM6IFtlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6ICdJbXBvcnQgZmFpbGVkJ11cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLy8gRXhwb3J0IHNpbmdsZXRvbiBpbnN0YW5jZVxuZXhwb3J0IGNvbnN0IHF1aXpEYXRhTWFuYWdlciA9IFF1aXpEYXRhTWFuYWdlci5nZXRJbnN0YW5jZSgpXG4iXSwibmFtZXMiOlsiUVVJWl9TVE9SQUdFX0tFWVMiLCJERUZBVUxUX0NBVEVHT1JJRVMiLCJWQUxJREFUSU9OX1JVTEVTIiwiUVVFU1RJT05fTUlOX0xFTkdUSCIsIlFVRVNUSU9OX01BWF9MRU5HVEgiLCJPUFRJT05fTUlOX0xFTkdUSCIsIk9QVElPTl9NQVhfTEVOR1RIIiwiTUlOX09QVElPTlMiLCJNQVhfT1BUSU9OUyIsIk1BWF9CVUxLX09QRVJBVElPTlMiLCJNQVhfRklMRV9TSVpFIiwiQVVUT19TQVZFX0lOVEVSVkFMIiwiUXVpekRhdGFFcnJvciIsIkVycm9yIiwibWVzc2FnZSIsImNvZGUiLCJuYW1lIiwiUXVpekRhdGFNYW5hZ2VyIiwiZ2V0SW5zdGFuY2UiLCJpbnN0YW5jZSIsInNhZmVHZXRJdGVtIiwia2V5IiwibG9jYWxTdG9yYWdlIiwiZ2V0SXRlbSIsImVycm9yIiwiY29uc29sZSIsInNhZmVTZXRJdGVtIiwidmFsdWUiLCJzZXRJdGVtIiwiRE9NRXhjZXB0aW9uIiwiZ2V0UXVlc3Rpb25zIiwiZGF0YSIsIlFVRVNUSU9OUyIsImluaXRpYWxpemVXaXRoU2FtcGxlRGF0YSIsInF1ZXN0aW9ucyIsIkpTT04iLCJwYXJzZSIsIkFycmF5IiwiaXNBcnJheSIsImdldEZpbHRlcmVkUXVlc3Rpb25zIiwiZmlsdGVycyIsImZpbHRlciIsInF1ZXN0aW9uIiwiY2F0ZWdvcnkiLCJkaWZmaWN1bHR5IiwidHlwZSIsInNlY3Rpb24iLCJzdWJjYXRlZ29yeSIsInRhZ3MiLCJzb21lIiwidGFnIiwiaW5jbHVkZXMiLCJnZXRRdWVzdGlvbnNCeVNlY3Rpb24iLCJnZXRRdWVzdGlvbnNCeUNhdGVnb3J5QW5kU2VjdGlvbiIsInNhdmVRdWVzdGlvbiIsInZhbGlkYXRlUXVlc3Rpb24iLCJub3ciLCJEYXRlIiwibmV3UXVlc3Rpb24iLCJpZCIsImdlbmVyYXRlSWQiLCJjcmVhdGVkQXQiLCJ1cGRhdGVkQXQiLCJwdXNoIiwic2F2ZVF1ZXN0aW9ucyIsInVwZGF0ZVF1ZXN0aW9uIiwidXBkYXRlcyIsImluZGV4IiwiZmluZEluZGV4IiwicSIsInVwZGF0ZWRRdWVzdGlvbiIsImRlbGV0ZVF1ZXN0aW9uIiwiZmlsdGVyZWRRdWVzdGlvbnMiLCJsZW5ndGgiLCJidWxrRGVsZXRlIiwiaWRzIiwiaW5pdGlhbENvdW50IiwiZGVsZXRlZENvdW50Iiwic3VjY2VzcyIsInByb2Nlc3NlZENvdW50IiwiZXJyb3JDb3VudCIsImVycm9ycyIsInNlYXJjaFF1ZXN0aW9ucyIsInNlYXJjaFRleHQiLCJzZWFyY2hMb3dlciIsInRvTG93ZXJDYXNlIiwiZ2V0Q2F0ZWdvcmllcyIsImNhdGVnb3J5Q291bnRzIiwicmVkdWNlIiwiYWNjIiwibWFwIiwicXVlc3Rpb25Db3VudCIsInNhdmVEcmFmdCIsImRyYWZ0IiwiZHJhZnRzIiwiZ2V0RHJhZnRzIiwiZXhpc3RpbmdJbmRleCIsImQiLCJsYXN0U2F2ZWQiLCJEUkFGVFMiLCJzdHJpbmdpZnkiLCJkZWxldGVEcmFmdCIsImdldFNldHRpbmdzIiwiU0VUVElOR1MiLCJnZXREZWZhdWx0U2V0dGluZ3MiLCJzYXZlU2V0dGluZ3MiLCJzZXR0aW5ncyIsImN1cnJlbnRTZXR0aW5ncyIsInVwZGF0ZWRTZXR0aW5ncyIsInBhZ2VTaXplIiwic29ydEJ5Iiwic29ydE9yZGVyIiwic2VsZWN0ZWRRdWVzdGlvbnMiLCJvcHRpb25zIiwiZm9yRWFjaCIsIm9wdGlvbiIsInVuaXF1ZU9wdGlvbnMiLCJTZXQiLCJvcHQiLCJ0cmltIiwic2l6ZSIsImNvcnJlY3RBbnN3ZXIiLCJ2YWxpZENhdGVnb3JpZXMiLCJjIiwiTWF0aCIsInJhbmRvbSIsInRvU3RyaW5nIiwic3Vic3RyIiwiZXhwb3J0VG9DU1YiLCJxdWVzdGlvbnNUb0V4cG9ydCIsImhlYWRlcnMiLCJjc3ZSb3dzIiwiam9pbiIsInJlcGxhY2UiLCJmdW5GYWN0IiwidG9JU09TdHJpbmciLCJpbXBvcnRGcm9tQ1NWIiwiY3N2Q29udGVudCIsImxpbmVzIiwic3BsaXQiLCJsaW5lIiwiaCIsImRhdGFMaW5lcyIsInNsaWNlIiwicmVzdWx0cyIsInZhbGlkUXVlc3Rpb25zIiwiZXhpc3RpbmdRdWVzdGlvbnMiLCJpIiwidmFsdWVzIiwicGFyc2VDU1ZMaW5lIiwicGFyc2VJbnQiLCJ1bmRlZmluZWQiLCJ0IiwiZ2V0VGltZSIsImFsbFF1ZXN0aW9ucyIsInJlc3VsdCIsImN1cnJlbnQiLCJpblF1b3RlcyIsImNoYXIiLCJzaG91bGRJbXBvcnRFeGlzdGluZ1F1ZXN0aW9ucyIsImltcG9ydEFsbEV4aXN0aW5nUXVlc3Rpb25zIiwic2FtcGxlUXVlc3Rpb25zIiwiaGFzSW1wb3J0ZWQiLCJvbmJvYXJkaW5nUXVlc3Rpb25zIiwiaW1wb3J0T25ib2FyZGluZ1F1ZXN0aW9ucyIsImhvbWVwYWdlUXVlc3Rpb25zIiwiaW1wb3J0SG9tZXBhZ2VRdWVzdGlvbnMiLCJjYXRlZ29yeVF1ZXN0aW9ucyIsImltcG9ydENhdGVnb3J5UXVlc3Rpb25zIiwibG9nIiwicmV3YXJkQ29pbnMiLCJzYW1wbGVDYXRlZ29yeVF1ZXN0aW9ucyIsImZvcmNlUmVpbXBvcnRRdWVzdGlvbnMiLCJpbXBvcnRlZFF1ZXN0aW9ucyIsImNyZWF0ZUJhY2t1cCIsImJhY2t1cCIsInRpbWVzdGFtcCIsInZlcnNpb24iLCJyZXN0b3JlRnJvbUJhY2t1cCIsImJhY2t1cERhdGEiLCJjdXJyZW50QmFja3VwIiwiQkFDS1VQIiwic3RhcnRBdXRvU2F2ZSIsImRyYWZ0SWQiLCJnZXREcmFmdERhdGEiLCJzdG9wQXV0b1NhdmUiLCJhdXRvU2F2ZVRpbWVyIiwic2V0SW50ZXJ2YWwiLCJkcmFmdERhdGEiLCJjbGVhckludGVydmFsIiwicm93IiwiZG93bmxvYWRDU1YiLCJibG9iIiwiQmxvYiIsImxpbmsiLCJkb2N1bWVudCIsImNyZWF0ZUVsZW1lbnQiLCJkb3dubG9hZCIsInVybCIsIlVSTCIsImNyZWF0ZU9iamVjdFVSTCIsInNldEF0dHJpYnV0ZSIsInN0eWxlIiwidmlzaWJpbGl0eSIsImJvZHkiLCJhcHBlbmRDaGlsZCIsImNsaWNrIiwicmVtb3ZlQ2hpbGQiLCJyZXZva2VPYmplY3RVUkwiLCJwYXJzZUNTViIsIm9wdDEiLCJvcHQyIiwib3B0MyIsIm9wdDQiLCJjb3JyZWN0QW5zd2VyTnVtIiwiaXNOYU4iLCJxdWVzdGlvbkRhdGEiLCJCb29sZWFuIiwic3VjY2Vzc0NvdW50IiwiaW1wb3J0RXJyb3JzIiwiZnVsbFF1ZXN0aW9uIiwidmFsaWRhdGlvbiIsImlzVmFsaWQiLCJxdWl6RGF0YU1hbmFnZXIiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/utils/quizDataManager.ts\n"));

/***/ })

});